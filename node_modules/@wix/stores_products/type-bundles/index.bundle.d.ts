type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface Product {
    /**
     * Product ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string;
    /**
     * Product name.
     *
     * Min: 1 character
     * Max: 80 characters
     */
    name?: string | null;
    /** A friendly URL name (generated automatically by the catalog when a product is created), can be updated. */
    slug?: string;
    /** Whether the product is visible to site visitors. */
    visible?: boolean | null;
    /** Currently, only creating physical products ( `"productType": "physical"` ) is supported via the API. */
    productType?: ProductType;
    /** Product description. */
    description?: string | null;
    /** Stock keeping unit. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, SKUs will be set per variant, and this field will be empty. */
    sku?: string | null;
    /** Product weight. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, weight will be set per variant, and this field will be empty. */
    weight?: number | null;
    /**
     * Product weight range. The minimum and maximum weights of all the variants.
     * @readonly
     */
    weightRange?: NumericPropertyRange;
    /**
     * Product inventory status (in future this will be writable via Inventory API).
     * @readonly
     */
    stock?: Stock;
    /**
     * Deprecated (use `priceData` instead).
     * @readonly
     * @deprecated
     */
    price?: PriceData;
    /** Price data. */
    priceData?: PriceData;
    /**
     * Price data, converted to the currency specified in request header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /**
     * Product price range. The minimum and maximum prices of all the variants.
     * @readonly
     */
    priceRange?: NumericPropertyRange;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData;
    /**
     * Product cost range. The minimum and maximum costs of all the variants.
     * @readonly
     */
    costRange?: NumericPropertyRange;
    /** Price per unit data. */
    pricePerUnitData?: PricePerUnitData;
    /** Additional text that the store owner can assign to the product (e.g. shipping details, refund policy, etc.). */
    additionalInfoSections?: AdditionalInfoSection[];
    /**
     * Deprecated (use `ribbon` instead).
     * @readonly
     * @deprecated
     */
    ribbons?: Ribbon[];
    /**
     * Media items (images, videos etc) associated with this product (writable via [Add Product Media](https://dev.wix.com/api/rest/wix-stores/catalog/products/add-product-media) endpoint).
     * @readonly
     */
    media?: Media;
    /**
     * Text box for the customer to add a message to their order (e.g., customization request). Currently writable only from the UI.
     * @readonly
     */
    customTextFields?: CustomTextField[];
    /** Whether variants are being managed for this product - enables unique SKU, price and weight per variant. Also affects inventory data. Once set to `true`, can be reset to `false` only if no variants exist. You cannot set `manageVariants` to `true` if more than 300 variants are defined. */
    manageVariants?: boolean | null;
    /** Options for this product. */
    productOptions?: ProductOption[];
    /**
     * Product page URL for this product (generated automatically by the server).
     * @readonly
     */
    productPageUrl?: PageUrl;
    /**
     * Product’s unique numeric ID (assigned in ascending order).
     * Primarily used for sorting and filtering when crawling all products.
     * @readonly
     */
    numericId?: string;
    /**
     * Inventory item ID - ID referencing the inventory system.
     * @readonly
     */
    inventoryItemId?: string;
    /** Discount deducted from the product's original price. */
    discount?: Discount;
    /**
     * A list of all collection IDs that this product is included in (writable via the Catalog > Collection APIs).
     * @readonly
     */
    collectionIds?: string[];
    /**
     * Product variants, will be provided if the the request was sent with the `includeVariants: true`.
     *
     * Max: 1,000 variants
     * @readonly
     */
    variants?: Variant[];
    /**
     * Date and time the product was last updated.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Date and time the product was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /** Custom SEO data for the product. */
    seoData?: SeoSchema;
    /** Product ribbon. Used to highlight relevant information about a product. For example, "Sale", "New Arrival", "Sold Out". */
    ribbon?: string | null;
    /** Product brand. Including a brand name can help improve site and product [visibility on search engines](https://support.wix.com/en/article/adding-brand-names-to-boost-product-page-seo-in-wix-stores). */
    brand?: string | null;
}
declare enum ProductType {
    unspecified_product_type = "unspecified_product_type",
    physical = "physical",
    digital = "digital"
}
interface NumericPropertyRange {
    /** Minimum value. */
    minValue?: number;
    /** Maximum value. */
    maxValue?: number;
}
interface Stock {
    /** Whether inventory is being tracked */
    trackInventory?: boolean;
    /** Quantity currently left in inventory */
    quantity?: number | null;
    /**
     * Whether the product is currently in stock (relevant only when tracking manually)
     * Deprecated (use `inventoryStatus` instead)
     * @deprecated
     */
    inStock?: boolean;
    /**
     * The current status of the inventory
     * + `IN_STOCK` - In stock
     * + `OUT_OF_STOCK` - Not in stock
     * + `PARTIALLY_OUT_OF_STOCK` - Some of the variants are not in stock
     */
    inventoryStatus?: InventoryStatus;
}
declare enum InventoryStatus {
    IN_STOCK = "IN_STOCK",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    PARTIALLY_OUT_OF_STOCK = "PARTIALLY_OUT_OF_STOCK"
}
interface PriceData {
    /**
     * Product price currency
     * @readonly
     */
    currency?: string;
    /** Product price */
    price?: number | null;
    /**
     * Discounted product price (if no discounted price is set, the product price is returned)
     * @readonly
     */
    discountedPrice?: number;
    /**
     * The product price and discounted price, formatted with the currency
     * @readonly
     */
    formatted?: FormattedPrice;
    /**
     * Price per unit
     * @readonly
     */
    pricePerUnit?: number | null;
}
interface FormattedPrice {
    /** Product price formatted with the currency */
    price?: string;
    /** Discounted product price formatted with the currency (if no discounted price is set, the product formatted price is returned) */
    discountedPrice?: string;
    /**
     * Price per unit
     * @readonly
     */
    pricePerUnit?: string | null;
}
interface CostAndProfitData {
    /** Item cost. */
    itemCost?: number | null;
    /**
     * Item cost formatted with currency symbol.
     * @readonly
     */
    formattedItemCost?: string;
    /**
     * Profit. Calculated by reducing `cost` from `discounted_price`.
     * @readonly
     */
    profit?: number;
    /**
     * Profit formatted with currency symbol.
     * @readonly
     */
    formattedProfit?: string;
    /**
     * Profit Margin. Calculated by dividing `profit` by `discounted_price`.
     * The result is rounded to 4 decimal places.
     * @readonly
     */
    profitMargin?: number;
}
interface PricePerUnitData {
    /** Total quantity */
    totalQuantity?: number;
    /** Total measurement unit */
    totalMeasurementUnit?: MeasurementUnit;
    /** Base quantity */
    baseQuantity?: number;
    /** Base measurement unit */
    baseMeasurementUnit?: MeasurementUnit;
}
declare enum MeasurementUnit {
    UNSPECIFIED = "UNSPECIFIED",
    ML = "ML",
    CL = "CL",
    L = "L",
    CBM = "CBM",
    MG = "MG",
    G = "G",
    KG = "KG",
    MM = "MM",
    CM = "CM",
    M = "M",
    SQM = "SQM",
    OZ = "OZ",
    LB = "LB",
    FLOZ = "FLOZ",
    PT = "PT",
    QT = "QT",
    GAL = "GAL",
    IN = "IN",
    FT = "FT",
    YD = "YD",
    SQFT = "SQFT"
}
interface AdditionalInfoSection {
    /** Product info section title */
    title?: string;
    /** Product info section description */
    description?: string;
}
interface Ribbon {
    /** Ribbon text */
    text?: string;
}
interface Media {
    /** Primary media (image, video etc) associated with this product. */
    mainMedia?: MediaItem;
    /** Media (images, videos etc) associated with this product. */
    items?: MediaItem[];
}
interface MediaItem extends MediaItemItemOneOf {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize;
    /** Video data (URL, size). */
    video?: MediaItemVideo;
    /** Media item thumbnail details. */
    thumbnail?: MediaItemUrlAndSize;
    /** Media item type (image, video, etc.). */
    mediaType?: MediaItemType;
    /** Media item title. */
    title?: string;
    /** Media ID (for example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`). */
    _id?: string;
}
/** @oneof */
interface MediaItemItemOneOf {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize;
    /** Video data (URL, size). */
    video?: MediaItemVideo;
}
interface MediaItemUrlAndSize {
    /** Media item URL. */
    url?: string;
    /** Media item width. */
    width?: number;
    /** Media item height. */
    height?: number;
    /** Media format (mp4, png, etc.). */
    format?: string | null;
    /** Alt text. This text will be shown in case the image is not available. */
    altText?: string | null;
}
declare enum MediaItemType {
    unspecified_media_item_type = "unspecified_media_item_type",
    image = "image",
    video = "video",
    audio = "audio",
    document = "document",
    zip = "zip"
}
interface MediaItemVideo {
    /** Data (URL, size) about each resolution for which this video is available. */
    files?: MediaItemUrlAndSize[];
    /** ID of an image taken from the video. Used primarily for Wix Search indexing. For example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`. */
    stillFrameMediaId?: string;
}
interface CustomTextField {
    /** Text box title */
    title?: string;
    /** Text box input max length */
    maxLength?: number;
    /** Whether this text box is mandatory */
    mandatory?: boolean;
}
interface ProductOption {
    /**
     * Option type - color or other(drop down)
     * @readonly
     */
    optionType?: OptionType;
    /** Option name. */
    name?: string;
    /** Choices available for this option. */
    choices?: Choice[];
}
declare enum OptionType {
    unspecified_option_type = "unspecified_option_type",
    drop_down = "drop_down",
    color = "color"
}
interface Choice {
    /** Choice value. */
    value?: string;
    /** Choice description. */
    description?: string;
    /**
     * Media items (images, videos) associated with this choice
     * @readonly
     */
    media?: Media;
    /**
     * Based on the customer’s choices, which (if any) variants that include the selected choices are in stock
     * @readonly
     */
    inStock?: boolean;
    /**
     * Based on the customer’s choices, which (if any) variants that include the selected choices are visible
     * @readonly
     */
    visible?: boolean;
}
interface PageUrl {
    /** Base URL. For premium sites, this is the domain. For free sites, this is the site URL (e.g mysite.wixsite.com/mysite). */
    base?: string;
    /** Path to the product page - e.g /product-page/a-product. */
    path?: string;
}
interface Discount {
    /**
     * Discount type:
     * + `"AMOUNT"`
     * + `"PERCENT"`
     */
    type?: DiscountType;
    /** Discount value */
    value?: number;
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** No discount */
    NONE = "NONE",
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface Variant {
    /** Requested Variant ID */
    _id?: string;
    /** Specific choices within a selection, as option-choice key-value pairs */
    choices?: Record<string, string>;
    variant?: VariantDataWithNoStock;
    /**
     * Variant inventory status.
     * @readonly
     */
    stock?: VariantStock;
}
interface VariantDataWithNoStock {
    /** Variant price. */
    priceData?: PriceData;
    /**
     * Variant price data, converted to currency requested in header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData;
    /** Variant weight. */
    weight?: number;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Whether the variant is visible to customers. */
    visible?: boolean;
}
interface VariantStock {
    /** Whether inventory is being tracked. */
    trackQuantity?: boolean;
    /** Quantity currently left in inventory. */
    quantity?: number | null;
    /** Whether the product is currently in stock (relevant only when tracking manually). */
    inStock?: boolean;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /** The source that added the keyword terms to the SEO settings. */
    origin?: string | null;
}
interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
     * For example: `{'name': 'description', 'content': 'the description itself'}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /** User-selected keyword terms for a specific page. */
    keywords?: Keyword[];
}
interface SecuredMedia {
    /** Media ID in Wix Media Manager. */
    _id?: string;
    /** Original filename. */
    fileName?: string;
    /** File type. */
    fileType?: FileType;
}
declare enum FileType {
    UNSPECIFIED = "UNSPECIFIED",
    SECURE_PICTURE = "SECURE_PICTURE",
    SECURE_VIDEO = "SECURE_VIDEO",
    SECURE_DOCUMENT = "SECURE_DOCUMENT",
    SECURE_MUSIC = "SECURE_MUSIC",
    SECURE_ARCHIVE = "SECURE_ARCHIVE"
}
interface CreateProductRequest {
    /** Product information. */
    product?: Product;
}
interface CreateProductResponse {
    product?: Product;
}
interface CreateProductPlatformizedRequest {
    /** Product information. */
    product?: Product;
}
interface CreateProductPlatformizedResponse {
    product?: Product;
}
interface CreateDigitalProductRequest {
    /** Product information. */
    product?: Product;
}
interface CreateDigitalProductResponse {
    /** Created product. */
    product?: Product;
}
interface UpdateProductRequest {
    product: Product;
}
interface UpdateProductResponse {
    product?: Product;
}
interface UpdateProductPlatformizedRequest {
    product?: Product;
}
interface UpdateProductPlatformizedResponse {
    product?: Product;
}
interface DeleteProductRequest {
    /** ID of the product to delete. */
    _id: string;
}
interface DeleteProductResponse {
}
interface DeleteProductPlatformizedRequest {
    /** ID of the product to delete. */
    _id?: string;
}
interface DeleteProductPlatformizedResponse {
}
interface BulkDeleteProductsRequest {
    /** IDs of the products to be deleted. */
    ids?: string[];
}
interface BulkDeleteProductsResponse {
}
interface UpdateVariantsRequest {
    /** ID of the product with managed variants. */
    _id: string;
    /** Variant info to update. */
    variants?: VariantOverride[];
}
interface VariantOverride {
    /** The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice). You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (Not relevant when passing variant IDs) */
    choices?: Record<string, string>;
    /**
     * List of variant IDs
     * (Not relevant when passing choices)
     */
    variantIds?: string[];
    /** Variant price */
    price?: number | null;
    /** Variant cost of goods */
    cost?: number | null;
    /** Variant weight */
    weight?: number | null;
    /** Variant SKU (stock keeping unit) */
    sku?: string | null;
    /** Whether the variant is visible to  customers */
    visible?: boolean | null;
}
interface UpdateVariantsResponse {
    /** List of the product's variants. */
    variants?: Variant[];
}
interface ResetAllVariantDataRequest {
    /** Product ID. */
    _id: string;
}
interface ResetAllVariantDataResponse {
}
interface AddProductsToCollectionRequest {
    /** Collection ID. */
    _id: string;
    /** IDs of the products to add to the collection, separated by commas. */
    productIds?: string[];
}
interface AddProductsToCollectionResponse {
}
interface RemoveProductsFromCollectionRequest {
    /** ID of the collection from which to remove products. */
    _id: string;
    /** IDs of the products to remove from the collection. */
    productIds: string[];
}
interface RemoveProductsFromCollectionResponse {
}
interface AddProductMediaRequest {
    /** Product ID. */
    _id: string;
    /** Sources of media items already uploaded to the Wix site. */
    media?: MediaDataForWrite[];
}
interface MediaDataForWrite extends MediaDataForWriteMediaSourceOneOf {
    /** Media ID. */
    mediaId?: string;
    /** Media external URL (for new media items). */
    url?: string;
    /** Assign this media item to a specific product choice. Note that you may set media items for choices under only one option (e.g., if Colors blue, green, and red have media items, Sizes S, M, and L can't have media items assigned to them). You may clear existing media from choices with the [Remove Product Media From Choices](#removeproductmediafromchoices). */
    choice?: OptionAndChoice;
}
/** @oneof */
interface MediaDataForWriteMediaSourceOneOf {
    /** Media ID. */
    mediaId?: string;
    /** Media external URL (for new media items). */
    url?: string;
}
interface OptionAndChoice {
    /** Option to add the media to. */
    option?: string;
    /** Choice to add the media to. */
    choice?: string;
}
interface AddProductMediaResponse {
}
interface RemoveProductMediaRequest {
    /** Product ID. */
    _id: string;
    /** List of media IDs to remove. Pass an empty array to delete all media items for the product. */
    mediaIds?: string[];
}
interface RemoveProductMediaResponse {
}
interface AddProductMediaToChoicesRequest {
    /** Product ID. */
    _id: string;
    /** Product media items and the choices to add the media to. */
    media?: MediaAssignmentToChoice[];
}
interface MediaAssignmentToChoice {
    /** Option name. */
    option?: string;
    /** Choice name. */
    choice?: string;
    /** Media IDs (available via the Query Product endpoint). */
    mediaIds?: string[];
}
interface AddProductMediaToChoicesResponse {
}
interface RemoveProductMediaFromChoicesRequest {
    /** Product ID from whose choices to remove media items. */
    _id: string;
    /** Media to remove from choices. If an empty array is passed, all media will be removed from all choices for the given product. */
    media?: MediaAssignmentToChoice[];
}
interface RemoveProductMediaFromChoicesResponse {
}
interface DeleteProductOptionsRequest {
    /** ID of the product with options to delete. */
    _id: string;
}
interface DeleteProductOptionsResponse {
}
interface SetCustomFieldsRequest {
    /** Product ID. */
    _id?: string;
    /** Custom field that will be added, if a custom field with the same name already exists, the value of the custom field will be overridden. */
    customFields?: Record<string, any>;
}
interface SetCustomFieldsResponse {
}
interface RemoveCustomFieldsRequest {
    /** Product ID. */
    _id?: string;
    /** Custom fields to be removed (by name). */
    names?: string[];
}
interface RemoveCustomFieldsResponse {
}
interface RemoveProductBrandRequest {
    /** Product ID. */
    _id: string;
}
interface RemoveProductBrandResponse {
}
interface BulkSetCustomFieldsRequest {
    /** Filter string. */
    filter?: string | null;
    /** Custom field that will be added, if a custom field with same name already exists, the value of the custom field will be overridden. */
    customFields?: Record<string, any>;
}
interface BulkSetCustomFieldsResponse {
}
interface BulkRemoveCustomFieldsRequest {
    /** Filter string. */
    filter?: string | null;
    /** Custom fields names. */
    names?: string[];
}
interface BulkRemoveCustomFieldsResponse {
}
interface CreateCollectionRequest {
    /** Collection info. */
    collection: Collection;
}
interface Collection {
    /**
     * Collection ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string | null;
    /** Collection name. */
    name?: string | null;
    /**
     * Media items (images, videos etc) associated with this collection. Read only.
     * @readonly
     */
    media?: Media;
    /**
     * Number of products in the collection. Read only.
     * @readonly
     */
    numberOfProducts?: number;
    /** Collection description. */
    description?: string | null;
    /** Collection slug. */
    slug?: string | null;
    /** Collection visibility. Only impacts dynamic pages, no impact on static pages. Default: `true`. */
    visible?: boolean | null;
}
interface CreateCollectionResponse {
    /** Collection. */
    collection?: Collection;
}
interface UpdateCollectionRequest {
    /** Collection info. */
    collection: Collection;
}
interface UpdateCollectionResponse {
    /** Updated collection. */
    collection?: Collection;
}
interface DeleteCollectionRequest {
    /** ID of the collection to delete. */
    _id: string;
}
interface DeleteCollectionResponse {
}
interface RemoveProductRibbonRequest {
    /** Product ID. */
    _id: string;
}
interface RemoveProductRibbonResponse {
}
interface BulkUpdateProductsRequest {
    /** Product IDs. */
    ids: string[];
    /** Field to update. */
    set?: SetValue;
}
interface SetValue extends SetValueValueOneOf {
    /**
     * Set product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variant prices will be calculated according to the set product price.
     * If variant price is negative after setting new price, the update will fail.
     */
    price?: number;
    /**
     * Set product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be set per variant.
     */
    cost?: number;
    /**
     * Set product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be set per variant.
     */
    weight?: number;
    /** Set product ribbon. Pass empty string to remove existing ribbon. */
    ribbon?: string;
    /** Set product brand. Pass empty string to remove existing brand. */
    brand?: string;
}
/** @oneof */
interface SetValueValueOneOf {
    /**
     * Set product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variant prices will be calculated according to the set product price.
     * If variant price is negative after setting new price, the update will fail.
     */
    price?: number;
    /**
     * Set product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be set per variant.
     */
    cost?: number;
    /**
     * Set product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be set per variant.
     */
    weight?: number;
    /** Set product ribbon. Pass empty string to remove existing ribbon. */
    ribbon?: string;
    /** Set product brand. Pass empty string to remove existing brand. */
    brand?: string;
}
interface BulkUpdateProductsResponse {
    /** Bulk action results. */
    results?: BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkProductResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateProductsByFilterSyncRequest {
    /** Filter object. Learn more about supported filters [here](https://bo.wix.com/wix-docs/rest/stores/stores-catalog/filter-and-sort). */
    filter?: Record<string, any> | null;
    /** The field to update. */
    set?: SetValue;
}
interface BulkUpdateProductsByFilterSyncResponse {
    /** Items updated by bulk action. */
    results?: BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface AllowedProductsCountLimitExceededErrorData {
    /** Total number of products */
    totalCount?: number;
}
interface BulkAdjustProductPropertiesRequest {
    /** Product IDs. */
    ids: string[];
    /** Numerical property to adjust. */
    adjust?: AdjustValue;
}
interface AdjustValue extends AdjustValueValueOneOf {
    /**
     * Adjust product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variants prices will be calculated according to the adjusted price.
     * If variant price is negative after the adjustment, the update will fail.
     */
    price?: PropertyAdjustmentData;
    /**
     * Adjust product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be adjusted per variant.
     */
    cost?: PropertyAdjustmentData;
    /**
     * Adjust product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be adjusted per variant.
     */
    weight?: PropertyAdjustmentData;
}
/** @oneof */
interface AdjustValueValueOneOf {
    /**
     * Adjust product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variants prices will be calculated according to the adjusted price.
     * If variant price is negative after the adjustment, the update will fail.
     */
    price?: PropertyAdjustmentData;
    /**
     * Adjust product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be adjusted per variant.
     */
    cost?: PropertyAdjustmentData;
    /**
     * Adjust product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be adjusted per variant.
     */
    weight?: PropertyAdjustmentData;
}
interface PropertyAdjustmentData extends PropertyAdjustmentDataByOneOf {
    /** Adjust by percentage. */
    percentage?: PercentageData;
    /** Adjust by amount. */
    amount?: number;
}
/** @oneof */
interface PropertyAdjustmentDataByOneOf {
    /** Adjust by percentage. */
    percentage?: PercentageData;
    /** Adjust by amount. */
    amount?: number;
}
interface PercentageData {
    /**
     * If `true`, result will be rounded to the nearest whole number.
     * If `false`, result will be rounded to 2 places after the decimal point.
     */
    roundToInt?: boolean;
    /**
     * Percentage value, as a whole number (integer) between `-100` and `1000`.
     *
     * For example:
     * + Pass `100` to increase value by 100% (multiply original value by 2).
     * + Pass `1000` to increase value by 1000% (multiply original value by 10).
     * + Pass `-50` to decrease value by 50% (original value is halved).
     */
    rate?: number;
}
interface BulkAdjustProductPropertiesResponse {
    /** Bulk action results. */
    results?: BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkAdjustProductPropertiesByFilterSyncRequest {
    /** Filter object. Learn more about supported filters [here](https://bo.wix.com/wix-docs/rest/stores/stores-catalog/filter-and-sort). */
    filter?: Record<string, any> | null;
    /** Numerical property to adjust. */
    adjust?: AdjustValue;
}
interface BulkAdjustProductPropertiesByFilterSyncResponse {
    /** Items updated by bulk action. */
    results?: BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface ReCloneStoreRequest {
    /** Description of value */
    metasiteId?: string | null;
    originalMetasiteId?: string | null;
}
interface ReCloneStoreResponse {
}
interface V1CreateProductPlatformizedRequest {
    /** Product information. */
    product?: Product;
}
interface V1CreateProductPlatformizedResponse {
    product?: Product;
}
interface V1UpdateProductPlatformizedRequest {
    product?: Product;
}
interface V1UpdateProductPlatformizedResponse {
    product?: Product;
}
interface V1DeleteProductPlatformizedRequest {
    /** ID of the product to delete. */
    _id?: string;
}
interface V1DeleteProductPlatformizedResponse {
}
interface ProductCreated {
    /** Product ID (generated automatically by the catalog). */
    productId?: string;
    /** Product name. */
    name?: string;
    /** Product price. */
    price?: PriceData;
    /** Whether the product is visible to customers. */
    visible?: boolean;
    /** Media items (images, videos, etc.) associated with this product. */
    media?: Media;
    /** Product stock keeping unit (SKU). If variants are being managed, this will be empty. */
    sku?: string;
    /** Product page URL for this product (generated automatically by the server). */
    productPageUrl?: PageUrl;
    /** Product brand. */
    brand?: string | null;
    /** Cost and profit data */
    costAndProfitData?: CostAndProfitData;
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
    /** Event slug. A human readable identifier of the event. */
    slug?: string;
}
declare enum Version {
    V1_CATALOG = "V1_CATALOG",
    V3_CATALOG = "V3_CATALOG"
}
interface ProductChanged {
    /** Product ID. */
    productId?: string;
    /** List of product fields that were changed. */
    changedFields?: string[];
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface ProductDeleted {
    /** ID of the product that was deleted. */
    productId?: string;
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface CollectionCreated {
    /** Collection ID (generated automatically by the catalog). */
    collection_Id?: string;
    /** Collection name. */
    name?: string;
    /** Media items (images, videos, etc.) associated with this collection. */
    media?: Media;
    /** Collection slug */
    slug?: string;
    /** Collection visible status */
    visible?: boolean;
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface CollectionChanged {
    /** Collection ID (generated automatically by the catalog). */
    collection_Id?: string;
    /** List of collection fields that were changed. */
    changedFields?: string[];
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface CollectionDeleted {
    /** ID of the collection that was deleted. */
    collection_Id?: string;
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface VariantsChanged {
    /** Product ID. */
    productId?: string;
    /** List of variants that were changed. */
    variants?: VariantChanged[];
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface VariantChanged {
    /** Variant ID. */
    variantId?: string;
    choices?: Record<string, string>;
    /** List of variant fields that were changed. */
    changedFields?: string[];
    /** Information about the version of the catalog from where this event was triggered. */
    originatedFromVersion?: Version;
}
interface QueryProductsRequest {
    query?: Query;
    /** Whether variants should be included in the response. */
    includeVariants?: boolean;
    /** Whether hidden products should be included in the response. Requires permissions to manage products. */
    includeHiddenProducts?: boolean;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface Query {
    paging?: Paging;
    /** Filter string */
    filter?: string | null;
    /** Sort string */
    sort?: string | null;
}
interface Paging {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface QueryProductsResponse {
    products?: Product[];
    metadata?: PagingMetadata;
    totalResults?: number;
}
interface PagingMetadata {
    /** Amount of items to load per page */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number;
}
interface QueryProductsPlatformizedRequest {
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryProductsPlatformizedResponse {
    products?: Product[];
    metadata?: PlatformPagingMetadata;
}
interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface QueryProductsWithBigPageLimitRequest {
    query?: QueryWithBigPageLimit;
    /** Whether variants should be included in the response. */
    includeVariants?: boolean;
    /** Whether hidden products should be included in the response. Requires permissions to manage products. */
    includeHiddenProducts?: boolean;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface QueryWithBigPageLimit {
    paging?: PagingWithBigLimit;
    /** Filter string */
    filter?: string | null;
    /** Sort string */
    sort?: string | null;
}
interface PagingWithBigLimit {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface GetProductsRequest {
    /** Requested product IDs. */
    ids?: string[];
}
interface GetProductsResponse {
    products?: Product[];
}
interface GetProductRequest {
    /** Requested product ID. */
    _id: string;
    /** Whether merchant specific data, such as cost and profit data, should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface GetProductResponse {
    /** Requested product data. */
    product?: Product;
}
interface GetProductPlatformizedRequest {
    /** Requested product ID. */
    _id?: string;
    /** Whether merchant specific data, such as cost and profit data, should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface GetProductPlatformizedResponse {
    /** Requested product data. */
    product?: Product;
}
interface QueryCollectionsRequest {
    /** Query options. */
    query?: Query;
    /** Whether number of products should be included in the response. */
    includeNumberOfProducts?: boolean;
    /** Wether to include collection description in the response. When `false` is passed, `collection.description` will return null. */
    includeDescription?: boolean;
}
interface QueryCollectionsResponse {
    /** List of collections. */
    collections?: Collection[];
    /** Details on the paged set of results returned. */
    metadata?: PagingMetadata;
    /** Total number of results returned. */
    totalResults?: number;
}
interface QueryCollectionsPlatformizedRequest {
    query?: PlatformQuery;
}
interface QueryCollectionsPlatformizedResponse {
    collections?: Collection[];
    metadata?: PlatformPagingMetadata;
}
interface GetCollectionRequest {
    /** Requested collection ID. */
    _id?: string;
    /**
     * Whether to return the `collection.numberOfProducts` field in the response.
     * Defaults to `false`, in which case the value of `collection.numberOfProducts` will be `0`.
     */
    includeNumberOfProducts?: boolean;
}
interface GetCollectionResponse {
    /** The requested collection. */
    collection?: Collection;
}
interface GetCollectionBySlugRequest {
    /** Slug of the collection to retrieve. */
    slug: string;
}
interface GetCollectionBySlugResponse {
    /** The requested collection. */
    collection?: Collection;
}
interface ProductOptionsAvailabilityRequest {
    /** Requested product ID. */
    _id: string;
    /** Array containing the selected options. For example, `["color": "Blue", "size": "Large"]`. */
    options?: Record<string, string>;
}
interface ProductOptionsAvailabilityResponse {
    /** Variant information, given that all the choices were provided. */
    selectedVariant?: VariantData;
    /** Information about media items (images, videos, etc.) associated with this choice. */
    media?: Media;
    /** Options information (color, size, etc.) for this product, with the inventory and visibility fields updated based on the provided choices. */
    productOptions?: ProductOption[];
    /** Whether all the selected choices result in a visible, in-stock variant. */
    availableForPurchase?: boolean;
}
interface VariantData {
    /** Variant price. */
    price?: PriceData;
    /**
     * Variant price data converted to currency provided in header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /** Variant weight. */
    weight?: number | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Quantity currently in inventory (relevant only when tracking by inventory). */
    quantity?: number | null;
    /** Whether the product is currently in stock (relevant only when tracking manually). */
    inStock?: boolean;
    /** Whether the variant is visible to customers. */
    visible?: boolean;
}
interface QueryProductVariantsRequest {
    /** Requested product ID. */
    _id: string;
    /**
     * The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice).
     * You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (not relevant when passing variant IDs).
     */
    choices?: Record<string, string>;
    /** List of variant IDs (not relevant when passing choices). */
    variantIds?: string[];
    paging?: Paging;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface QueryProductVariantsResponse {
    /** List of variants based on the specified filters and sorting. */
    variants?: Variant[];
    metadata?: PagingMetadata;
    totalResults?: number;
}
interface QueryStoreVariantsRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface QueryStoreVariantsResponse {
    /** List of variants based on the specified filters and sorting. */
    variants?: StoreVariant[];
    /** Details on the paged set of results returned. */
    metadata?: PlatformPagingMetadata;
}
interface StoreVariant {
    /** Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen: {productId}.{variantId}. */
    _id?: string;
    /** Variant ID. */
    variantId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant name. */
    variantName?: string;
    /** Product name. */
    productName?: string;
    /** Whether the variant is managed or represents a product. */
    managedVariant?: boolean;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Variant inventory status. */
    stock?: VariantStock;
    /** The selected options of this variant. For example, `{"Color": "Blue", "Size": "Large"}`. */
    choices?: Record<string, string>;
    /** Collections that include this variant. */
    collectionIds?: string[];
    /**
     * Media items (images, videos) associated with this variant.
     * @readonly
     */
    media?: PlatformMedia;
    /** Preorder information. */
    preorderInfo?: PreorderInfo;
}
interface PlatformMedia extends PlatformMediaMediaOneOf {
    image?: string;
    video?: string;
}
/** @oneof */
interface PlatformMediaMediaOneOf {
    image?: string;
    video?: string;
}
interface VideoResolution {
    /** Video URL. */
    url?: string;
    /** Video height. */
    height?: number;
    /** Video width. */
    width?: number;
    /** Video format for example, mp4, hls. */
    format?: string;
}
interface PreorderInfo {
    /** Whether the item is available for preorder. */
    enabled?: boolean;
    /** A message the buyer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /** Number of products that can be preordered after stock reaches zero. */
    limit?: number | null;
}
interface QueryStoreVariantsWithBigLimitRequest {
    /** Query options. */
    query?: UnlimitedPlatformQuery;
}
/**
 * Don't use it unless you have to and know what you do. Prefer PlatformQuery other than this.
 * It doesn't have max validation for limit but we still MUST have it so implement required validation in your code.
 */
interface UnlimitedPlatformQuery extends UnlimitedPlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: UnlimitedPlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: UnlimitedPlatformCursorPaging;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting[];
}
/** @oneof */
interface UnlimitedPlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: UnlimitedPlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: UnlimitedPlatformCursorPaging;
}
/**
 * Don't use it unless you have to and know what you do. Prefer PlatformPaging or wix.common.Paging other than this.
 * It doesn't have max validation for limit but we still MUST have it so implement required validation in your code.
 */
interface UnlimitedPlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
/**
 * Don't use it unless you have to and know what you do. Prefer PlatformCursorPaging or wix.common.CursorPaging other than this.
 * It doesn't have max validation for limit but we still MUST have it so implement required validation in your code.
 */
interface UnlimitedPlatformCursorPaging {
    /**
     * The number of items to load.
     * Cursor token returned in the query response. To be used on the next query request, but not the first query request.
     */
    limit?: number | null;
    /** Cursor returned in last query response. Should not be provided on first page request */
    cursor?: string | null;
}
interface GetStoreVariantRequest {
    /** Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen. For example, `{productId}-{variantId}`. */
    _id: string;
}
interface GetStoreVariantResponse {
    /** The requested store variant. */
    variant?: StoreVariant;
}
interface QueryCustomFieldsRequest {
    /** Requested product ID. */
    _id?: string;
    /** Requested field names. */
    names?: string[];
}
interface QueryCustomFieldsResponse {
    customFields?: Record<string, any>;
}
interface BulkQueryCustomFieldsRequest {
    /** Filter string. */
    query?: Query;
    /** Requested field names. */
    names?: string[];
}
interface BulkQueryCustomFieldsResponse {
    /** ProductId to Custom Fields Map packed in container. */
    productIdToCustomFields?: Record<string, CustomFieldsContainer>;
    metadata?: PagingMetadata;
    totalResults?: number;
}
interface CustomFieldsContainer {
    customFields?: Record<string, any>;
}
interface AggregateProductsRequest {
    /** Filter applied to original data */
    filter?: Record<string, any> | null;
    /** This is an object defining aggregation itself */
    aggregation?: Record<string, any> | null;
    /** Whether hidden products should be considered. Requires permissions to manage products. */
    includeHiddenProducts?: boolean;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface AggregateProductsResponse {
    aggregates?: Record<string, any> | null;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface NumericPropertyRangeNonNullableFields {
    minValue: number;
    maxValue: number;
}
interface StockNonNullableFields {
    trackInventory: boolean;
    inStock: boolean;
    inventoryStatus: InventoryStatus;
}
interface FormattedPriceNonNullableFields {
    price: string;
    discountedPrice: string;
}
interface PriceDataNonNullableFields {
    currency: string;
    discountedPrice: number;
    formatted?: FormattedPriceNonNullableFields;
}
interface CostAndProfitDataNonNullableFields {
    formattedItemCost: string;
    profit: number;
    formattedProfit: string;
    profitMargin: number;
}
interface PricePerUnitDataNonNullableFields {
    totalQuantity: number;
    totalMeasurementUnit: MeasurementUnit;
    baseQuantity: number;
    baseMeasurementUnit: MeasurementUnit;
}
interface AdditionalInfoSectionNonNullableFields {
    title: string;
    description: string;
}
interface RibbonNonNullableFields {
    text: string;
}
interface MediaItemUrlAndSizeNonNullableFields {
    url: string;
    width: number;
    height: number;
}
interface MediaItemVideoNonNullableFields {
    files: MediaItemUrlAndSizeNonNullableFields[];
    stillFrameMediaId: string;
}
interface MediaItemNonNullableFields {
    image?: MediaItemUrlAndSizeNonNullableFields;
    video?: MediaItemVideoNonNullableFields;
    thumbnail?: MediaItemUrlAndSizeNonNullableFields;
    mediaType: MediaItemType;
    title: string;
    _id: string;
}
interface MediaNonNullableFields {
    mainMedia?: MediaItemNonNullableFields;
    items: MediaItemNonNullableFields[];
}
interface CustomTextFieldNonNullableFields {
    title: string;
    maxLength: number;
    mandatory: boolean;
}
interface ChoiceNonNullableFields {
    value: string;
    description: string;
    media?: MediaNonNullableFields;
    inStock: boolean;
    visible: boolean;
}
interface ProductOptionNonNullableFields {
    optionType: OptionType;
    name: string;
    choices: ChoiceNonNullableFields[];
}
interface PageUrlNonNullableFields {
    base: string;
    path: string;
}
interface DiscountNonNullableFields {
    type: DiscountType;
    value: number;
}
interface VariantDataWithNoStockNonNullableFields {
    priceData?: PriceDataNonNullableFields;
    convertedPriceData?: PriceDataNonNullableFields;
    costAndProfitData?: CostAndProfitDataNonNullableFields;
    weight: number;
    sku: string;
    visible: boolean;
}
interface VariantStockNonNullableFields {
    trackQuantity: boolean;
    inStock: boolean;
}
interface VariantNonNullableFields {
    _id: string;
    variant?: VariantDataWithNoStockNonNullableFields;
    stock?: VariantStockNonNullableFields;
}
interface TagNonNullableFields {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields[];
}
interface SeoSchemaNonNullableFields {
    tags: TagNonNullableFields[];
    settings?: SettingsNonNullableFields;
}
interface SecuredMediaNonNullableFields {
    _id: string;
    fileName: string;
    fileType: FileType;
}
interface ProductNonNullableFields {
    _id: string;
    slug: string;
    productType: ProductType;
    weightRange?: NumericPropertyRangeNonNullableFields;
    stock?: StockNonNullableFields;
    price?: PriceDataNonNullableFields;
    priceData?: PriceDataNonNullableFields;
    convertedPriceData?: PriceDataNonNullableFields;
    priceRange?: NumericPropertyRangeNonNullableFields;
    costAndProfitData?: CostAndProfitDataNonNullableFields;
    costRange?: NumericPropertyRangeNonNullableFields;
    pricePerUnitData?: PricePerUnitDataNonNullableFields;
    additionalInfoSections: AdditionalInfoSectionNonNullableFields[];
    ribbons: RibbonNonNullableFields[];
    media?: MediaNonNullableFields;
    customTextFields: CustomTextFieldNonNullableFields[];
    productOptions: ProductOptionNonNullableFields[];
    productPageUrl?: PageUrlNonNullableFields;
    numericId: string;
    inventoryItemId: string;
    discount?: DiscountNonNullableFields;
    collectionIds: string[];
    variants: VariantNonNullableFields[];
    seoData?: SeoSchemaNonNullableFields;
    exportProductId: string;
    digitalFile?: SecuredMediaNonNullableFields;
}
interface CreateProductResponseNonNullableFields {
    product?: ProductNonNullableFields;
}
interface UpdateProductResponseNonNullableFields {
    product?: ProductNonNullableFields;
}
interface UpdateVariantsResponseNonNullableFields {
    variants: VariantNonNullableFields[];
}
interface CollectionNonNullableFields {
    media?: MediaNonNullableFields;
    numberOfProducts: number;
    seoSchema?: SeoSchemaNonNullableFields;
}
interface CreateCollectionResponseNonNullableFields {
    collection?: CollectionNonNullableFields;
}
interface UpdateCollectionResponseNonNullableFields {
    collection?: CollectionNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface BulkProductResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkUpdateProductsResponseNonNullableFields {
    results: BulkProductResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkAdjustProductPropertiesResponseNonNullableFields {
    results: BulkProductResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface QueryProductsPlatformizedResponseNonNullableFields {
    products: ProductNonNullableFields[];
}
interface GetProductResponseNonNullableFields {
    product?: ProductNonNullableFields;
}
interface GetCollectionBySlugResponseNonNullableFields {
    collection?: CollectionNonNullableFields;
}
interface VariantDataNonNullableFields {
    price?: PriceDataNonNullableFields;
    convertedPriceData?: PriceDataNonNullableFields;
    sku: string;
    inStock: boolean;
    visible: boolean;
    variantId: string;
}
interface ProductOptionsAvailabilityResponseNonNullableFields {
    selectedVariant?: VariantDataNonNullableFields;
    media?: MediaNonNullableFields;
    productOptions: ProductOptionNonNullableFields[];
    availableForPurchase: boolean;
    managedProduct: boolean;
}
interface PagingMetadataNonNullableFields {
    items: number;
    offset: number;
}
interface QueryProductVariantsResponseNonNullableFields {
    variants: VariantNonNullableFields[];
    metadata?: PagingMetadataNonNullableFields;
    totalResults: number;
}
interface PlatformMediaNonNullableFields {
    image: string;
    video: string;
}
interface PreorderInfoNonNullableFields {
    enabled: boolean;
}
interface StoreVariantNonNullableFields {
    _id: string;
    variantId: string;
    productId: string;
    variantName: string;
    productName: string;
    managedVariant: boolean;
    sku: string;
    stock?: VariantStockNonNullableFields;
    collectionIds: string[];
    media?: PlatformMediaNonNullableFields;
    preorderInfo?: PreorderInfoNonNullableFields;
}
interface QueryStoreVariantsResponseNonNullableFields {
    variants: StoreVariantNonNullableFields[];
}
interface GetStoreVariantResponseNonNullableFields {
    variant?: StoreVariantNonNullableFields;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface ProductCreatedEnvelope {
    data: ProductCreated;
    metadata: BaseEventMetadata;
}
interface ProductChangedEnvelope {
    data: ProductChanged;
    metadata: BaseEventMetadata;
}
interface ProductDeletedEnvelope {
    data: ProductDeleted;
    metadata: BaseEventMetadata;
}
interface ProductCollectionCreatedEnvelope {
    data: CollectionCreated;
    metadata: BaseEventMetadata;
}
interface ProductCollectionChangedEnvelope {
    data: CollectionChanged;
    metadata: BaseEventMetadata;
}
interface ProductCollectionDeletedEnvelope {
    data: CollectionDeleted;
    metadata: BaseEventMetadata;
}
interface ProductVariantsChangedEnvelope {
    data: VariantsChanged;
    metadata: BaseEventMetadata;
}
interface UpdateProduct {
    /**
     * Product ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string;
    /**
     * Product name.
     *
     * Min: 1 character
     * Max: 80 characters
     */
    name?: string | null;
    /** A friendly URL name (generated automatically by the catalog when a product is created), can be updated. */
    slug?: string;
    /** Whether the product is visible to site visitors. */
    visible?: boolean | null;
    /** Currently, only creating physical products ( `"productType": "physical"` ) is supported via the API. */
    productType?: ProductType;
    /** Product description. */
    description?: string | null;
    /** Stock keeping unit. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, SKUs will be set per variant, and this field will be empty. */
    sku?: string | null;
    /** Product weight. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, weight will be set per variant, and this field will be empty. */
    weight?: number | null;
    /**
     * Product weight range. The minimum and maximum weights of all the variants.
     * @readonly
     */
    weightRange?: NumericPropertyRange;
    /**
     * Product inventory status (in future this will be writable via Inventory API).
     * @readonly
     */
    stock?: Stock;
    /**
     * Deprecated (use `priceData` instead).
     * @readonly
     * @deprecated
     */
    price?: PriceData;
    /** Price data. */
    priceData?: PriceData;
    /**
     * Price data, converted to the currency specified in request header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /**
     * Product price range. The minimum and maximum prices of all the variants.
     * @readonly
     */
    priceRange?: NumericPropertyRange;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData;
    /**
     * Product cost range. The minimum and maximum costs of all the variants.
     * @readonly
     */
    costRange?: NumericPropertyRange;
    /** Price per unit data. */
    pricePerUnitData?: PricePerUnitData;
    /** Additional text that the store owner can assign to the product (e.g. shipping details, refund policy, etc.). */
    additionalInfoSections?: AdditionalInfoSection[];
    /**
     * Deprecated (use `ribbon` instead).
     * @readonly
     * @deprecated
     */
    ribbons?: Ribbon[];
    /**
     * Media items (images, videos etc) associated with this product (writable via [Add Product Media](https://dev.wix.com/api/rest/wix-stores/catalog/products/add-product-media) endpoint).
     * @readonly
     */
    media?: Media;
    /**
     * Text box for the customer to add a message to their order (e.g., customization request). Currently writable only from the UI.
     * @readonly
     */
    customTextFields?: CustomTextField[];
    /** Whether variants are being managed for this product - enables unique SKU, price and weight per variant. Also affects inventory data. Once set to `true`, can be reset to `false` only if no variants exist. You cannot set `manageVariants` to `true` if more than 300 variants are defined. */
    manageVariants?: boolean | null;
    /** Options for this product. */
    productOptions?: ProductOption[];
    /**
     * Product page URL for this product (generated automatically by the server).
     * @readonly
     */
    productPageUrl?: PageUrl;
    /**
     * Product’s unique numeric ID (assigned in ascending order).
     * Primarily used for sorting and filtering when crawling all products.
     * @readonly
     */
    numericId?: string;
    /**
     * Inventory item ID - ID referencing the inventory system.
     * @readonly
     */
    inventoryItemId?: string;
    /** Discount deducted from the product's original price. */
    discount?: Discount;
    /**
     * A list of all collection IDs that this product is included in (writable via the Catalog > Collection APIs).
     * @readonly
     */
    collectionIds?: string[];
    /**
     * Product variants, will be provided if the the request was sent with the `includeVariants: true`.
     *
     * Max: 1,000 variants
     * @readonly
     */
    variants?: Variant[];
    /**
     * Date and time the product was last updated.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Date and time the product was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /** Custom SEO data for the product. */
    seoData?: SeoSchema;
    /** Product ribbon. Used to highlight relevant information about a product. For example, "Sale", "New Arrival", "Sold Out". */
    ribbon?: string | null;
    /** Product brand. Including a brand name can help improve site and product [visibility on search engines](https://support.wix.com/en/article/adding-brand-names-to-boost-product-page-seo-in-wix-stores). */
    brand?: string | null;
}
interface UpdateCollection {
    /**
     * Collection ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string | null;
    /** Collection name. */
    name?: string | null;
    /**
     * Media items (images, videos etc) associated with this collection. Read only.
     * @readonly
     */
    media?: Media;
    /**
     * Number of products in the collection. Read only.
     * @readonly
     */
    numberOfProducts?: number;
    /** Collection description. */
    description?: string | null;
    /** Collection slug. */
    slug?: string | null;
    /** Collection visibility. Only impacts dynamic pages, no impact on static pages. Default: `true`. */
    visible?: boolean | null;
}
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface ProductsQueryResult extends QueryOffsetResult {
    items: Product[];
    query: ProductsQueryBuilder;
    next: () => Promise<ProductsQueryResult>;
    prev: () => Promise<ProductsQueryResult>;
}
interface ProductsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | 'name' | 'slug' | 'productType' | 'description' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'collectionIds' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | 'name' | 'slug' | 'productType' | 'description' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'collectionIds' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: 'priceData.price' | 'numericId' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: 'priceData.price' | 'numericId' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: 'priceData.price' | 'numericId' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: 'priceData.price' | 'numericId' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'name' | 'slug' | 'description' | 'sku', value: string) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: '_id' | 'name' | 'slug' | 'productType' | 'description' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'collectionIds' | 'lastUpdated' | '_createdDate', value: any[]) => ProductsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasAll: (propertyName: 'collectionIds', value: any[]) => ProductsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | 'name' | 'slug' | 'productType' | 'description' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'collectionIds' | 'lastUpdated' | '_createdDate', value: any) => ProductsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | 'name' | 'slug' | 'productType' | 'description' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'collectionIds' | 'lastUpdated' | '_createdDate', value: boolean) => ProductsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_id' | 'name' | 'slug' | 'productType' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'lastUpdated'>) => ProductsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_id' | 'name' | 'slug' | 'productType' | 'sku' | 'price' | 'priceData.price' | 'numericId' | 'lastUpdated'>) => ProductsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => ProductsQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results.
     * @documentationMaturity preview
     */
    skip: (skip: number) => ProductsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<ProductsQueryResult>;
}
interface GetProductOptions {
    /** Whether merchant specific data, such as cost and profit data, should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface QueryProductVariantsOptions {
    /**
     * The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice).
     * You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (not relevant when passing variant IDs).
     */
    choices?: Record<string, string>;
    /** List of variant IDs (not relevant when passing choices). */
    variantIds?: string[];
    paging?: Paging;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}

declare function createProduct$1(httpClient: HttpClient): CreateProductSignature;
interface CreateProductSignature {
    /**
     * Creates a new product.
     * @param - Product information.
     */
    (product: Product): Promise<CreateProductResponse & CreateProductResponseNonNullableFields>;
}
declare function updateProduct$1(httpClient: HttpClient): UpdateProductSignature;
interface UpdateProductSignature {
    /**
     * Updates specified fields in a product.
     * @param - Product ID (generated automatically by the catalog).
     * @param - Product info to update.
     */
    (_id: string, product: UpdateProduct): Promise<UpdateProductResponse & UpdateProductResponseNonNullableFields>;
}
declare function deleteProduct$1(httpClient: HttpClient): DeleteProductSignature;
interface DeleteProductSignature {
    /**
     * Deletes a product.
     * @param - ID of the product to delete.
     */
    (_id: string): Promise<void>;
}
declare function updateProductVariants$1(httpClient: HttpClient): UpdateProductVariantsSignature;
interface UpdateProductVariantsSignature {
    /**
     * Updates variants of a specified product.
     * @param - ID of the product with managed variants.
     * @param - Variant info to update.
     */
    (_id: string, variants: VariantOverride[]): Promise<UpdateVariantsResponse & UpdateVariantsResponseNonNullableFields>;
}
declare function resetAllProductVariantData$1(httpClient: HttpClient): ResetAllProductVariantDataSignature;
interface ResetAllProductVariantDataSignature {
    /**
     * Resets the data (such as the price and the weight) of all variants for a given product to their default values.
     * @param - Product ID.
     */
    (_id: string): Promise<void>;
}
declare function addProductsToCollection$1(httpClient: HttpClient): AddProductsToCollectionSignature;
interface AddProductsToCollectionSignature {
    /**
     * Adds products to a specified collection.
     * @param - Collection ID.
     * @param - IDs of the products to add to the collection, separated by commas.
     */
    (_id: string, productIds: string[]): Promise<void>;
}
declare function removeProductsFromCollection$1(httpClient: HttpClient): RemoveProductsFromCollectionSignature;
interface RemoveProductsFromCollectionSignature {
    /**
     * Deletes products from a specified collection.
     * @param - ID of the collection from which to remove products.
     * @param - IDs of the products to remove from the collection.
     */
    (_id: string, productIds: string[]): Promise<void>;
}
declare function addProductMedia$1(httpClient: HttpClient): AddProductMediaSignature;
interface AddProductMediaSignature {
    /**
     * Adds media items to a specified product, either via URL or existing media ID.
     *
     * > **NOTE:** The URL is not validated and no event is triggered to indicate if the media was added successfully.
     * @param - Product ID.
     * @param - Sources of media items already uploaded to the Wix site.
     */
    (_id: string, media: MediaDataForWrite[]): Promise<void>;
}
declare function removeProductMedia$1(httpClient: HttpClient): RemoveProductMediaSignature;
interface RemoveProductMediaSignature {
    /**
     * Removes specified media items from a product.
     * Pass an empty array to remove all media items.
     * @param - Product ID.
     * @param - List of media IDs to remove. Pass an empty array to delete all media items for the product.
     */
    (_id: string, mediaIds: string[]): Promise<void>;
}
declare function addProductMediaToChoices$1(httpClient: HttpClient): AddProductMediaToChoicesSignature;
interface AddProductMediaToChoicesSignature {
    /**
     * Links media items that are already associated with a specific product to a choice within the same product.
     *
     * Media items can only be set for choices within one option at a time - e.g., if you set media items for some or all of the choices within the Colors option (blue, green, and red), you won't be able to also assign media items to choices within the Size option (S, M, and L).
     *
     * To remove all existing media items, call the [Remove Product Media From Choices](https://dev.wix.com/api/rest/wix-stores/catalog/products/remove-product-media-from-choices) endpoint.
     * @param - Product ID.
     * @param - Product media items and the choices to add the media to.
     */
    (_id: string, media: MediaAssignmentToChoice[]): Promise<void>;
}
declare function removeProductMediaFromChoices$1(httpClient: HttpClient): RemoveProductMediaFromChoicesSignature;
interface RemoveProductMediaFromChoicesSignature {
    /**
     * Removes media items from all or some of a product's choices.
     * (Media items can only be set for choices within one option at a time - e.g., if you set media items for some or all of the choices within the Colors option (blue, green, and red), you won't be able to also assign media items to choices within the Size option (S, M, and L).)
     * @param - Product ID from whose choices to remove media items.
     * @param - Media to remove from choices. If an empty array is passed, all media will be removed from all choices for the given product.
     */
    (_id: string, media: MediaAssignmentToChoice[]): Promise<void>;
}
declare function deleteProductOptions$1(httpClient: HttpClient): DeleteProductOptionsSignature;
interface DeleteProductOptionsSignature {
    /**
     * Delete all options from a specific product. Only available when [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is disabled.
     * @param - ID of the product with options to delete.
     */
    (_id: string): Promise<void>;
}
declare function removeBrand$1(httpClient: HttpClient): RemoveBrandSignature;
interface RemoveBrandSignature {
    /**
     * Deletes a product's brand.
     * @param - Product ID.
     */
    (_id: string): Promise<void>;
}
declare function createCollection$1(httpClient: HttpClient): CreateCollectionSignature;
interface CreateCollectionSignature {
    /**
     * Creates a new collection.
     * @param - Collection info.
     */
    (collection: Collection): Promise<CreateCollectionResponse & CreateCollectionResponseNonNullableFields>;
}
declare function updateCollection$1(httpClient: HttpClient): UpdateCollectionSignature;
interface UpdateCollectionSignature {
    /**
     * Updates specified properties of a collection. To add products to a collection, call the [addProductsToCollection](#addproductstocollection) function.
     * @param - Collection ID (generated automatically by the catalog).
     * @param - Collection info to update.
     */
    (_id: string | null, collection: UpdateCollection): Promise<UpdateCollectionResponse & UpdateCollectionResponseNonNullableFields>;
}
declare function deleteCollection$1(httpClient: HttpClient): DeleteCollectionSignature;
interface DeleteCollectionSignature {
    /**
     * Deletes a collection.
     * @param - ID of the collection to delete.
     */
    (_id: string): Promise<void>;
}
declare function removeRibbon$1(httpClient: HttpClient): RemoveRibbonSignature;
interface RemoveRibbonSignature {
    /**
     * Deletes a product's ribbon.
     * @param - Product ID.
     */
    (_id: string): Promise<void>;
}
declare function bulkUpdateProductsProperty$1(httpClient: HttpClient): BulkUpdateProductsPropertySignature;
interface BulkUpdateProductsPropertySignature {
    /**
     * Updates a specified property for up to 100 products at a time.
     * @param - Product IDs.
     * @param - Field to update.
     */
    (ids: string[], set: SetValue): Promise<BulkUpdateProductsResponse & BulkUpdateProductsResponseNonNullableFields>;
}
declare function bulkAdjustProductProperty$1(httpClient: HttpClient): BulkAdjustProductPropertySignature;
interface BulkAdjustProductPropertySignature {
    /**
     * Adjusts a specified numerical property for up to 100 products at a time.
     * The property can be increased or decreased either by percentage or amount.
     * @param - Numerical property to adjust.
     * @param - Product IDs.
     */
    (adjust: AdjustValue, ids: string[]): Promise<BulkAdjustProductPropertiesResponse & BulkAdjustProductPropertiesResponseNonNullableFields>;
}
declare function queryProducts$1(httpClient: HttpClient): QueryProductsSignature;
interface QueryProductsSignature {
    /**
     * Returns a list of up to 100 products, given the provided paging, sorting and filtering.
     */
    (): ProductsQueryBuilder;
}
declare function getProduct$1(httpClient: HttpClient): GetProductSignature;
interface GetProductSignature {
    /**
     * Retrieves a product with the provided ID.
     * @param - Requested product ID.
     */
    (_id: string, options?: GetProductOptions | undefined): Promise<GetProductResponse & GetProductResponseNonNullableFields>;
}
declare function getCollectionBySlug$1(httpClient: HttpClient): GetCollectionBySlugSignature;
interface GetCollectionBySlugSignature {
    /**
     * Retrieves a collection with the provided slug.
     * @param - Slug of the collection to retrieve.
     */
    (slug: string): Promise<GetCollectionBySlugResponse & GetCollectionBySlugResponseNonNullableFields>;
}
declare function getProductOptionsAvailability$1(httpClient: HttpClient): GetProductOptionsAvailabilitySignature;
interface GetProductOptionsAvailabilitySignature {
    /**
     * Gets the availability of relevant product variants based on the product ID and selections provided. See [Use Cases](https://dev.wix.com/api/rest/wix-stores/catalog/use-cases) for an example.
     * @param - Requested product ID.
     * @param - Array containing the selected options. For example, `["color": "Blue", "size": "Large"]`.
     */
    (_id: string, options: Record<string, string>): Promise<ProductOptionsAvailabilityResponse & ProductOptionsAvailabilityResponseNonNullableFields>;
}
declare function queryProductVariants$1(httpClient: HttpClient): QueryProductVariantsSignature;
interface QueryProductVariantsSignature {
    /**
     * Retrieves product variants, based on either choices (option-choice key-value pairs) or variant IDs.
     * See [Stores Pagination](https://dev.wix.com/api/rest/wix-stores/pagination) for more information.
     * @param - Requested product ID.
     */
    (_id: string, options?: QueryProductVariantsOptions | undefined): Promise<QueryProductVariantsResponse & QueryProductVariantsResponseNonNullableFields>;
}
declare function queryStoreVariants$1(httpClient: HttpClient): QueryStoreVariantsSignature;
interface QueryStoreVariantsSignature {
    /**
     * Retrieves up to 100 store variants, given the provided paging, filtering, and sorting.
     * @param - Query options.
     */
    (query: PlatformQuery): Promise<QueryStoreVariantsResponse & QueryStoreVariantsResponseNonNullableFields>;
}
declare function getStoreVariant$1(httpClient: HttpClient): GetStoreVariantSignature;
interface GetStoreVariantSignature {
    /**
     * Retrieves a store variant with the provided ID.
     * @param - Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen. For example, `{productId}-{variantId}`.
     */
    (_id: string): Promise<GetStoreVariantResponse & GetStoreVariantResponseNonNullableFields>;
}
declare const onProductCreated$1: EventDefinition<ProductCreatedEnvelope, "com.wix.ecommerce.catalog.api.v1.ProductCreated">;
declare const onProductChanged$1: EventDefinition<ProductChangedEnvelope, "com.wix.ecommerce.catalog.api.v1.ProductChanged">;
declare const onProductDeleted$1: EventDefinition<ProductDeletedEnvelope, "com.wix.ecommerce.catalog.api.v1.ProductDeleted">;
declare const onProductCollectionCreated$1: EventDefinition<ProductCollectionCreatedEnvelope, "com.wix.ecommerce.catalog.api.v1.CollectionCreated">;
declare const onProductCollectionChanged$1: EventDefinition<ProductCollectionChangedEnvelope, "com.wix.ecommerce.catalog.api.v1.CollectionChanged">;
declare const onProductCollectionDeleted$1: EventDefinition<ProductCollectionDeletedEnvelope, "com.wix.ecommerce.catalog.api.v1.CollectionDeleted">;
declare const onProductVariantsChanged$1: EventDefinition<ProductVariantsChangedEnvelope, "com.wix.ecommerce.catalog.api.v1.VariantsChanged">;

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const createProduct: MaybeContext<BuildRESTFunction<typeof createProduct$1> & typeof createProduct$1>;
declare const updateProduct: MaybeContext<BuildRESTFunction<typeof updateProduct$1> & typeof updateProduct$1>;
declare const deleteProduct: MaybeContext<BuildRESTFunction<typeof deleteProduct$1> & typeof deleteProduct$1>;
declare const updateProductVariants: MaybeContext<BuildRESTFunction<typeof updateProductVariants$1> & typeof updateProductVariants$1>;
declare const resetAllProductVariantData: MaybeContext<BuildRESTFunction<typeof resetAllProductVariantData$1> & typeof resetAllProductVariantData$1>;
declare const addProductsToCollection: MaybeContext<BuildRESTFunction<typeof addProductsToCollection$1> & typeof addProductsToCollection$1>;
declare const removeProductsFromCollection: MaybeContext<BuildRESTFunction<typeof removeProductsFromCollection$1> & typeof removeProductsFromCollection$1>;
declare const addProductMedia: MaybeContext<BuildRESTFunction<typeof addProductMedia$1> & typeof addProductMedia$1>;
declare const removeProductMedia: MaybeContext<BuildRESTFunction<typeof removeProductMedia$1> & typeof removeProductMedia$1>;
declare const addProductMediaToChoices: MaybeContext<BuildRESTFunction<typeof addProductMediaToChoices$1> & typeof addProductMediaToChoices$1>;
declare const removeProductMediaFromChoices: MaybeContext<BuildRESTFunction<typeof removeProductMediaFromChoices$1> & typeof removeProductMediaFromChoices$1>;
declare const deleteProductOptions: MaybeContext<BuildRESTFunction<typeof deleteProductOptions$1> & typeof deleteProductOptions$1>;
declare const removeBrand: MaybeContext<BuildRESTFunction<typeof removeBrand$1> & typeof removeBrand$1>;
declare const createCollection: MaybeContext<BuildRESTFunction<typeof createCollection$1> & typeof createCollection$1>;
declare const updateCollection: MaybeContext<BuildRESTFunction<typeof updateCollection$1> & typeof updateCollection$1>;
declare const deleteCollection: MaybeContext<BuildRESTFunction<typeof deleteCollection$1> & typeof deleteCollection$1>;
declare const removeRibbon: MaybeContext<BuildRESTFunction<typeof removeRibbon$1> & typeof removeRibbon$1>;
declare const bulkUpdateProductsProperty: MaybeContext<BuildRESTFunction<typeof bulkUpdateProductsProperty$1> & typeof bulkUpdateProductsProperty$1>;
declare const bulkAdjustProductProperty: MaybeContext<BuildRESTFunction<typeof bulkAdjustProductProperty$1> & typeof bulkAdjustProductProperty$1>;
declare const queryProducts: MaybeContext<BuildRESTFunction<typeof queryProducts$1> & typeof queryProducts$1>;
declare const getProduct: MaybeContext<BuildRESTFunction<typeof getProduct$1> & typeof getProduct$1>;
declare const getCollectionBySlug: MaybeContext<BuildRESTFunction<typeof getCollectionBySlug$1> & typeof getCollectionBySlug$1>;
declare const getProductOptionsAvailability: MaybeContext<BuildRESTFunction<typeof getProductOptionsAvailability$1> & typeof getProductOptionsAvailability$1>;
declare const queryProductVariants: MaybeContext<BuildRESTFunction<typeof queryProductVariants$1> & typeof queryProductVariants$1>;
declare const queryStoreVariants: MaybeContext<BuildRESTFunction<typeof queryStoreVariants$1> & typeof queryStoreVariants$1>;
declare const getStoreVariant: MaybeContext<BuildRESTFunction<typeof getStoreVariant$1> & typeof getStoreVariant$1>;

type _publicOnProductCreatedType = typeof onProductCreated$1;
/**
 * Triggered when a product is created.
 */
declare const onProductCreated: ReturnType<typeof createEventModule<_publicOnProductCreatedType>>;

type _publicOnProductChangedType = typeof onProductChanged$1;
/**
 * Triggered when a product is changed.
 */
declare const onProductChanged: ReturnType<typeof createEventModule<_publicOnProductChangedType>>;

type _publicOnProductDeletedType = typeof onProductDeleted$1;
/**
 * Triggered when a product is deleted.
 */
declare const onProductDeleted: ReturnType<typeof createEventModule<_publicOnProductDeletedType>>;

type _publicOnProductCollectionCreatedType = typeof onProductCollectionCreated$1;
/**
 * Triggered when a collection is created.
 */
declare const onProductCollectionCreated: ReturnType<typeof createEventModule<_publicOnProductCollectionCreatedType>>;

type _publicOnProductCollectionChangedType = typeof onProductCollectionChanged$1;
/**
 * Triggered when a collection is changed.
 */
declare const onProductCollectionChanged: ReturnType<typeof createEventModule<_publicOnProductCollectionChangedType>>;

type _publicOnProductCollectionDeletedType = typeof onProductCollectionDeleted$1;
/**
 * Triggered when a collection is deleted.
 */
declare const onProductCollectionDeleted: ReturnType<typeof createEventModule<_publicOnProductCollectionDeletedType>>;

type _publicOnProductVariantsChangedType = typeof onProductVariantsChanged$1;
/**
 * Triggered when a product variant is changed.
 */
declare const onProductVariantsChanged: ReturnType<typeof createEventModule<_publicOnProductVariantsChangedType>>;

export { type AddProductMediaRequest, type AddProductMediaResponse, type AddProductMediaToChoicesRequest, type AddProductMediaToChoicesResponse, type AddProductsToCollectionRequest, type AddProductsToCollectionResponse, type AdditionalInfoSection, type AdjustValue, type AdjustValueValueOneOf, type AggregateProductsRequest, type AggregateProductsResponse, type AllowedProductsCountLimitExceededErrorData, type ApplicationError, type BaseEventMetadata, type BulkActionMetadata, type BulkAdjustProductPropertiesByFilterSyncRequest, type BulkAdjustProductPropertiesByFilterSyncResponse, type BulkAdjustProductPropertiesRequest, type BulkAdjustProductPropertiesResponse, type BulkAdjustProductPropertiesResponseNonNullableFields, type BulkDeleteProductsRequest, type BulkDeleteProductsResponse, type BulkProductResult, type BulkQueryCustomFieldsRequest, type BulkQueryCustomFieldsResponse, type BulkRemoveCustomFieldsRequest, type BulkRemoveCustomFieldsResponse, type BulkSetCustomFieldsRequest, type BulkSetCustomFieldsResponse, type BulkUpdateProductsByFilterSyncRequest, type BulkUpdateProductsByFilterSyncResponse, type BulkUpdateProductsRequest, type BulkUpdateProductsResponse, type BulkUpdateProductsResponseNonNullableFields, type Choice, type Collection, type CollectionChanged, type CollectionCreated, type CollectionDeleted, type CostAndProfitData, type CreateCollectionRequest, type CreateCollectionResponse, type CreateCollectionResponseNonNullableFields, type CreateDigitalProductRequest, type CreateDigitalProductResponse, type CreateProductPlatformizedRequest, type CreateProductPlatformizedResponse, type CreateProductRequest, type CreateProductResponse, type CreateProductResponseNonNullableFields, type CursorPaging, type Cursors, type CustomFieldsContainer, type CustomTextField, type DeleteCollectionRequest, type DeleteCollectionResponse, type DeleteProductOptionsRequest, type DeleteProductOptionsResponse, type DeleteProductPlatformizedRequest, type DeleteProductPlatformizedResponse, type DeleteProductRequest, type DeleteProductResponse, type Discount, DiscountType, FileType, type FormattedPrice, type GetCollectionBySlugRequest, type GetCollectionBySlugResponse, type GetCollectionBySlugResponseNonNullableFields, type GetCollectionRequest, type GetCollectionResponse, type GetProductOptions, type GetProductPlatformizedRequest, type GetProductPlatformizedResponse, type GetProductRequest, type GetProductResponse, type GetProductResponseNonNullableFields, type GetProductsRequest, type GetProductsResponse, type GetStoreVariantRequest, type GetStoreVariantResponse, type GetStoreVariantResponseNonNullableFields, type IdentificationData, type IdentificationDataIdOneOf, InventoryStatus, type ItemMetadata, type Keyword, MeasurementUnit, type Media, type MediaAssignmentToChoice, type MediaDataForWrite, type MediaDataForWriteMediaSourceOneOf, type MediaItem, type MediaItemItemOneOf, MediaItemType, type MediaItemUrlAndSize, type MediaItemVideo, type MessageEnvelope, type NumericPropertyRange, type OptionAndChoice, OptionType, type PageUrl, type Paging, type PagingMetadata, type PagingWithBigLimit, type PercentageData, type PlatformMedia, type PlatformMediaMediaOneOf, type PlatformPaging, type PlatformPagingMetadata, type PlatformQuery, type PlatformQueryPagingMethodOneOf, type PreorderInfo, type PriceData, type PricePerUnitData, type Product, type ProductChanged, type ProductChangedEnvelope, type ProductCollectionChangedEnvelope, type ProductCollectionCreatedEnvelope, type ProductCollectionDeletedEnvelope, type ProductCreated, type ProductCreatedEnvelope, type ProductDeleted, type ProductDeletedEnvelope, type ProductOption, type ProductOptionsAvailabilityRequest, type ProductOptionsAvailabilityResponse, type ProductOptionsAvailabilityResponseNonNullableFields, ProductType, type ProductVariantsChangedEnvelope, type ProductsQueryBuilder, type ProductsQueryResult, type PropertyAdjustmentData, type PropertyAdjustmentDataByOneOf, type Query, type QueryCollectionsPlatformizedRequest, type QueryCollectionsPlatformizedResponse, type QueryCollectionsRequest, type QueryCollectionsResponse, type QueryCustomFieldsRequest, type QueryCustomFieldsResponse, type QueryProductVariantsOptions, type QueryProductVariantsRequest, type QueryProductVariantsResponse, type QueryProductVariantsResponseNonNullableFields, type QueryProductsPlatformizedRequest, type QueryProductsPlatformizedResponse, type QueryProductsPlatformizedResponseNonNullableFields, type QueryProductsRequest, type QueryProductsResponse, type QueryProductsWithBigPageLimitRequest, type QueryStoreVariantsRequest, type QueryStoreVariantsResponse, type QueryStoreVariantsResponseNonNullableFields, type QueryStoreVariantsWithBigLimitRequest, type QueryWithBigPageLimit, type ReCloneStoreRequest, type ReCloneStoreResponse, type RemoveCustomFieldsRequest, type RemoveCustomFieldsResponse, type RemoveProductBrandRequest, type RemoveProductBrandResponse, type RemoveProductMediaFromChoicesRequest, type RemoveProductMediaFromChoicesResponse, type RemoveProductMediaRequest, type RemoveProductMediaResponse, type RemoveProductRibbonRequest, type RemoveProductRibbonResponse, type RemoveProductsFromCollectionRequest, type RemoveProductsFromCollectionResponse, type ResetAllVariantDataRequest, type ResetAllVariantDataResponse, type Ribbon, type SecuredMedia, type SeoSchema, type SetCustomFieldsRequest, type SetCustomFieldsResponse, type SetValue, type SetValueValueOneOf, type Settings, SortOrder, type Sorting, type Stock, type StoreVariant, type Tag, type UnlimitedPlatformCursorPaging, type UnlimitedPlatformPaging, type UnlimitedPlatformQuery, type UnlimitedPlatformQueryPagingMethodOneOf, type UpdateCollection, type UpdateCollectionRequest, type UpdateCollectionResponse, type UpdateCollectionResponseNonNullableFields, type UpdateProduct, type UpdateProductPlatformizedRequest, type UpdateProductPlatformizedResponse, type UpdateProductRequest, type UpdateProductResponse, type UpdateProductResponseNonNullableFields, type UpdateVariantsRequest, type UpdateVariantsResponse, type UpdateVariantsResponseNonNullableFields, type V1CreateProductPlatformizedRequest, type V1CreateProductPlatformizedResponse, type V1DeleteProductPlatformizedRequest, type V1DeleteProductPlatformizedResponse, type V1UpdateProductPlatformizedRequest, type V1UpdateProductPlatformizedResponse, type Variant, type VariantChanged, type VariantData, type VariantDataWithNoStock, type VariantOverride, type VariantStock, type VariantsChanged, Version, type VideoResolution, WebhookIdentityType, type _publicOnProductChangedType, type _publicOnProductCollectionChangedType, type _publicOnProductCollectionCreatedType, type _publicOnProductCollectionDeletedType, type _publicOnProductCreatedType, type _publicOnProductDeletedType, type _publicOnProductVariantsChangedType, addProductMedia, addProductMediaToChoices, addProductsToCollection, bulkAdjustProductProperty, bulkUpdateProductsProperty, createCollection, createProduct, deleteCollection, deleteProduct, deleteProductOptions, getCollectionBySlug, getProduct, getProductOptionsAvailability, getStoreVariant, onProductChanged, onProductCollectionChanged, onProductCollectionCreated, onProductCollectionDeleted, onProductCreated, onProductDeleted, onProductVariantsChanged, onProductChanged$1 as publicOnProductChanged, onProductCollectionChanged$1 as publicOnProductCollectionChanged, onProductCollectionCreated$1 as publicOnProductCollectionCreated, onProductCollectionDeleted$1 as publicOnProductCollectionDeleted, onProductCreated$1 as publicOnProductCreated, onProductDeleted$1 as publicOnProductDeleted, onProductVariantsChanged$1 as publicOnProductVariantsChanged, queryProductVariants, queryProducts, queryStoreVariants, removeBrand, removeProductMedia, removeProductMediaFromChoices, removeProductsFromCollection, removeRibbon, resetAllProductVariantData, updateCollection, updateProduct, updateProductVariants };
