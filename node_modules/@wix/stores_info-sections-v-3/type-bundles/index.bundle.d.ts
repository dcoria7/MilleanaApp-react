type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/**
 * An info section is a visible property of a product
 * Add info sections to a product to provide all the explanations your customers need.
 */
interface InfoSection {
    /**
     * Info section ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the info section is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the info section.
     *
     * Ignored when creating an info section.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the info section was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the info section was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Unique name. Used as an identifier. */
    uniqueName?: string;
    /** Info section title. */
    title?: string;
    /**
     * Info section description using rich content.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    description?: RichContent;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
    /**
     * Number of products this info section is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Info Sections API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
interface RichContent {
    /** Node objects representing a rich content document. */
    nodes?: Node[];
    /** Object metadata. */
    metadata?: Metadata;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle;
}
interface Node extends NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** Data for a map node. */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeType;
    /** Node ID. */
    _id?: string;
    /** A list of child nodes. */
    nodes?: Node[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle;
}
/** @oneof */
interface NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** Data for a map node. */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
}
declare enum NodeType {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION"
}
interface NodeStyle {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData {
    /** Styling for the button's container. */
    containerData?: PluginContainerData;
    /** The button type. */
    type?: Type;
    /** Styling for the button. */
    styles?: Styles;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link;
}
interface Border {
    /** Border width in pixels. */
    width?: number | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface Colors {
    /** The text color as a hexadecimal value. */
    text?: string | null;
    /** The border color as a hexadecimal value. */
    border?: string | null;
    /** The background color as a hexadecimal value. */
    background?: string | null;
}
interface PluginContainerData {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignment;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler;
    /** The height of the node when it's displayed. */
    height?: Height;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
interface PluginContainerDataWidth extends PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
interface Spoiler {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum Type {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
interface Styles {
    /** Border attributes. */
    border?: Border;
    /** Color attributes. */
    colors?: Colors;
}
interface Link extends LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: Target;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
interface Rel {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData {
    /** Styling for the code block's text. */
    textStyle?: TextStyle;
}
interface TextStyle {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignment;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
interface DividerData {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData;
    /** Divider line style. */
    lineStyle?: LineStyle;
    /** Divider width. */
    width?: Width;
    /** Divider alignment. */
    alignment?: Alignment;
}
declare enum LineStyle {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
declare enum Width {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
declare enum Alignment {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
interface FileData {
    /** Styling for the file's container. */
    containerData?: PluginContainerData;
    /** The source for the file's data. */
    src?: FileSource;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
interface FileSource extends FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    _id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    _id?: string | null;
}
interface PDFSettings {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewMode;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData;
    /** The items in the gallery. */
    items?: Item[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface Media {
    /** The source for the media's data. */
    src?: FileSource;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface Image {
    /** Image file details. */
    media?: Media;
    /** Link details for images that are links. */
    link?: Link;
}
interface Video {
    /** Video file details. */
    media?: Media;
    /** Video thumbnail file details. */
    thumbnail?: Media;
}
interface Item extends ItemDataOneOf {
    /** An image item. */
    image?: Image;
    /** A video item. */
    video?: Video;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf {
    /** An image item. */
    image?: Image;
    /** A video item. */
    video?: Video;
}
interface GalleryOptions {
    /** Gallery layout. */
    layout?: Layout;
    /** Styling for gallery items. */
    item?: ItemStyle;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails;
}
declare enum LayoutType {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
declare enum Orientation {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
declare enum Crop {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
declare enum ThumbnailsAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
interface Layout {
    /** Gallery layout type. */
    type?: LayoutType;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: Orientation;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: Crop;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignment;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData;
    /** The source of the full size GIF. */
    original?: GIF;
    /** The source of the downsized GIF. */
    downsized?: GIF;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
}
interface GIF {
    /** GIF format URL. */
    gif?: string | null;
    /** MP4 format URL. */
    mp4?: string | null;
    /** Thumbnail URL. */
    still?: string | null;
}
interface HeadingData {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData extends HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. */
    containerData?: PluginContainerData;
    /** The type of HTML code. */
    source?: Source;
}
/** @oneof */
interface HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
interface ImageData {
    /** Styling for the image's container. */
    containerData?: PluginContainerData;
    /** Image file details. */
    image?: Media;
    /** Link details for images that are links. */
    link?: Link;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface LinkPreviewData {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData;
    /** Link details. */
    link?: Link;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
}
interface MapData {
    /** Styling for the map's container. */
    containerData?: PluginContainerData;
    /** Map settings. */
    mapSettings?: MapSettings;
}
interface MapSettings {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapType;
}
declare enum MapType {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
interface ParagraphData {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData;
    /** Poll data. */
    poll?: Poll;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout;
    /** Styling for the poll and voting options. */
    design?: Design;
}
declare enum ViewRole {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
declare enum VoteRole {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
interface Permissions {
    /** Sets who can view the poll results. */
    view?: ViewRole;
    /** Sets who can vote. */
    vote?: VoteRole;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option {
    /** Option ID. */
    _id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: Media;
}
interface Settings {
    /** Permissions settings for voting. */
    permissions?: Permissions;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
declare enum PollLayoutDirection {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface PollLayout {
    /** The layout for displaying the voting options. */
    type?: PollLayoutType;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirection;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
interface Gradient {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /** The start color as a hexademical value. */
    startColor?: string | null;
    /** The end color as a hexademical value. */
    lastColor?: string | null;
}
interface Background extends BackgroundBackgroundOneOf {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundType;
}
/** @oneof */
interface BackgroundBackgroundOneOf {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
}
interface PollDesign {
    /** Background styling. */
    background?: Background;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll {
    /** Poll ID. */
    _id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: Media;
    /** Voting options. */
    options?: Option[];
    /** The poll's permissions and display settings. */
    settings?: Settings;
}
interface PollDataLayout {
    /** Poll layout settings. */
    poll?: PollLayout;
    /** Voting otpions layout settings. */
    options?: OptionLayout;
}
interface Design {
    /** Styling for the poll. */
    poll?: PollDesign;
    /** Styling for voting options. */
    options?: OptionDesign;
}
interface TextData {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration[];
}
/** Adds appearence changes to text */
interface Decoration extends DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
    /** The type of decoration to apply. */
    type?: DecorationType;
}
/** @oneof */
interface DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
}
declare enum DecorationType {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL"
}
interface AnchorData {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData {
    /** Link details. */
    link?: Link;
}
interface MentionData {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    _id?: string | null;
}
interface FontSizeData {
    /** The units used for the font size. */
    unit?: FontType;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType {
    PX = "PX",
    EM = "EM"
}
interface SpoilerData {
    /** Spoiler ID. */
    _id?: string | null;
}
interface AppEmbedData extends AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
    /** The type of Wix App content being embedded. */
    type?: AppType;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: Media;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
}
declare enum AppType {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
interface BookingData {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface VideoData {
    /** Styling for the video's container. */
    containerData?: PluginContainerData;
    /** Video details. */
    video?: Media;
    /** Video thumbnail details. */
    thumbnail?: Media;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions;
}
interface PlaybackOptions {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItems;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: Direction;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
declare enum Direction {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface TableData {
    /** Styling for the table's container. */
    containerData?: PluginContainerData;
    /** The table's dimensions. */
    dimensions?: Dimensions;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle;
    /** The cell's border colors. */
    borderColors?: BorderColors;
}
declare enum VerticalAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
interface CellStyle {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignment;
    /** Cell background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface BorderColors {
    /** Left border color as a hexadecimal value. */
    left?: string | null;
    /** Right border color as a hexadecimal value. */
    right?: string | null;
    /** Top border color as a hexadecimal value. */
    top?: string | null;
    /** Bottom border color as a hexadecimal value. */
    bottom?: string | null;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 * The JSON representation for `NullValue` is JSON `null`.
 */
declare enum NullValue {
    /** Null value. */
    NULL_VALUE = "NULL_VALUE"
}
/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
 */
interface ListValue {
    /** Repeated field of dynamically typed values. */
    values?: any[];
}
interface AudioData {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData;
    /** Audio file details. */
    audio?: Media;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: Media;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData {
    textStyle?: TextStyle;
}
interface Metadata {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    _id?: string | null;
}
interface DocumentStyle {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle;
}
interface TextNodeStyle {
    /** The decorations to apply to the node. */
    decorations?: Decoration[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** tell us why you're invalidating the cache. You don't need to add your app name */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
interface App {
    /** The AppDefId */
    appDefId?: string;
    /** The instance Id */
    instanceId?: string;
}
interface Page {
    /** the msid the page is on */
    metaSiteId?: string;
    /** Invalidate by Page ID */
    pageId?: string;
}
interface URI {
    /** the msid the URI is on */
    metaSiteId?: string;
    /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
    uriPath?: string;
}
interface File {
    /** the msid the file is related to */
    metaSiteId?: string;
    /** Invalidate by filename (for media files such as PDFs) */
    fileName?: string;
}
interface CreateInfoSectionRequest {
    /** Info section to create. */
    infoSection: InfoSection;
}
interface CreateInfoSectionResponse {
    /** Created info section. */
    infoSection?: InfoSection;
}
interface GetInfoSectionRequest {
    /** Info section ID. */
    infoSectionId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
declare enum RequestedFields {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetInfoSectionResponse {
    /** Info section. */
    infoSection?: InfoSection;
}
interface GetOrCreateInfoSectionRequest {
    /** Info section to retrieve or create. */
    infoSection?: InfoSectionForGetOrCreate;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface InfoSectionForGetOrCreate {
    /**
     * Info section ID.
     * Pass an ID to retrieve an existing info section.
     */
    _id?: string | null;
    /**
     * Info section unique name.
     *
     * > **Note:**
     * > + Pass the `uniqueName` of an existing info section to return it.
     * > + If no such info section exists - pass `uniqueName` and `title` to create an info section.
     */
    uniqueName?: string | null;
    /**
     * Info section title.
     *
     * Required when passing `uniqueName` to create a new info section.
     */
    title?: string | null;
    /**
     * Info section description using rich content.
     *
     * Learn more about [Working with Rich Content](https://dev.wix.com/docs/go-headless/tutorials-templates/other-tutorials/working-with-rich-content).
     */
    description?: RichContent;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
}
interface GetOrCreateInfoSectionResponse {
    /** Info section. */
    infoSection?: InfoSection;
}
interface BulkGetOrCreateInfoSectionsRequest {
    /** Info sections to retrieve or create. */
    infoSections?: InfoSectionForGetOrCreate[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface BulkGetOrCreateInfoSectionsResponse {
    /** Info sections retrieved or created by bulk action. */
    results?: BulkInfoSectionItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInfoSectionItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InfoSection;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateInfoSectionRequest {
    /** Info section to update. */
    infoSection: InfoSection;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface UpdateInfoSectionResponse {
    /** Updated info section. */
    infoSection?: InfoSection;
}
interface DeleteInfoSectionRequest {
    /** Info section ID */
    infoSectionId: string;
}
interface DeleteInfoSectionResponse {
}
interface QueryInfoSectionsRequest {
    /** Query options. */
    query?: CursorQuery;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryInfoSectionsResponse {
    /** List of info sections. */
    infoSections?: InfoSection[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateInfoSectionsRequest {
    /** Info sections to create. */
    infoSections: InfoSection[];
    /**
     * Whether to return the full created info section entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInfoSectionsResponse {
    /** Info sections created by bulk action. */
    results?: BulkInfoSectionItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkUpdateInfoSectionsRequest {
    /** List of info sections to update. */
    infoSections: MaskedInfoSection[];
    /**
     * Whether to return the full updated info sections entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface MaskedInfoSection {
    /** Info section to update. */
    infoSection?: InfoSection;
}
interface BulkUpdateInfoSectionsResponse {
    /** Info sections updated by bulk action. */
    results?: BulkInfoSectionItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkDeleteInfoSectionsRequest {
    /** IDs of info sections to delete. */
    infoSectionIds: string[];
}
interface BulkDeleteInfoSectionsResponse {
    /** Info sections deleted by bulk action */
    results?: BulkInfoSectionResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInfoSectionResult {
    /** Bulk action metadata for info section. */
    itemMetadata?: ItemMetadata;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface PluginContainerDataWidthNonNullableFields {
    size: WidthType;
}
interface PluginContainerDataNonNullableFields {
    width?: PluginContainerDataWidthNonNullableFields;
    alignment: PluginContainerDataAlignment;
}
interface LinkNonNullableFields {
    url: string;
    anchor: string;
    target: Target;
}
interface ButtonDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    type: Type;
    link?: LinkNonNullableFields;
}
interface TextStyleNonNullableFields {
    textAlignment: TextAlignment;
}
interface CodeBlockDataNonNullableFields {
    textStyle?: TextStyleNonNullableFields;
}
interface DividerDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    lineStyle: LineStyle;
    width: Width;
    alignment: Alignment;
}
interface PDFSettingsNonNullableFields {
    viewMode: ViewMode;
}
interface FileDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    pdfSettings?: PDFSettingsNonNullableFields;
}
interface ImageNonNullableFields {
    link?: LinkNonNullableFields;
}
interface ItemNonNullableFields {
    image?: ImageNonNullableFields;
}
interface LayoutNonNullableFields {
    type: LayoutType;
    orientation: Orientation;
}
interface ItemStyleNonNullableFields {
    crop: Crop;
}
interface ThumbnailsNonNullableFields {
    placement: ThumbnailsAlignment;
}
interface GalleryOptionsNonNullableFields {
    layout?: LayoutNonNullableFields;
    item?: ItemStyleNonNullableFields;
    thumbnails?: ThumbnailsNonNullableFields;
}
interface GalleryDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    items: ItemNonNullableFields[];
    options?: GalleryOptionsNonNullableFields;
}
interface GIFDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    height: number;
    width: number;
}
interface HeadingDataNonNullableFields {
    level: number;
    textStyle?: TextStyleNonNullableFields;
}
interface HTMLDataNonNullableFields {
    url: string;
    html: string;
    containerData?: PluginContainerDataNonNullableFields;
    source: Source;
}
interface ImageDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    link?: LinkNonNullableFields;
}
interface LinkPreviewDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    link?: LinkNonNullableFields;
}
interface MapSettingsNonNullableFields {
    mapType: MapType;
}
interface MapDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    mapSettings?: MapSettingsNonNullableFields;
}
interface ParagraphDataNonNullableFields {
    textStyle?: TextStyleNonNullableFields;
}
interface PermissionsNonNullableFields {
    view: ViewRole;
    vote: VoteRole;
}
interface SettingsNonNullableFields {
    permissions?: PermissionsNonNullableFields;
}
interface PollNonNullableFields {
    settings?: SettingsNonNullableFields;
}
interface PollLayoutNonNullableFields {
    type: PollLayoutType;
    direction: PollLayoutDirection;
}
interface PollDataLayoutNonNullableFields {
    poll?: PollLayoutNonNullableFields;
}
interface BackgroundNonNullableFields {
    type: BackgroundType;
}
interface PollDesignNonNullableFields {
    background?: BackgroundNonNullableFields;
}
interface DesignNonNullableFields {
    poll?: PollDesignNonNullableFields;
}
interface PollDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    poll?: PollNonNullableFields;
    layout?: PollDataLayoutNonNullableFields;
    design?: DesignNonNullableFields;
}
interface AnchorDataNonNullableFields {
    anchor: string;
}
interface LinkDataNonNullableFields {
    link?: LinkNonNullableFields;
}
interface MentionDataNonNullableFields {
    name: string;
    slug: string;
}
interface FontSizeDataNonNullableFields {
    unit: FontType;
}
interface DecorationNonNullableFields {
    anchorData?: AnchorDataNonNullableFields;
    linkData?: LinkDataNonNullableFields;
    mentionData?: MentionDataNonNullableFields;
    fontSizeData?: FontSizeDataNonNullableFields;
    type: DecorationType;
}
interface TextDataNonNullableFields {
    text: string;
    decorations: DecorationNonNullableFields[];
}
interface AppEmbedDataNonNullableFields {
    type: AppType;
}
interface VideoDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
}
interface EmbedDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
}
interface CollapsibleListDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    initialExpandedItems: InitialExpandedItems;
    direction: Direction;
}
interface DimensionsNonNullableFields {
    colsWidthRatio: number[];
    rowsHeight: number[];
    colsMinWidth: number[];
}
interface TableDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    dimensions?: DimensionsNonNullableFields;
}
interface CellStyleNonNullableFields {
    verticalAlignment: VerticalAlignment;
}
interface TableCellDataNonNullableFields {
    cellStyle?: CellStyleNonNullableFields;
}
interface AudioDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
}
interface OrderedListDataNonNullableFields {
    indentation: number;
}
interface BulletedListDataNonNullableFields {
    indentation: number;
}
interface BlockquoteDataNonNullableFields {
    indentation: number;
}
interface CaptionDataNonNullableFields {
    textStyle?: TextStyleNonNullableFields;
}
interface NodeNonNullableFields {
    buttonData?: ButtonDataNonNullableFields;
    codeBlockData?: CodeBlockDataNonNullableFields;
    dividerData?: DividerDataNonNullableFields;
    fileData?: FileDataNonNullableFields;
    galleryData?: GalleryDataNonNullableFields;
    gifData?: GIFDataNonNullableFields;
    headingData?: HeadingDataNonNullableFields;
    htmlData?: HTMLDataNonNullableFields;
    imageData?: ImageDataNonNullableFields;
    linkPreviewData?: LinkPreviewDataNonNullableFields;
    mapData?: MapDataNonNullableFields;
    paragraphData?: ParagraphDataNonNullableFields;
    pollData?: PollDataNonNullableFields;
    textData?: TextDataNonNullableFields;
    appEmbedData?: AppEmbedDataNonNullableFields;
    videoData?: VideoDataNonNullableFields;
    embedData?: EmbedDataNonNullableFields;
    collapsibleListData?: CollapsibleListDataNonNullableFields;
    tableData?: TableDataNonNullableFields;
    tableCellData?: TableCellDataNonNullableFields;
    audioData?: AudioDataNonNullableFields;
    orderedListData?: OrderedListDataNonNullableFields;
    bulletedListData?: BulletedListDataNonNullableFields;
    blockquoteData?: BlockquoteDataNonNullableFields;
    captionData?: CaptionDataNonNullableFields;
    type: NodeType;
    _id: string;
    nodes: NodeNonNullableFields[];
}
interface MetadataNonNullableFields {
    version: number;
}
interface TextNodeStyleNonNullableFields {
    decorations: DecorationNonNullableFields[];
}
interface DocumentStyleNonNullableFields {
    headerOne?: TextNodeStyleNonNullableFields;
    headerTwo?: TextNodeStyleNonNullableFields;
    headerThree?: TextNodeStyleNonNullableFields;
    headerFour?: TextNodeStyleNonNullableFields;
    headerFive?: TextNodeStyleNonNullableFields;
    headerSix?: TextNodeStyleNonNullableFields;
    paragraph?: TextNodeStyleNonNullableFields;
    blockquote?: TextNodeStyleNonNullableFields;
    codeBlock?: TextNodeStyleNonNullableFields;
}
interface RichContentNonNullableFields {
    nodes: NodeNonNullableFields[];
    metadata?: MetadataNonNullableFields;
    documentStyle?: DocumentStyleNonNullableFields;
}
interface InfoSectionNonNullableFields {
    uniqueName: string;
    title: string;
    description?: RichContentNonNullableFields;
}
interface CreateInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields;
}
interface GetInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields;
}
interface GetOrCreateInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface BulkInfoSectionItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: InfoSectionNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkGetOrCreateInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface UpdateInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields;
}
interface QueryInfoSectionsResponseNonNullableFields {
    infoSections: InfoSectionNonNullableFields[];
}
interface BulkCreateInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkUpdateInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkInfoSectionResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
}
interface BulkDeleteInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface InfoSectionCreatedEnvelope {
    entity: InfoSection;
    metadata: EventMetadata;
}
interface InfoSectionUpdatedEnvelope {
    entity: InfoSection;
    metadata: EventMetadata;
}
interface InfoSectionDeletedEnvelope {
    metadata: EventMetadata;
}
interface GetInfoSectionOptions {
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface GetOrCreateInfoSectionOptions {
    /** Info section to retrieve or create. */
    infoSection?: InfoSectionForGetOrCreate;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface BulkGetOrCreateInfoSectionsOptions {
    /** Info sections to retrieve or create. */
    infoSections?: InfoSectionForGetOrCreate[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface UpdateInfoSection {
    /**
     * Info section ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the info section is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the info section.
     *
     * Ignored when creating an info section.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the info section was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the info section was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Unique name. Used as an identifier. */
    uniqueName?: string;
    /** Info section title. */
    title?: string;
    /**
     * Info section description using rich content.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    description?: RichContent;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
    /**
     * Number of products this info section is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Info Sections API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
interface UpdateInfoSectionOptions {
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface QueryInfoSectionsOptions {
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[] | undefined;
}
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface InfoSectionsQueryResult extends QueryCursorResult {
    items: InfoSection[];
    query: InfoSectionsQueryBuilder;
    next: () => Promise<InfoSectionsQueryResult>;
    prev: () => Promise<InfoSectionsQueryResult>;
}
interface InfoSectionsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'uniqueName' | 'title', value: any) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'uniqueName' | 'title', value: any) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: '_createdDate' | '_updatedDate', value: any) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'uniqueName' | 'title', value: string) => InfoSectionsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'uniqueName' | 'title', value: any[]) => InfoSectionsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'uniqueName' | 'title', value: any) => InfoSectionsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'uniqueName' | 'title', value: boolean) => InfoSectionsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'uniqueName' | 'title'>) => InfoSectionsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'uniqueName' | 'title'>) => InfoSectionsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => InfoSectionsQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => InfoSectionsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<InfoSectionsQueryResult>;
}
interface BulkCreateInfoSectionsOptions {
    /**
     * Whether to return the full created info section entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkUpdateInfoSectionsOptions {
    /**
     * Whether to return the full updated info sections entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}

declare function createInfoSection$1(httpClient: HttpClient): CreateInfoSectionSignature;
interface CreateInfoSectionSignature {
    /**
     * Creates an info section.
     *
     * To assign the info section to a product, include the `infoSection.id` or `infoSection.uniqueName`
     * when [creating](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/products-v3/create-product) or
     * [updating](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/products-v3/update-product) a product.
     * @param - Info section to create.
     * @returns Created info section.
     */
    (infoSection: InfoSection): Promise<InfoSection & InfoSectionNonNullableFields>;
}
declare function getInfoSection$1(httpClient: HttpClient): GetInfoSectionSignature;
interface GetInfoSectionSignature {
    /**
     * Retrieves an info section.
     * @param - Info section ID.
     * @returns Info section.
     */
    (infoSectionId: string, options?: GetInfoSectionOptions | undefined): Promise<InfoSection & InfoSectionNonNullableFields>;
}
declare function getOrCreateInfoSection$1(httpClient: HttpClient): GetOrCreateInfoSectionSignature;
interface GetOrCreateInfoSectionSignature {
    /**
     * Retrieves an info section by ID or `uniqueName`, or creates an info section if one with the passed `uniqueName` doesn't exist.
     *
     * > **Note:** If an info section with the passed `uniqueName` doesn't exist, the `uniqueName` and `title` fields are required to create a new info section.
     */
    (options?: GetOrCreateInfoSectionOptions | undefined): Promise<GetOrCreateInfoSectionResponse & GetOrCreateInfoSectionResponseNonNullableFields>;
}
declare function bulkGetOrCreateInfoSections$1(httpClient: HttpClient): BulkGetOrCreateInfoSectionsSignature;
interface BulkGetOrCreateInfoSectionsSignature {
    /**
     * Retrieves multiple info sections by ID or `uniqueName`, or creates multiple info sections if those with the passed `uniqueName` don't exist.
     *
     * > **Note:** If an info section with the passed `uniqueName` doesn't exist, the `uniqueName` and `title` fields are required to create a new info section.
     */
    (options?: BulkGetOrCreateInfoSectionsOptions | undefined): Promise<BulkGetOrCreateInfoSectionsResponse & BulkGetOrCreateInfoSectionsResponseNonNullableFields>;
}
declare function updateInfoSection$1(httpClient: HttpClient): UpdateInfoSectionSignature;
interface UpdateInfoSectionSignature {
    /**
     * Updates an info section.
     *
     *
     * Each time the info section is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating the info section.
     * This ensures you're working with the latest info section and prevents unintended overwrites.
     * @param - Info section ID.
     * @returns Updated info section.
     */
    (_id: string | null, infoSection: UpdateInfoSection, options?: UpdateInfoSectionOptions | undefined): Promise<InfoSection & InfoSectionNonNullableFields>;
}
declare function deleteInfoSection$1(httpClient: HttpClient): DeleteInfoSectionSignature;
interface DeleteInfoSectionSignature {
    /**
     * Deletes an info section.
     *
     * > **Note:** Deleting an info section will also remove it from all products it is assigned to.
     * @param - Info section ID
     */
    (infoSectionId: string): Promise<void>;
}
declare function queryInfoSections$1(httpClient: HttpClient): QueryInfoSectionsSignature;
interface QueryInfoSectionsSignature {
    /**
     * Retrieves a list of up to 100 info sections, given the provided filtering, sorting, and cursor paging.
     * Pass supported values to the `fields` array in the request to include those fields in the response.
     *
     *
     * Query Info Sections runs with these defaults, which you can override:
     *
     * - `createdDate` is sorted in `DESC` order
     * - `cursorPaging.limit` is `100`
     *
     * For field support for filters and sorting,
     * see [Info Sections: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/info-sections-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Query_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    (options?: QueryInfoSectionsOptions | undefined): InfoSectionsQueryBuilder;
}
declare function bulkCreateInfoSections$1(httpClient: HttpClient): BulkCreateInfoSectionsSignature;
interface BulkCreateInfoSectionsSignature {
    /**
     * Creates multiple info sections.
     * @param - Info sections to create.
     */
    (infoSections: InfoSection[], options?: BulkCreateInfoSectionsOptions | undefined): Promise<BulkCreateInfoSectionsResponse & BulkCreateInfoSectionsResponseNonNullableFields>;
}
declare function bulkUpdateInfoSections$1(httpClient: HttpClient): BulkUpdateInfoSectionsSignature;
interface BulkUpdateInfoSectionsSignature {
    /**
     * Updates multiple info sections.
     *
     * Each time an info section is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an info section.
     * This ensures you're working with the latest info section and prevents unintended overwrites.
     * @param - List of info sections to update.
     */
    (infoSections: MaskedInfoSection[], options?: BulkUpdateInfoSectionsOptions | undefined): Promise<BulkUpdateInfoSectionsResponse & BulkUpdateInfoSectionsResponseNonNullableFields>;
}
declare function bulkDeleteInfoSections$1(httpClient: HttpClient): BulkDeleteInfoSectionsSignature;
interface BulkDeleteInfoSectionsSignature {
    /**
     * Deletes multiple info sections.
     * @param - IDs of info sections to delete.
     */
    (infoSectionIds: string[]): Promise<BulkDeleteInfoSectionsResponse & BulkDeleteInfoSectionsResponseNonNullableFields>;
}
declare const onInfoSectionCreated$1: EventDefinition<InfoSectionCreatedEnvelope, "wix.stores.catalog.v3.info_section_created">;
declare const onInfoSectionUpdated$1: EventDefinition<InfoSectionUpdatedEnvelope, "wix.stores.catalog.v3.info_section_updated">;
declare const onInfoSectionDeleted$1: EventDefinition<InfoSectionDeletedEnvelope, "wix.stores.catalog.v3.info_section_deleted">;

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const createInfoSection: MaybeContext<BuildRESTFunction<typeof createInfoSection$1> & typeof createInfoSection$1>;
declare const getInfoSection: MaybeContext<BuildRESTFunction<typeof getInfoSection$1> & typeof getInfoSection$1>;
declare const getOrCreateInfoSection: MaybeContext<BuildRESTFunction<typeof getOrCreateInfoSection$1> & typeof getOrCreateInfoSection$1>;
declare const bulkGetOrCreateInfoSections: MaybeContext<BuildRESTFunction<typeof bulkGetOrCreateInfoSections$1> & typeof bulkGetOrCreateInfoSections$1>;
declare const updateInfoSection: MaybeContext<BuildRESTFunction<typeof updateInfoSection$1> & typeof updateInfoSection$1>;
declare const deleteInfoSection: MaybeContext<BuildRESTFunction<typeof deleteInfoSection$1> & typeof deleteInfoSection$1>;
declare const queryInfoSections: MaybeContext<BuildRESTFunction<typeof queryInfoSections$1> & typeof queryInfoSections$1>;
declare const bulkCreateInfoSections: MaybeContext<BuildRESTFunction<typeof bulkCreateInfoSections$1> & typeof bulkCreateInfoSections$1>;
declare const bulkUpdateInfoSections: MaybeContext<BuildRESTFunction<typeof bulkUpdateInfoSections$1> & typeof bulkUpdateInfoSections$1>;
declare const bulkDeleteInfoSections: MaybeContext<BuildRESTFunction<typeof bulkDeleteInfoSections$1> & typeof bulkDeleteInfoSections$1>;

type _publicOnInfoSectionCreatedType = typeof onInfoSectionCreated$1;
/**
 * Triggered when an info section is created.
 */
declare const onInfoSectionCreated: ReturnType<typeof createEventModule<_publicOnInfoSectionCreatedType>>;

type _publicOnInfoSectionUpdatedType = typeof onInfoSectionUpdated$1;
/**
 * Triggered when an info section is updated.
 */
declare const onInfoSectionUpdated: ReturnType<typeof createEventModule<_publicOnInfoSectionUpdatedType>>;

type _publicOnInfoSectionDeletedType = typeof onInfoSectionDeleted$1;
/**
 * Triggered when an info section is deleted.
 */
declare const onInfoSectionDeleted: ReturnType<typeof createEventModule<_publicOnInfoSectionDeletedType>>;

export { type ActionEvent, Alignment, type AnchorData, type App, type AppEmbedData, type AppEmbedDataAppDataOneOf, AppType, type ApplicationError, type AudioData, type Background, type BackgroundBackgroundOneOf, BackgroundType, type BaseEventMetadata, type BlockquoteData, type BookingData, type Border, type BorderColors, type BulkActionMetadata, type BulkCreateInfoSectionsOptions, type BulkCreateInfoSectionsRequest, type BulkCreateInfoSectionsResponse, type BulkCreateInfoSectionsResponseNonNullableFields, type BulkDeleteInfoSectionsRequest, type BulkDeleteInfoSectionsResponse, type BulkDeleteInfoSectionsResponseNonNullableFields, type BulkGetOrCreateInfoSectionsOptions, type BulkGetOrCreateInfoSectionsRequest, type BulkGetOrCreateInfoSectionsResponse, type BulkGetOrCreateInfoSectionsResponseNonNullableFields, type BulkInfoSectionItemResult, type BulkInfoSectionResult, type BulkUpdateInfoSectionsOptions, type BulkUpdateInfoSectionsRequest, type BulkUpdateInfoSectionsResponse, type BulkUpdateInfoSectionsResponseNonNullableFields, type BulletedListData, type ButtonData, type CaptionData, type CellStyle, type CodeBlockData, type CollapsibleListData, type ColorData, type Colors, type CreateInfoSectionRequest, type CreateInfoSectionResponse, type CreateInfoSectionResponseNonNullableFields, Crop, type CursorPaging, type CursorPagingMetadata, type CursorQuery, type CursorQueryPagingMethodOneOf, type Cursors, type Decoration, type DecorationDataOneOf, DecorationType, type DeleteInfoSectionRequest, type DeleteInfoSectionResponse, type Design, type Dimensions, Direction, type DividerData, type DocumentStyle, type DomainEvent, type DomainEventBodyOneOf, type EmbedData, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventData, type EventMetadata, type File, type FileData, type FileSource, type FileSourceDataOneOf, type FontSizeData, FontType, type GIF, type GIFData, type GalleryData, type GalleryOptions, type GetInfoSectionOptions, type GetInfoSectionRequest, type GetInfoSectionResponse, type GetInfoSectionResponseNonNullableFields, type GetOrCreateInfoSectionOptions, type GetOrCreateInfoSectionRequest, type GetOrCreateInfoSectionResponse, type GetOrCreateInfoSectionResponseNonNullableFields, type Gradient, type HTMLData, type HTMLDataDataOneOf, type HeadingData, type Height, type IdentificationData, type IdentificationDataIdOneOf, type Image, type ImageData, type InfoSection, type InfoSectionCreatedEnvelope, type InfoSectionDeletedEnvelope, type InfoSectionForGetOrCreate, type InfoSectionNonNullableFields, type InfoSectionUpdatedEnvelope, type InfoSectionsQueryBuilder, type InfoSectionsQueryResult, InitialExpandedItems, type InvalidateCache, type InvalidateCacheGetByOneOf, type Item, type ItemDataOneOf, type ItemMetadata, type ItemStyle, type Layout, LayoutType, LineStyle, type Link, type LinkData, type LinkDataOneOf, type LinkPreviewData, type ListValue, type MapData, type MapSettings, MapType, type MaskedInfoSection, type Media, type MentionData, type MessageEnvelope, type Metadata, type Node, type NodeDataOneOf, type NodeStyle, NodeType, NullValue, type Oembed, type Option, type OptionDesign, type OptionLayout, type OrderedListData, Orientation, type PDFSettings, type Page, type ParagraphData, type Permissions, type PlaybackOptions, type PluginContainerData, PluginContainerDataAlignment, type PluginContainerDataWidth, type PluginContainerDataWidthDataOneOf, type Poll, type PollData, type PollDataLayout, type PollDesign, type PollLayout, PollLayoutDirection, PollLayoutType, type QueryInfoSectionsOptions, type QueryInfoSectionsRequest, type QueryInfoSectionsResponse, type QueryInfoSectionsResponseNonNullableFields, type Rel, RequestedFields, type RestoreInfo, type RichContent, type Settings, SortOrder, type Sorting, Source, type Spoiler, type SpoilerData, type Styles, type TableCellData, type TableData, Target, TextAlignment, type TextData, type TextNodeStyle, type TextStyle, type Thumbnails, ThumbnailsAlignment, Type, type URI, type UpdateInfoSection, type UpdateInfoSectionOptions, type UpdateInfoSectionRequest, type UpdateInfoSectionResponse, type UpdateInfoSectionResponseNonNullableFields, VerticalAlignment, type Video, type VideoData, ViewMode, ViewRole, VoteRole, WebhookIdentityType, Width, WidthType, type _publicOnInfoSectionCreatedType, type _publicOnInfoSectionDeletedType, type _publicOnInfoSectionUpdatedType, bulkCreateInfoSections, bulkDeleteInfoSections, bulkGetOrCreateInfoSections, bulkUpdateInfoSections, createInfoSection, deleteInfoSection, getInfoSection, getOrCreateInfoSection, onInfoSectionCreated, onInfoSectionDeleted, onInfoSectionUpdated, onInfoSectionCreated$1 as publicOnInfoSectionCreated, onInfoSectionDeleted$1 as publicOnInfoSectionDeleted, onInfoSectionUpdated$1 as publicOnInfoSectionUpdated, queryInfoSections, updateInfoSection };
