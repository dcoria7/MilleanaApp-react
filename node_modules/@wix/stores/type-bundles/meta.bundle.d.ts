interface WishlistData$1 {
    /** GUID unique to this list for this site */
    id?: string | null;
    /** Member id the list belongs to */
    ownerId?: string;
    /** List of items in the list. Not necessarily the full list (can depends on request data) */
    items?: WishlistItem$1[];
    /** Total count of items in the list */
    totalCount?: number;
}
interface WishlistItem$1 {
    /** Unique identifier for an item of this type and origin */
    id?: string;
    /**
     * The data the item was save to the list
     * @readonly
     */
    dateAdded?: Date | null;
    /** The type of the item. For example "product" */
    type?: string;
    /** The origin of the item. Should be the scope the item type is related to. For example "wixstores" */
    origin?: string;
}
interface WishlistItemKind$1 {
    /** The type of the item. For example "product" */
    type?: string;
    /** The origin of the item. Should be the scope the item type is related to. For example "wixstores" */
    origin?: string;
}
interface GetWishlistByIdRequest$1 {
    /** Unique identifier representing requested list */
    id: string;
    /** List length limit. Default is 100 */
    limit?: number | null;
    /** List starting index offset. Default is 0 */
    offset?: number | null;
    /** Filter requested list by specific kinds of items */
    kind?: WishlistItemKind$1[];
}
interface GetWishlistByIdResponse$1 {
    /** Object containing requested list data */
    wishlist?: WishlistData$1;
}
interface WishlistItemNonNullableFields$1 {
    id: string;
    type: string;
    origin: string;
}
interface WishlistDataNonNullableFields$1 {
    ownerId: string;
    items: WishlistItemNonNullableFields$1[];
    totalCount: number;
}
interface GetWishlistByIdResponseNonNullableFields$1 {
    wishlist?: WishlistDataNonNullableFields$1;
}

interface WishlistData {
    /** GUID unique to this list for this site */
    _id?: string | null;
    /** Member id the list belongs to */
    ownerId?: string;
    /** List of items in the list. Not necessarily the full list (can depends on request data) */
    items?: WishlistItem[];
    /** Total count of items in the list */
    totalCount?: number;
}
interface WishlistItem {
    /** Unique identifier for an item of this type and origin */
    _id?: string;
    /**
     * The data the item was save to the list
     * @readonly
     */
    dateAdded?: Date | null;
    /** The type of the item. For example "product" */
    type?: string;
    /** The origin of the item. Should be the scope the item type is related to. For example "wixstores" */
    origin?: string;
}
interface WishlistItemKind {
    /** The type of the item. For example "product" */
    type?: string;
    /** The origin of the item. Should be the scope the item type is related to. For example "wixstores" */
    origin?: string;
}
interface GetWishlistByIdRequest {
    /** Unique identifier representing requested list */
    _id: string;
    /** List length limit. Default is 100 */
    limit?: number | null;
    /** List starting index offset. Default is 0 */
    offset?: number | null;
    /** Filter requested list by specific kinds of items */
    kind?: WishlistItemKind[];
}
interface GetWishlistByIdResponse {
    /** Object containing requested list data */
    wishlist?: WishlistData;
}
interface WishlistItemNonNullableFields {
    _id: string;
    type: string;
    origin: string;
}
interface WishlistDataNonNullableFields {
    ownerId: string;
    items: WishlistItemNonNullableFields[];
    totalCount: number;
}
interface GetWishlistByIdResponseNonNullableFields {
    wishlist?: WishlistDataNonNullableFields;
}

type __PublicMethodMetaInfo$c<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getWishlistById(): __PublicMethodMetaInfo$c<'POST', {}, GetWishlistByIdRequest, GetWishlistByIdRequest$1, GetWishlistByIdResponse & GetWishlistByIdResponseNonNullableFields, GetWishlistByIdResponse$1 & GetWishlistByIdResponseNonNullableFields$1>;

declare const meta$c_getWishlistById: typeof getWishlistById;
declare namespace meta$c {
  export { type __PublicMethodMetaInfo$c as __PublicMethodMetaInfo, meta$c_getWishlistById as getWishlistById };
}

interface Collection$3 {
    /**
     * Collection ID (generated automatically by the catalog).
     * @readonly
     */
    id?: string | null;
    /** Collection name. */
    name?: string | null;
    /**
     * Media items (images, videos etc) associated with this collection. Read only.
     * @readonly
     */
    media?: Media$7;
    /**
     * Number of products in the collection. Read only.
     * @readonly
     */
    numberOfProducts?: number;
    /** Collection description. */
    description?: string | null;
    /** Collection slug. */
    slug?: string | null;
    /** Collection visibility. Only impacts dynamic pages, no impact on static pages. Default: `true`. */
    visible?: boolean | null;
}
interface Media$7 {
    /** Primary media (image, video etc) associated with this product. */
    mainMedia?: MediaItem$3;
    /** Media (images, videos etc) associated with this product. */
    items?: MediaItem$3[];
}
interface MediaItem$3 extends MediaItemItemOneOf$3 {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize$3;
    /** Video data (URL, size). */
    video?: MediaItemVideo$3;
    /** Media item thumbnail details. */
    thumbnail?: MediaItemUrlAndSize$3;
    /** Media item type (image, video, etc.). */
    mediaType?: MediaItemType$3;
    /** Media item title. */
    title?: string;
    /** Media ID (for example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`). */
    id?: string;
}
/** @oneof */
interface MediaItemItemOneOf$3 {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize$3;
    /** Video data (URL, size). */
    video?: MediaItemVideo$3;
}
interface MediaItemUrlAndSize$3 {
    /** Media item URL. */
    url?: string;
    /** Media item width. */
    width?: number;
    /** Media item height. */
    height?: number;
    /** Media format (mp4, png, etc.). */
    format?: string | null;
    /** Alt text. This text will be shown in case the image is not available. */
    altText?: string | null;
}
declare enum MediaItemType$3 {
    unspecified_media_item_type = "unspecified_media_item_type",
    image = "image",
    video = "video",
    audio = "audio",
    document = "document",
    zip = "zip"
}
interface MediaItemVideo$3 {
    /** Data (URL, size) about each resolution for which this video is available. */
    files?: MediaItemUrlAndSize$3[];
    /** ID of an image taken from the video. Used primarily for Wix Search indexing. For example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`. */
    stillFrameMediaId?: string;
}
interface QueryCollectionsRequest$1 {
    query?: PlatformQuery$3;
}
interface PlatformQuery$3 extends PlatformQueryPagingMethodOneOf$3 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$3;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$f;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting$f[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf$3 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$3;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$f;
}
interface Sorting$f {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$f;
}
declare enum SortOrder$f {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging$3 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging$f {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryCollectionsResponse$1 {
    collections?: Collection$3[];
    metadata?: PlatformPagingMetadata$3;
}
interface PlatformPagingMetadata$3 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$f;
}
interface Cursors$f {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface GetCollectionRequest$1 {
    /** Requested collection ID. */
    id: string;
}
interface GetCollectionResponse$1 {
    collection?: Collection$3;
}
interface GetCollectionBySlugRequest$3 {
    /** Slug of the collection to retrieve. */
    slug: string;
}
interface GetCollectionBySlugResponse$3 {
    /** The requested collection. */
    collection?: Collection$3;
}
interface MediaItemUrlAndSizeNonNullableFields$3 {
    url: string;
    width: number;
    height: number;
}
interface MediaItemVideoNonNullableFields$3 {
    files: MediaItemUrlAndSizeNonNullableFields$3[];
    stillFrameMediaId: string;
}
interface MediaItemNonNullableFields$3 {
    image?: MediaItemUrlAndSizeNonNullableFields$3;
    video?: MediaItemVideoNonNullableFields$3;
    thumbnail?: MediaItemUrlAndSizeNonNullableFields$3;
    mediaType: MediaItemType$3;
    title: string;
    id: string;
}
interface MediaNonNullableFields$5 {
    mainMedia?: MediaItemNonNullableFields$3;
    items: MediaItemNonNullableFields$3[];
}
interface TagNonNullableFields$5 {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields$5 {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields$7 {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields$5[];
}
interface SeoSchemaNonNullableFields$5 {
    tags: TagNonNullableFields$5[];
    settings?: SettingsNonNullableFields$7;
}
interface CollectionNonNullableFields$3 {
    media?: MediaNonNullableFields$5;
    numberOfProducts: number;
    seoSchema?: SeoSchemaNonNullableFields$5;
}
interface QueryCollectionsResponseNonNullableFields$1 {
    collections: CollectionNonNullableFields$3[];
}
interface GetCollectionResponseNonNullableFields$1 {
    collection?: CollectionNonNullableFields$3;
}
interface GetCollectionBySlugResponseNonNullableFields$3 {
    collection?: CollectionNonNullableFields$3;
}

interface Collection$2 {
    /**
     * Collection ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string | null;
    /** Collection name. */
    name?: string | null;
    /**
     * Media items (images, videos etc) associated with this collection. Read only.
     * @readonly
     */
    media?: Media$6;
    /**
     * Number of products in the collection. Read only.
     * @readonly
     */
    numberOfProducts?: number;
    /** Collection description. */
    description?: string | null;
    /** Collection slug. */
    slug?: string | null;
    /** Collection visibility. Only impacts dynamic pages, no impact on static pages. Default: `true`. */
    visible?: boolean | null;
}
interface Media$6 {
    /** Primary media (image, video etc) associated with this product. */
    mainMedia?: MediaItem$2;
    /** Media (images, videos etc) associated with this product. */
    items?: MediaItem$2[];
}
interface MediaItem$2 extends MediaItemItemOneOf$2 {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize$2;
    /** Video data (URL, size). */
    video?: MediaItemVideo$2;
    /** Media item thumbnail details. */
    thumbnail?: MediaItemUrlAndSize$2;
    /** Media item type (image, video, etc.). */
    mediaType?: MediaItemType$2;
    /** Media item title. */
    title?: string;
    /** Media ID (for example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`). */
    _id?: string;
}
/** @oneof */
interface MediaItemItemOneOf$2 {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize$2;
    /** Video data (URL, size). */
    video?: MediaItemVideo$2;
}
interface MediaItemUrlAndSize$2 {
    /** Media item URL. */
    url?: string;
    /** Media item width. */
    width?: number;
    /** Media item height. */
    height?: number;
    /** Media format (mp4, png, etc.). */
    format?: string | null;
    /** Alt text. This text will be shown in case the image is not available. */
    altText?: string | null;
}
declare enum MediaItemType$2 {
    unspecified_media_item_type = "unspecified_media_item_type",
    image = "image",
    video = "video",
    audio = "audio",
    document = "document",
    zip = "zip"
}
interface MediaItemVideo$2 {
    /** Data (URL, size) about each resolution for which this video is available. */
    files?: MediaItemUrlAndSize$2[];
    /** ID of an image taken from the video. Used primarily for Wix Search indexing. For example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`. */
    stillFrameMediaId?: string;
}
interface QueryCollectionsRequest {
    query?: PlatformQuery$2;
}
interface PlatformQuery$2 extends PlatformQueryPagingMethodOneOf$2 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$2;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$e;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting$e[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf$2 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$2;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$e;
}
interface Sorting$e {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$e;
}
declare enum SortOrder$e {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging$2 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging$e {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryCollectionsResponse {
    collections?: Collection$2[];
    metadata?: PlatformPagingMetadata$2;
}
interface PlatformPagingMetadata$2 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$e;
}
interface Cursors$e {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface GetCollectionRequest {
    /** Requested collection ID. */
    _id: string;
}
interface GetCollectionResponse {
    collection?: Collection$2;
}
interface GetCollectionBySlugRequest$2 {
    /** Slug of the collection to retrieve. */
    slug: string;
}
interface GetCollectionBySlugResponse$2 {
    /** The requested collection. */
    collection?: Collection$2;
}
interface MediaItemUrlAndSizeNonNullableFields$2 {
    url: string;
    width: number;
    height: number;
}
interface MediaItemVideoNonNullableFields$2 {
    files: MediaItemUrlAndSizeNonNullableFields$2[];
    stillFrameMediaId: string;
}
interface MediaItemNonNullableFields$2 {
    image?: MediaItemUrlAndSizeNonNullableFields$2;
    video?: MediaItemVideoNonNullableFields$2;
    thumbnail?: MediaItemUrlAndSizeNonNullableFields$2;
    mediaType: MediaItemType$2;
    title: string;
    _id: string;
}
interface MediaNonNullableFields$4 {
    mainMedia?: MediaItemNonNullableFields$2;
    items: MediaItemNonNullableFields$2[];
}
interface TagNonNullableFields$4 {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields$4 {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields$6 {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields$4[];
}
interface SeoSchemaNonNullableFields$4 {
    tags: TagNonNullableFields$4[];
    settings?: SettingsNonNullableFields$6;
}
interface CollectionNonNullableFields$2 {
    media?: MediaNonNullableFields$4;
    numberOfProducts: number;
    seoSchema?: SeoSchemaNonNullableFields$4;
}
interface QueryCollectionsResponseNonNullableFields {
    collections: CollectionNonNullableFields$2[];
}
interface GetCollectionResponseNonNullableFields {
    collection?: CollectionNonNullableFields$2;
}
interface GetCollectionBySlugResponseNonNullableFields$2 {
    collection?: CollectionNonNullableFields$2;
}

type __PublicMethodMetaInfo$b<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function queryCollections(): __PublicMethodMetaInfo$b<'GET', {}, QueryCollectionsRequest, QueryCollectionsRequest$1, QueryCollectionsResponse & QueryCollectionsResponseNonNullableFields, QueryCollectionsResponse$1 & QueryCollectionsResponseNonNullableFields$1>;
declare function getCollection(): __PublicMethodMetaInfo$b<'GET', {
    id: string;
}, GetCollectionRequest, GetCollectionRequest$1, GetCollectionResponse & GetCollectionResponseNonNullableFields, GetCollectionResponse$1 & GetCollectionResponseNonNullableFields$1>;
declare function getCollectionBySlug$1(): __PublicMethodMetaInfo$b<'GET', {
    slug: string;
}, GetCollectionBySlugRequest$2, GetCollectionBySlugRequest$3, GetCollectionBySlugResponse$2 & GetCollectionBySlugResponseNonNullableFields$2, GetCollectionBySlugResponse$3 & GetCollectionBySlugResponseNonNullableFields$3>;

declare const meta$b_getCollection: typeof getCollection;
declare const meta$b_queryCollections: typeof queryCollections;
declare namespace meta$b {
  export { type __PublicMethodMetaInfo$b as __PublicMethodMetaInfo, meta$b_getCollection as getCollection, getCollectionBySlug$1 as getCollectionBySlug, meta$b_queryCollections as queryCollections };
}

interface Product$5 {
    /**
     * Product ID (generated automatically by the catalog).
     * @readonly
     */
    id?: string;
    /**
     * Product name.
     *
     * Min: 1 character
     * Max: 80 characters
     */
    name?: string | null;
    /** A friendly URL name (generated automatically by the catalog when a product is created), can be updated. */
    slug?: string;
    /** Whether the product is visible to site visitors. */
    visible?: boolean | null;
    /** Currently, only creating physical products ( `"productType": "physical"` ) is supported via the API. */
    productType?: ProductType$3;
    /** Product description. Accepts [rich text](https://dev.wix.com/api/rest/wix-stores/rich-text). */
    description?: string | null;
    /** Stock keeping unit. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, SKUs will be set per variant, and this field will be empty. */
    sku?: string | null;
    /** Product weight. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, weight will be set per variant, and this field will be empty. */
    weight?: number | null;
    /**
     * Product weight range. The minimum and maximum weights of all the variants.
     * @readonly
     */
    weightRange?: NumericPropertyRange$1;
    /**
     * Product inventory status (in future this will be writable via Inventory API).
     * @readonly
     */
    stock?: Stock$1;
    /**
     * Deprecated (use `priceData` instead).
     * @readonly
     * @deprecated
     */
    price?: PriceData$1;
    /** Price data. */
    priceData?: PriceData$1;
    /**
     * Price data, converted to the currency specified in request header.
     * @readonly
     */
    convertedPriceData?: PriceData$1;
    /**
     * Product price range. The minimum and maximum prices of all the variants.
     * @readonly
     */
    priceRange?: NumericPropertyRange$1;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData$1;
    /**
     * Product cost range. The minimum and maximum costs of all the variants.
     * @readonly
     */
    costRange?: NumericPropertyRange$1;
    /** Price per unit data. */
    pricePerUnitData?: PricePerUnitData$1;
    /** Additional text that the store owner can assign to the product (e.g. shipping details, refund policy, etc.). */
    additionalInfoSections?: AdditionalInfoSection$1[];
    /**
     * Deprecated (use `ribbon` instead).
     * @readonly
     * @deprecated
     */
    ribbons?: Ribbon$5[];
    /**
     * Media items (images, videos etc) associated with this product (writable via [Add Product Media](https://dev.wix.com/api/rest/wix-stores/catalog/products/add-product-media) endpoint).
     * @readonly
     */
    media?: Media$5;
    /**
     * Text box for the customer to add a message to their order (e.g., customization request). Currently writable only from the UI.
     * @readonly
     */
    customTextFields?: CustomTextField$1[];
    /** Whether variants are being managed for this product - enables unique SKU, price and weight per variant. Also affects inventory data. */
    manageVariants?: boolean | null;
    /** Options for this product. */
    productOptions?: ProductOption$1[];
    /**
     * Product page URL for this product (generated automatically by the server).
     * @readonly
     */
    productPageUrl?: PageUrl$1;
    /**
     * Product’s unique numeric ID (assigned in ascending order).
     * Primarily used for sorting and filtering when crawling all products.
     * @readonly
     */
    numericId?: string;
    /**
     * Inventory item ID - ID referencing the inventory system.
     * @readonly
     */
    inventoryItemId?: string;
    /** Discount deducted from the product's original price. */
    discount?: Discount$3;
    /**
     * A list of all collection IDs that this product is included in (writable via the Catalog > Collection APIs).
     * @readonly
     */
    collectionIds?: string[];
    /**
     * Product variants, will be provided if the the request was sent with the `includeVariants: true`.
     *
     * Max: 1,000 variants
     * @readonly
     */
    variants?: Variant$3[];
    /**
     * Date and time the product was last updated.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Date and time the product was created.
     * @readonly
     */
    createdDate?: Date | null;
    /** Custom SEO data for the product. */
    seoData?: SeoSchema$3;
    /** Product ribbon. Used to highlight relevant information about a product. For example, "Sale", "New Arrival", "Sold Out". */
    ribbon?: string | null;
    /** Product brand. Including a brand name can help improve site and product [visibility on search engines](https://support.wix.com/en/article/adding-brand-names-to-boost-product-page-seo-in-wix-stores). */
    brand?: string | null;
}
declare enum ProductType$3 {
    unspecified_product_type = "unspecified_product_type",
    physical = "physical",
    digital = "digital"
}
interface NumericPropertyRange$1 {
    /** Minimum value. */
    minValue?: number;
    /** Maximum value. */
    maxValue?: number;
}
interface Stock$1 {
    /** Whether inventory is being tracked */
    trackInventory?: boolean;
    /** Quantity currently left in inventory */
    quantity?: number | null;
    /**
     * Whether the product is currently in stock (relevant only when tracking manually)
     * Deprecated (use `inventoryStatus` instead)
     * @deprecated
     */
    inStock?: boolean;
    /**
     * The current status of the inventory
     * + `IN_STOCK` - In stock
     * + `OUT_OF_STOCK` - Not in stock
     * + `PARTIALLY_OUT_OF_STOCK` - Some of the variants are not in stock
     */
    inventoryStatus?: InventoryStatus$3;
}
declare enum InventoryStatus$3 {
    IN_STOCK = "IN_STOCK",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    PARTIALLY_OUT_OF_STOCK = "PARTIALLY_OUT_OF_STOCK"
}
interface PriceData$1 {
    /**
     * Product price currency
     * @readonly
     */
    currency?: string;
    /** Product price */
    price?: number | null;
    /**
     * Discounted product price (if no discounted price is set, the product price is returned)
     * @readonly
     */
    discountedPrice?: number;
    /**
     * The product price and discounted price, formatted with the currency
     * @readonly
     */
    formatted?: FormattedPrice$1;
    /**
     * Price per unit
     * @readonly
     */
    pricePerUnit?: number | null;
}
interface FormattedPrice$1 {
    /** Product price formatted with the currency */
    price?: string;
    /** Discounted product price formatted with the currency (if no discounted price is set, the product formatted price is returned) */
    discountedPrice?: string;
    /**
     * Price per unit
     * @readonly
     */
    pricePerUnit?: string | null;
}
interface CostAndProfitData$1 {
    /** Item cost. */
    itemCost?: number | null;
    /**
     * Item cost formatted with currency symbol.
     * @readonly
     */
    formattedItemCost?: string;
    /**
     * Profit. Calculated by reducing `cost` from `discounted_price`.
     * @readonly
     */
    profit?: number;
    /**
     * Profit formatted with currency symbol.
     * @readonly
     */
    formattedProfit?: string;
    /**
     * Profit Margin. Calculated by dividing `profit` by `discounted_price`.
     * The result is rounded to 4 decimal places.
     * @readonly
     */
    profitMargin?: number;
}
interface PricePerUnitData$1 {
    /** Total quantity */
    totalQuantity?: number;
    /** Total measurement unit */
    totalMeasurementUnit?: MeasurementUnit$3;
    /** Base quantity */
    baseQuantity?: number;
    /** Base measurement unit */
    baseMeasurementUnit?: MeasurementUnit$3;
}
declare enum MeasurementUnit$3 {
    UNSPECIFIED = "UNSPECIFIED",
    ML = "ML",
    CL = "CL",
    L = "L",
    CBM = "CBM",
    MG = "MG",
    G = "G",
    KG = "KG",
    MM = "MM",
    CM = "CM",
    M = "M",
    SQM = "SQM",
    OZ = "OZ",
    LB = "LB",
    FLOZ = "FLOZ",
    PT = "PT",
    QT = "QT",
    GAL = "GAL",
    IN = "IN",
    FT = "FT",
    YD = "YD",
    SQFT = "SQFT"
}
interface AdditionalInfoSection$1 {
    /** Product info section title */
    title?: string;
    /** Product info section description */
    description?: string;
}
interface Ribbon$5 {
    /** Ribbon text */
    text?: string;
}
interface Media$5 {
    /** Primary media (image, video etc) associated with this product. */
    mainMedia?: MediaItem$1;
    /** Media (images, videos etc) associated with this product. */
    items?: MediaItem$1[];
}
interface MediaItem$1 extends MediaItemItemOneOf$1 {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize$1;
    /** Video data (URL, size). */
    video?: MediaItemVideo$1;
    /** Media item thumbnail details. */
    thumbnail?: MediaItemUrlAndSize$1;
    /** Media item type (image, video, etc.). */
    mediaType?: MediaItemType$1;
    /** Media item title. */
    title?: string;
    /** Media ID (for example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`). */
    id?: string;
}
/** @oneof */
interface MediaItemItemOneOf$1 {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize$1;
    /** Video data (URL, size). */
    video?: MediaItemVideo$1;
}
interface MediaItemUrlAndSize$1 {
    /** Media item URL. */
    url?: string;
    /** Media item width. */
    width?: number;
    /** Media item height. */
    height?: number;
    /** Media format (mp4, png, etc.). */
    format?: string | null;
    /** Alt text. This text will be shown in case the image is not available. */
    altText?: string | null;
}
declare enum MediaItemType$1 {
    unspecified_media_item_type = "unspecified_media_item_type",
    image = "image",
    video = "video",
    audio = "audio",
    document = "document",
    zip = "zip"
}
interface MediaItemVideo$1 {
    /** Data (URL, size) about each resolution for which this video is available. */
    files?: MediaItemUrlAndSize$1[];
    /** ID of an image taken from the video. Used primarily for Wix Search indexing. For example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`. */
    stillFrameMediaId?: string;
}
interface CustomTextField$1 {
    /** Text box title */
    title?: string;
    /** Text box input max length */
    maxLength?: number;
    /** Whether this text box is mandatory */
    mandatory?: boolean;
}
interface ProductOption$1 {
    /**
     * Option type - color or other(drop down)
     * @readonly
     */
    optionType?: OptionType$1;
    /** Option name. */
    name?: string;
    /** Choices available for this option. */
    choices?: Choice$3[];
}
declare enum OptionType$1 {
    unspecified_option_type = "unspecified_option_type",
    drop_down = "drop_down",
    color = "color"
}
interface Choice$3 {
    /** Choice value. */
    value?: string;
    /** Choice description. */
    description?: string;
    /**
     * Media items (images, videos) associated with this choice
     * @readonly
     */
    media?: Media$5;
    /**
     * Based on the customer’s choices, which (if any) variants that include the selected choices are in stock
     * @readonly
     */
    inStock?: boolean;
    /**
     * Based on the customer’s choices, which (if any) variants that include the selected choices are visible
     * @readonly
     */
    visible?: boolean;
}
interface PageUrl$1 {
    /** Base URL. For premium sites, this is the domain. For free sites, this is the site URL (e.g mysite.wixsite.com/mysite). */
    base?: string;
    /** Path to the product page - e.g /product-page/a-product. */
    path?: string;
}
interface Discount$3 {
    /**
     * Discount type:
     * + `"AMOUNT"`
     * + `"PERCENT"`
     */
    type?: DiscountType$5;
    /** Discount value */
    value?: number;
}
declare enum DiscountType$5 {
    UNDEFINED = "UNDEFINED",
    /** No discount */
    NONE = "NONE",
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface Variant$3 {
    /** Requested Variant ID */
    id?: string;
    /** Specific choices within a selection, as option-choice key-value pairs */
    choices?: Record<string, string>;
    variant?: VariantDataWithNoStock$1;
    /**
     * Variant inventory status.
     * @readonly
     */
    stock?: VariantStock$1;
}
interface VariantDataWithNoStock$1 {
    /** Variant price. */
    priceData?: PriceData$1;
    /**
     * Variant price data, converted to currency requested in header.
     * @readonly
     */
    convertedPriceData?: PriceData$1;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData$1;
    /** Variant weight. */
    weight?: number;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Whether the variant is visible to customers. */
    visible?: boolean;
}
interface VariantStock$1 {
    /** Whether inventory is being tracked. */
    trackQuantity?: boolean;
    /** Quantity currently left in inventory. */
    quantity?: number | null;
    /** Whether the product is currently in stock (relevant only when tracking manually). */
    inStock?: boolean;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema$3 {
    /** SEO tag information. */
    tags?: Tag$3[];
    /** SEO general settings. */
    settings?: Settings$5;
}
interface Keyword$3 {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /** The source that added the keyword terms to the SEO settings. */
    origin?: string | null;
}
interface Tag$3 {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
     * For example: `{'name': 'description', 'content': 'the description itself'}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings$5 {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /** User-selected keyword terms for a specific page. */
    keywords?: Keyword$3[];
}
declare enum FileType$3 {
    UNSPECIFIED = "UNSPECIFIED",
    SECURE_PICTURE = "SECURE_PICTURE",
    SECURE_VIDEO = "SECURE_VIDEO",
    SECURE_DOCUMENT = "SECURE_DOCUMENT",
    SECURE_MUSIC = "SECURE_MUSIC",
    SECURE_ARCHIVE = "SECURE_ARCHIVE"
}
interface CreateProductRequest$3 {
    /** Product information. */
    product?: Product$5;
}
interface CreateProductResponse$3 {
    product?: Product$5;
}
interface UpdateProductRequest$3 {
    product: Product$5;
}
interface UpdateProductResponse$3 {
    product?: Product$5;
}
interface DeleteProductRequest$1 {
    /** ID of the product to delete. */
    id: string;
}
interface DeleteProductResponse$1 {
}
interface UpdateVariantsRequest$1 {
    /** ID of the product with managed variants. */
    id: string;
    /** Variant info to update. */
    variants?: VariantOverride$1[];
}
interface VariantOverride$1 {
    /** The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice). You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (Not relevant when passing variant IDs) */
    choices?: Record<string, string>;
    /**
     * List of variant IDs
     * (Not relevant when passing choices)
     */
    variantIds?: string[];
    /** Variant price */
    price?: number | null;
    /** Variant cost of goods */
    cost?: number | null;
    /** Variant weight */
    weight?: number | null;
    /** Variant SKU (stock keeping unit) */
    sku?: string | null;
    /** Whether the variant is visible to  customers */
    visible?: boolean | null;
}
interface UpdateVariantsResponse$1 {
    /** List of the product's variants. */
    variants?: Variant$3[];
}
interface ResetAllVariantDataRequest$1 {
    /** Product ID. */
    id: string;
}
interface ResetAllVariantDataResponse$1 {
}
interface AddProductsToCollectionRequest$1 {
    /** Collection ID. */
    id: string;
    /** IDs of the products to add to the collection, separated by commas. */
    productIds?: string[];
}
interface AddProductsToCollectionResponse$1 {
}
interface RemoveProductsFromCollectionRequest$1 {
    /** Collection ID. */
    id: string;
    /** IDs of the products to remove from the collection. */
    productIds: string[];
}
interface RemoveProductsFromCollectionResponse$1 {
}
interface AddProductMediaRequest$1 {
    /** Product ID. */
    id: string;
    /** Sources of media items already uploaded to the Wix site. */
    media?: MediaDataForWrite$1[];
}
interface MediaDataForWrite$1 extends MediaDataForWriteMediaSourceOneOf$1 {
    /** Media ID. For media items previously saved in Wix Media, the media ID is returned in the Query Product response. */
    mediaId?: string;
    /** Media external URL (for new media items). */
    url?: string;
    /**
     * Assign this media item to a specific product choice.
     * Note that you may set media items for choices under only one option (e.g., if Colors blue, green, and red have media items, Sizes S, M, and L can't have media items assigned to them).
     * You may clear existing media from choices with the [Remove Product Media From Choices](/catalog/products/remove-product-media-from-choices).
     */
    choice?: OptionAndChoice$1;
}
/** @oneof */
interface MediaDataForWriteMediaSourceOneOf$1 {
    /** Media ID. For media items previously saved in Wix Media, the media ID is returned in the Query Product response. */
    mediaId?: string;
    /** Media external URL (for new media items). */
    url?: string;
}
interface OptionAndChoice$1 {
    /** Option to add the media to. */
    option?: string;
    /** Choice to add the media to. */
    choice?: string;
}
interface AddProductMediaResponse$1 {
}
interface RemoveProductMediaRequest$1 {
    /** Product ID. */
    id: string;
    /** List of media IDs to remove. Pass an empty array to delete all media items for the product. */
    mediaIds?: string[];
}
interface RemoveProductMediaResponse$1 {
}
interface AddProductMediaToChoicesRequest$1 {
    /** Product ID. */
    id: string;
    /** Product media items and the choices to add the media to. */
    media?: MediaAssignmentToChoice$1[];
}
interface MediaAssignmentToChoice$1 {
    /** Option name. */
    option?: string;
    /** Choice name. */
    choice?: string;
    /** Media IDs (available via the Query Product endpoint). */
    mediaIds?: string[];
}
interface AddProductMediaToChoicesResponse$1 {
}
interface RemoveProductMediaFromChoicesRequest$1 {
    /** Product ID from whose choices to remove media items. */
    id: string;
    /** Media to remove from choices. If an empty array is passed, all media will be removed from all choices for the given product. */
    media?: MediaAssignmentToChoice$1[];
}
interface RemoveProductMediaFromChoicesResponse$1 {
}
interface DeleteProductOptionsRequest$1 {
    /** ID of the product with options to delete. */
    id: string;
}
interface DeleteProductOptionsResponse$1 {
}
interface RemoveProductBrandRequest$1 {
    /** Product ID. */
    id: string;
}
interface RemoveProductBrandResponse$1 {
}
interface CreateCollectionRequest$1 {
    /** Collection info. */
    collection: Collection$1;
}
interface Collection$1 {
    /**
     * Collection ID (generated automatically by the catalog).
     * @readonly
     */
    id?: string | null;
    /** Collection name. */
    name?: string | null;
    /**
     * Media items (images, videos etc) associated with this collection. Read only.
     * @readonly
     */
    media?: Media$5;
    /**
     * Number of products in the collection. Read only.
     * @readonly
     */
    numberOfProducts?: number;
    /** Collection description. */
    description?: string | null;
    /** Collection slug. */
    slug?: string | null;
    /** Collection visibility. Only impacts dynamic pages, no impact on static pages. Default: `true`. */
    visible?: boolean | null;
}
interface CreateCollectionResponse$1 {
    /** Collection. */
    collection?: Collection$1;
}
interface UpdateCollectionRequest$1 {
    /** Collection info. */
    collection: Collection$1;
}
interface UpdateCollectionResponse$1 {
    /** Updated collection. */
    collection?: Collection$1;
}
interface DeleteCollectionRequest$1 {
    /** ID of the collection to delete. */
    id: string;
}
interface DeleteCollectionResponse$1 {
}
interface RemoveProductRibbonRequest$1 {
    /** Product ID. */
    id: string;
}
interface RemoveProductRibbonResponse$1 {
}
interface BulkUpdateProductsRequest$3 {
    /** Product IDs. */
    ids: string[];
    /** Field to update. */
    set?: SetValue$1;
}
interface SetValue$1 extends SetValueValueOneOf$1 {
    /**
     * Set product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variant prices will be calculated according to the set product price.
     * If variant price is negative after setting new price, the update will fail.
     */
    price?: number;
    /**
     * Set product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be set per variant.
     */
    cost?: number;
    /**
     * Set product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be set per variant.
     */
    weight?: number;
    /** Set product ribbon. Pass empty string to remove existing ribbon. */
    ribbon?: string;
    /** Set product brand. Pass empty string to remove existing brand. */
    brand?: string;
}
/** @oneof */
interface SetValueValueOneOf$1 {
    /**
     * Set product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variant prices will be calculated according to the set product price.
     * If variant price is negative after setting new price, the update will fail.
     */
    price?: number;
    /**
     * Set product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be set per variant.
     */
    cost?: number;
    /**
     * Set product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be set per variant.
     */
    weight?: number;
    /** Set product ribbon. Pass empty string to remove existing ribbon. */
    ribbon?: string;
    /** Set product brand. Pass empty string to remove existing brand. */
    brand?: string;
}
interface BulkUpdateProductsResponse$3 {
    /** Bulk action results. */
    results?: BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$b;
}
interface BulkProductResult$1 {
    /** Item metadata. */
    itemMetadata?: ItemMetadata$b;
}
interface ItemMetadata$b {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$d;
}
interface ApplicationError$d {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$b {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkAdjustProductPropertiesRequest$1 {
    /** Product IDs. */
    ids: string[];
    /** Numerical property to adjust. */
    adjust?: AdjustValue$1;
}
interface AdjustValue$1 extends AdjustValueValueOneOf$1 {
    /**
     * Adjust product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variants prices will be calculated according to the adjusted price.
     * If variant price is negative after the adjustment, the update will fail.
     */
    price?: PropertyAdjustmentData$1;
    /**
     * Adjust product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be adjusted per variant.
     */
    cost?: PropertyAdjustmentData$1;
    /**
     * Adjust product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be adjusted per variant.
     */
    weight?: PropertyAdjustmentData$1;
}
/** @oneof */
interface AdjustValueValueOneOf$1 {
    /**
     * Adjust product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variants prices will be calculated according to the adjusted price.
     * If variant price is negative after the adjustment, the update will fail.
     */
    price?: PropertyAdjustmentData$1;
    /**
     * Adjust product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be adjusted per variant.
     */
    cost?: PropertyAdjustmentData$1;
    /**
     * Adjust product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be adjusted per variant.
     */
    weight?: PropertyAdjustmentData$1;
}
interface PropertyAdjustmentData$1 extends PropertyAdjustmentDataByOneOf$1 {
    /** Adjust by percentage. */
    percentage?: PercentageData$1;
    /** Adjust by amount. */
    amount?: number;
}
/** @oneof */
interface PropertyAdjustmentDataByOneOf$1 {
    /** Adjust by percentage. */
    percentage?: PercentageData$1;
    /** Adjust by amount. */
    amount?: number;
}
interface PercentageData$1 {
    /**
     * If `true`, result will be rounded to the nearest whole number.
     * If `false`, result will be rounded to 2 places after the decimal point.
     */
    roundToInt?: boolean;
    /**
     * Percentage value, as a whole number (integer) between `-100` and `1000`.
     *
     * For example:
     * + Pass `100` to increase value by 100% (multiply original value by 2).
     * + Pass `1000` to increase value by 1000% (multiply original value by 10).
     * + Pass `-50` to decrease value by 50% (original value is halved).
     */
    rate?: number;
}
interface BulkAdjustProductPropertiesResponse$1 {
    /** Bulk action results. */
    results?: BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$b;
}
interface Paging$5 {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface PagingMetadata$5 {
    /** Amount of items to load per page */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number;
}
interface QueryProductsPlatformizedRequest$1 {
    query?: PlatformQuery$1;
}
interface PlatformQuery$1 extends PlatformQueryPagingMethodOneOf$1 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$1;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$d;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting$d[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf$1 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging$1;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$d;
}
interface Sorting$d {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$d;
}
declare enum SortOrder$d {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging$1 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging$d {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryProductsPlatformizedResponse$1 {
    products?: Product$5[];
    metadata?: PlatformPagingMetadata$1;
}
interface PlatformPagingMetadata$1 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$d;
}
interface Cursors$d {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface GetProductRequest$1 {
    /** Requested product ID. */
    id: string;
    /** Whether merchant specific data, such as cost and profit data, should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface GetProductResponse$1 {
    /** Requested product data. */
    product?: Product$5;
}
interface GetCollectionBySlugRequest$1 {
    /** Slug of the collection to retrieve. */
    slug: string;
}
interface GetCollectionBySlugResponse$1 {
    /** The requested collection. */
    collection?: Collection$1;
}
interface ProductOptionsAvailabilityRequest$1 {
    /** Requested product ID. */
    id: string;
    /** Array containing the selected options. For example, `["color": "Blue", "size": "Large"]`. */
    options?: Record<string, string>;
}
interface ProductOptionsAvailabilityResponse$1 {
    /** Variant information, given that all the choices were provided. */
    selectedVariant?: VariantData$1;
    /** Information about media items (images, videos, etc.) associated with this choice. */
    media?: Media$5;
    /** Options information (color, size, etc.) for this product, with the inventory and visibility fields updated based on the provided choices. */
    productOptions?: ProductOption$1[];
    /** Whether all the selected choices result in a visible, in-stock variant. */
    availableForPurchase?: boolean;
}
interface VariantData$1 {
    /** Variant price. */
    price?: PriceData$1;
    /**
     * Variant price data converted to currency provided in header.
     * @readonly
     */
    convertedPriceData?: PriceData$1;
    /** Variant weight. */
    weight?: number | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Quantity currently in inventory (relevant only when tracking by inventory). */
    quantity?: number | null;
    /** Whether the product is currently in stock (relevant only when tracking manually). */
    inStock?: boolean;
    /** Whether the variant is visible to customers. */
    visible?: boolean;
}
interface QueryProductVariantsRequest$1 {
    /** Requested product ID. */
    id: string;
    /**
     * The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice).
     * You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (not relevant when passing variant IDs).
     */
    choices?: Record<string, string>;
    /** List of variant IDs (not relevant when passing choices). */
    variantIds?: string[];
    paging?: Paging$5;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface QueryProductVariantsResponse$1 {
    /** List of variants based on the specified filters and sorting. */
    variants?: Variant$3[];
    metadata?: PagingMetadata$5;
    totalResults?: number;
}
interface QueryStoreVariantsRequest$1 {
    /** Query options. */
    query?: PlatformQuery$1;
}
interface QueryStoreVariantsResponse$1 {
    /** List of variants based on the specified filters and sorting. */
    variants?: StoreVariant$1[];
    /** Details on the paged set of results returned. */
    metadata?: PlatformPagingMetadata$1;
}
interface StoreVariant$1 {
    /** Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen: {productId}.{variantId}. */
    id?: string;
    /** Variant ID. */
    variantId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant name. */
    variantName?: string;
    /** Product name. */
    productName?: string;
    /** Whether the variant is managed or represents a product. */
    managedVariant?: boolean;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Variant inventory status. */
    stock?: VariantStock$1;
    /** The selected options of this variant. For example, `{"Color": "Blue", "Size": "Large"}`. */
    choices?: Record<string, string>;
    /** Collections that include this variant. */
    collectionIds?: string[];
    /**
     * Media items (images, videos) associated with this variant.
     * @readonly
     */
    media?: PlatformMedia$1;
    /** Preorder information. */
    preorderInfo?: PreorderInfo$7;
}
interface PlatformMedia$1 extends PlatformMediaMediaOneOf$1 {
    image?: Image$4;
    video?: VideoV2$1;
}
/** @oneof */
interface PlatformMediaMediaOneOf$1 {
    image?: Image$4;
    video?: VideoV2$1;
}
interface Image$4 {
    /** WixMedia image ID. */
    id?: string;
    /** Image URL. */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoV2$1 {
    /** WixMedia ID. */
    id?: string;
    /**
     * Available resolutions for the video, starting with the optimal resolution.
     * @readonly
     */
    resolutions?: VideoResolution$1[];
    /**
     * Video filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoResolution$1 {
    /** Video URL. */
    url?: string;
    /** Video height. */
    height?: number;
    /** Video width. */
    width?: number;
    /** Video format for example, mp4, hls. */
    format?: string;
}
interface PreorderInfo$7 {
    /** Whether the item is available for preorder. */
    enabled?: boolean;
    /** A message the buyer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /** Number of products that can be preordered after stock reaches zero. */
    limit?: number | null;
}
interface GetStoreVariantRequest$1 {
    /** Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen. For example, `{productId}-{variantId}`. */
    id: string;
}
interface GetStoreVariantResponse$1 {
    /** The requested store variant. */
    variant?: StoreVariant$1;
}
interface NumericPropertyRangeNonNullableFields$1 {
    minValue: number;
    maxValue: number;
}
interface StockNonNullableFields$1 {
    trackInventory: boolean;
    inStock: boolean;
    inventoryStatus: InventoryStatus$3;
}
interface FormattedPriceNonNullableFields$1 {
    price: string;
    discountedPrice: string;
}
interface PriceDataNonNullableFields$1 {
    currency: string;
    discountedPrice: number;
    formatted?: FormattedPriceNonNullableFields$1;
}
interface CostAndProfitDataNonNullableFields$1 {
    formattedItemCost: string;
    profit: number;
    formattedProfit: string;
    profitMargin: number;
}
interface PricePerUnitDataNonNullableFields$1 {
    totalQuantity: number;
    totalMeasurementUnit: MeasurementUnit$3;
    baseQuantity: number;
    baseMeasurementUnit: MeasurementUnit$3;
}
interface AdditionalInfoSectionNonNullableFields$1 {
    title: string;
    description: string;
}
interface RibbonNonNullableFields$3 {
    text: string;
}
interface MediaItemUrlAndSizeNonNullableFields$1 {
    url: string;
    width: number;
    height: number;
}
interface MediaItemVideoNonNullableFields$1 {
    files: MediaItemUrlAndSizeNonNullableFields$1[];
    stillFrameMediaId: string;
}
interface MediaItemNonNullableFields$1 {
    image?: MediaItemUrlAndSizeNonNullableFields$1;
    video?: MediaItemVideoNonNullableFields$1;
    thumbnail?: MediaItemUrlAndSizeNonNullableFields$1;
    mediaType: MediaItemType$1;
    title: string;
    id: string;
}
interface MediaNonNullableFields$3 {
    mainMedia?: MediaItemNonNullableFields$1;
    items: MediaItemNonNullableFields$1[];
}
interface CustomTextFieldNonNullableFields$1 {
    title: string;
    maxLength: number;
    mandatory: boolean;
}
interface ChoiceNonNullableFields$3 {
    value: string;
    description: string;
    media?: MediaNonNullableFields$3;
    inStock: boolean;
    visible: boolean;
}
interface ProductOptionNonNullableFields$1 {
    optionType: OptionType$1;
    name: string;
    choices: ChoiceNonNullableFields$3[];
}
interface PageUrlNonNullableFields$1 {
    base: string;
    path: string;
}
interface DiscountNonNullableFields$3 {
    type: DiscountType$5;
    value: number;
}
interface VariantDataWithNoStockNonNullableFields$1 {
    priceData?: PriceDataNonNullableFields$1;
    convertedPriceData?: PriceDataNonNullableFields$1;
    costAndProfitData?: CostAndProfitDataNonNullableFields$1;
    weight: number;
    sku: string;
    visible: boolean;
}
interface VariantStockNonNullableFields$1 {
    trackQuantity: boolean;
    inStock: boolean;
}
interface VariantNonNullableFields$3 {
    id: string;
    variant?: VariantDataWithNoStockNonNullableFields$1;
    stock?: VariantStockNonNullableFields$1;
}
interface TagNonNullableFields$3 {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields$3 {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields$5 {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields$3[];
}
interface SeoSchemaNonNullableFields$3 {
    tags: TagNonNullableFields$3[];
    settings?: SettingsNonNullableFields$5;
}
interface SecuredMediaNonNullableFields$3 {
    id: string;
    fileName: string;
    fileType: FileType$3;
}
interface ProductNonNullableFields$5 {
    id: string;
    slug: string;
    productType: ProductType$3;
    weightRange?: NumericPropertyRangeNonNullableFields$1;
    stock?: StockNonNullableFields$1;
    price?: PriceDataNonNullableFields$1;
    priceData?: PriceDataNonNullableFields$1;
    convertedPriceData?: PriceDataNonNullableFields$1;
    priceRange?: NumericPropertyRangeNonNullableFields$1;
    costAndProfitData?: CostAndProfitDataNonNullableFields$1;
    costRange?: NumericPropertyRangeNonNullableFields$1;
    pricePerUnitData?: PricePerUnitDataNonNullableFields$1;
    additionalInfoSections: AdditionalInfoSectionNonNullableFields$1[];
    ribbons: RibbonNonNullableFields$3[];
    media?: MediaNonNullableFields$3;
    customTextFields: CustomTextFieldNonNullableFields$1[];
    productOptions: ProductOptionNonNullableFields$1[];
    productPageUrl?: PageUrlNonNullableFields$1;
    numericId: string;
    inventoryItemId: string;
    discount?: DiscountNonNullableFields$3;
    collectionIds: string[];
    variants: VariantNonNullableFields$3[];
    seoData?: SeoSchemaNonNullableFields$3;
    exportProductId: string;
    digitalFile?: SecuredMediaNonNullableFields$3;
}
interface CreateProductResponseNonNullableFields$3 {
    product?: ProductNonNullableFields$5;
}
interface UpdateProductResponseNonNullableFields$3 {
    product?: ProductNonNullableFields$5;
}
interface UpdateVariantsResponseNonNullableFields$1 {
    variants: VariantNonNullableFields$3[];
}
interface CollectionNonNullableFields$1 {
    media?: MediaNonNullableFields$3;
    numberOfProducts: number;
    seoSchema?: SeoSchemaNonNullableFields$3;
}
interface CreateCollectionResponseNonNullableFields$1 {
    collection?: CollectionNonNullableFields$1;
}
interface UpdateCollectionResponseNonNullableFields$1 {
    collection?: CollectionNonNullableFields$1;
}
interface ApplicationErrorNonNullableFields$d {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$b {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$d;
}
interface BulkProductResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$b;
}
interface BulkActionMetadataNonNullableFields$b {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkUpdateProductsResponseNonNullableFields$3 {
    results: BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$b;
}
interface BulkAdjustProductPropertiesResponseNonNullableFields$1 {
    results: BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$b;
}
interface QueryProductsPlatformizedResponseNonNullableFields$1 {
    products: ProductNonNullableFields$5[];
}
interface GetProductResponseNonNullableFields$1 {
    product?: ProductNonNullableFields$5;
}
interface GetCollectionBySlugResponseNonNullableFields$1 {
    collection?: CollectionNonNullableFields$1;
}
interface VariantDataNonNullableFields$1 {
    price?: PriceDataNonNullableFields$1;
    convertedPriceData?: PriceDataNonNullableFields$1;
    sku: string;
    inStock: boolean;
    visible: boolean;
    variantId: string;
}
interface ProductOptionsAvailabilityResponseNonNullableFields$1 {
    selectedVariant?: VariantDataNonNullableFields$1;
    media?: MediaNonNullableFields$3;
    productOptions: ProductOptionNonNullableFields$1[];
    availableForPurchase: boolean;
    managedProduct: boolean;
}
interface PagingMetadataNonNullableFields$5 {
    items: number;
    offset: number;
}
interface QueryProductVariantsResponseNonNullableFields$1 {
    variants: VariantNonNullableFields$3[];
    metadata?: PagingMetadataNonNullableFields$5;
    totalResults: number;
}
interface ImageNonNullableFields$5 {
    id: string;
    url: string;
    height: number;
    width: number;
}
interface VideoResolutionNonNullableFields$1 {
    url: string;
    height: number;
    width: number;
    poster?: ImageNonNullableFields$5;
    format: string;
}
interface VideoV2NonNullableFields$1 {
    id: string;
    url: string;
    resolutions: VideoResolutionNonNullableFields$1[];
    posters: ImageNonNullableFields$5[];
}
interface PlatformMediaNonNullableFields$1 {
    image?: ImageNonNullableFields$5;
    video?: VideoV2NonNullableFields$1;
}
interface PreorderInfoNonNullableFields$3 {
    enabled: boolean;
}
interface StoreVariantNonNullableFields$1 {
    id: string;
    variantId: string;
    productId: string;
    variantName: string;
    productName: string;
    managedVariant: boolean;
    sku: string;
    stock?: VariantStockNonNullableFields$1;
    collectionIds: string[];
    media?: PlatformMediaNonNullableFields$1;
    preorderInfo?: PreorderInfoNonNullableFields$3;
}
interface QueryStoreVariantsResponseNonNullableFields$1 {
    variants: StoreVariantNonNullableFields$1[];
}
interface GetStoreVariantResponseNonNullableFields$1 {
    variant?: StoreVariantNonNullableFields$1;
}

interface Product$4 {
    /**
     * Product ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string;
    /**
     * Product name.
     *
     * Min: 1 character
     * Max: 80 characters
     */
    name?: string | null;
    /** A friendly URL name (generated automatically by the catalog when a product is created), can be updated. */
    slug?: string;
    /** Whether the product is visible to site visitors. */
    visible?: boolean | null;
    /** Currently, only creating physical products ( `"productType": "physical"` ) is supported via the API. */
    productType?: ProductType$2;
    /** Product description. */
    description?: string | null;
    /** Stock keeping unit. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, SKUs will be set per variant, and this field will be empty. */
    sku?: string | null;
    /** Product weight. If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled, weight will be set per variant, and this field will be empty. */
    weight?: number | null;
    /**
     * Product weight range. The minimum and maximum weights of all the variants.
     * @readonly
     */
    weightRange?: NumericPropertyRange;
    /**
     * Product inventory status (in future this will be writable via Inventory API).
     * @readonly
     */
    stock?: Stock;
    /**
     * Deprecated (use `priceData` instead).
     * @readonly
     * @deprecated
     */
    price?: PriceData;
    /** Price data. */
    priceData?: PriceData;
    /**
     * Price data, converted to the currency specified in request header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /**
     * Product price range. The minimum and maximum prices of all the variants.
     * @readonly
     */
    priceRange?: NumericPropertyRange;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData;
    /**
     * Product cost range. The minimum and maximum costs of all the variants.
     * @readonly
     */
    costRange?: NumericPropertyRange;
    /** Price per unit data. */
    pricePerUnitData?: PricePerUnitData;
    /** Additional text that the store owner can assign to the product (e.g. shipping details, refund policy, etc.). */
    additionalInfoSections?: AdditionalInfoSection[];
    /**
     * Deprecated (use `ribbon` instead).
     * @readonly
     * @deprecated
     */
    ribbons?: Ribbon$4[];
    /**
     * Media items (images, videos etc) associated with this product (writable via [Add Product Media](https://dev.wix.com/api/rest/wix-stores/catalog/products/add-product-media) endpoint).
     * @readonly
     */
    media?: Media$4;
    /**
     * Text box for the customer to add a message to their order (e.g., customization request). Currently writable only from the UI.
     * @readonly
     */
    customTextFields?: CustomTextField[];
    /** Whether variants are being managed for this product - enables unique SKU, price and weight per variant. Also affects inventory data. Once set to `true`, can be reset to `false` only if no variants exist. You cannot set `manageVariants` to `true` if more than 300 variants are defined. */
    manageVariants?: boolean | null;
    /** Options for this product. */
    productOptions?: ProductOption[];
    /**
     * Product page URL for this product (generated automatically by the server).
     * @readonly
     */
    productPageUrl?: PageUrl;
    /**
     * Product’s unique numeric ID (assigned in ascending order).
     * Primarily used for sorting and filtering when crawling all products.
     * @readonly
     */
    numericId?: string;
    /**
     * Inventory item ID - ID referencing the inventory system.
     * @readonly
     */
    inventoryItemId?: string;
    /** Discount deducted from the product's original price. */
    discount?: Discount$2;
    /**
     * A list of all collection IDs that this product is included in (writable via the Catalog > Collection APIs).
     * @readonly
     */
    collectionIds?: string[];
    /**
     * Product variants, will be provided if the the request was sent with the `includeVariants: true`.
     *
     * Max: 1,000 variants
     * @readonly
     */
    variants?: Variant$2[];
    /**
     * Date and time the product was last updated.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Date and time the product was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /** Custom SEO data for the product. */
    seoData?: SeoSchema$2;
    /** Product ribbon. Used to highlight relevant information about a product. For example, "Sale", "New Arrival", "Sold Out". */
    ribbon?: string | null;
    /** Product brand. Including a brand name can help improve site and product [visibility on search engines](https://support.wix.com/en/article/adding-brand-names-to-boost-product-page-seo-in-wix-stores). */
    brand?: string | null;
}
declare enum ProductType$2 {
    unspecified_product_type = "unspecified_product_type",
    physical = "physical",
    digital = "digital"
}
interface NumericPropertyRange {
    /** Minimum value. */
    minValue?: number;
    /** Maximum value. */
    maxValue?: number;
}
interface Stock {
    /** Whether inventory is being tracked */
    trackInventory?: boolean;
    /** Quantity currently left in inventory */
    quantity?: number | null;
    /**
     * Whether the product is currently in stock (relevant only when tracking manually)
     * Deprecated (use `inventoryStatus` instead)
     * @deprecated
     */
    inStock?: boolean;
    /**
     * The current status of the inventory
     * + `IN_STOCK` - In stock
     * + `OUT_OF_STOCK` - Not in stock
     * + `PARTIALLY_OUT_OF_STOCK` - Some of the variants are not in stock
     */
    inventoryStatus?: InventoryStatus$2;
}
declare enum InventoryStatus$2 {
    IN_STOCK = "IN_STOCK",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    PARTIALLY_OUT_OF_STOCK = "PARTIALLY_OUT_OF_STOCK"
}
interface PriceData {
    /**
     * Product price currency
     * @readonly
     */
    currency?: string;
    /** Product price */
    price?: number | null;
    /**
     * Discounted product price (if no discounted price is set, the product price is returned)
     * @readonly
     */
    discountedPrice?: number;
    /**
     * The product price and discounted price, formatted with the currency
     * @readonly
     */
    formatted?: FormattedPrice;
    /**
     * Price per unit
     * @readonly
     */
    pricePerUnit?: number | null;
}
interface FormattedPrice {
    /** Product price formatted with the currency */
    price?: string;
    /** Discounted product price formatted with the currency (if no discounted price is set, the product formatted price is returned) */
    discountedPrice?: string;
    /**
     * Price per unit
     * @readonly
     */
    pricePerUnit?: string | null;
}
interface CostAndProfitData {
    /** Item cost. */
    itemCost?: number | null;
    /**
     * Item cost formatted with currency symbol.
     * @readonly
     */
    formattedItemCost?: string;
    /**
     * Profit. Calculated by reducing `cost` from `discounted_price`.
     * @readonly
     */
    profit?: number;
    /**
     * Profit formatted with currency symbol.
     * @readonly
     */
    formattedProfit?: string;
    /**
     * Profit Margin. Calculated by dividing `profit` by `discounted_price`.
     * The result is rounded to 4 decimal places.
     * @readonly
     */
    profitMargin?: number;
}
interface PricePerUnitData {
    /** Total quantity */
    totalQuantity?: number;
    /** Total measurement unit */
    totalMeasurementUnit?: MeasurementUnit$2;
    /** Base quantity */
    baseQuantity?: number;
    /** Base measurement unit */
    baseMeasurementUnit?: MeasurementUnit$2;
}
declare enum MeasurementUnit$2 {
    UNSPECIFIED = "UNSPECIFIED",
    ML = "ML",
    CL = "CL",
    L = "L",
    CBM = "CBM",
    MG = "MG",
    G = "G",
    KG = "KG",
    MM = "MM",
    CM = "CM",
    M = "M",
    SQM = "SQM",
    OZ = "OZ",
    LB = "LB",
    FLOZ = "FLOZ",
    PT = "PT",
    QT = "QT",
    GAL = "GAL",
    IN = "IN",
    FT = "FT",
    YD = "YD",
    SQFT = "SQFT"
}
interface AdditionalInfoSection {
    /** Product info section title */
    title?: string;
    /** Product info section description */
    description?: string;
}
interface Ribbon$4 {
    /** Ribbon text */
    text?: string;
}
interface Media$4 {
    /** Primary media (image, video etc) associated with this product. */
    mainMedia?: MediaItem;
    /** Media (images, videos etc) associated with this product. */
    items?: MediaItem[];
}
interface MediaItem extends MediaItemItemOneOf {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize;
    /** Video data (URL, size). */
    video?: MediaItemVideo;
    /** Media item thumbnail details. */
    thumbnail?: MediaItemUrlAndSize;
    /** Media item type (image, video, etc.). */
    mediaType?: MediaItemType;
    /** Media item title. */
    title?: string;
    /** Media ID (for example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`). */
    _id?: string;
}
/** @oneof */
interface MediaItemItemOneOf {
    /** Image data (URL, size). */
    image?: MediaItemUrlAndSize;
    /** Video data (URL, size). */
    video?: MediaItemVideo;
}
interface MediaItemUrlAndSize {
    /** Media item URL. */
    url?: string;
    /** Media item width. */
    width?: number;
    /** Media item height. */
    height?: number;
    /** Media format (mp4, png, etc.). */
    format?: string | null;
    /** Alt text. This text will be shown in case the image is not available. */
    altText?: string | null;
}
declare enum MediaItemType {
    unspecified_media_item_type = "unspecified_media_item_type",
    image = "image",
    video = "video",
    audio = "audio",
    document = "document",
    zip = "zip"
}
interface MediaItemVideo {
    /** Data (URL, size) about each resolution for which this video is available. */
    files?: MediaItemUrlAndSize[];
    /** ID of an image taken from the video. Used primarily for Wix Search indexing. For example, `"nsplsh_306d666a123a4a74306459~mv2_d_4517_2992_s_4_2.jpg"`. */
    stillFrameMediaId?: string;
}
interface CustomTextField {
    /** Text box title */
    title?: string;
    /** Text box input max length */
    maxLength?: number;
    /** Whether this text box is mandatory */
    mandatory?: boolean;
}
interface ProductOption {
    /**
     * Option type - color or other(drop down)
     * @readonly
     */
    optionType?: OptionType;
    /** Option name. */
    name?: string;
    /** Choices available for this option. */
    choices?: Choice$2[];
}
declare enum OptionType {
    unspecified_option_type = "unspecified_option_type",
    drop_down = "drop_down",
    color = "color"
}
interface Choice$2 {
    /** Choice value. */
    value?: string;
    /** Choice description. */
    description?: string;
    /**
     * Media items (images, videos) associated with this choice
     * @readonly
     */
    media?: Media$4;
    /**
     * Based on the customer’s choices, which (if any) variants that include the selected choices are in stock
     * @readonly
     */
    inStock?: boolean;
    /**
     * Based on the customer’s choices, which (if any) variants that include the selected choices are visible
     * @readonly
     */
    visible?: boolean;
}
interface PageUrl {
    /** Base URL. For premium sites, this is the domain. For free sites, this is the site URL (e.g mysite.wixsite.com/mysite). */
    base?: string;
    /** Path to the product page - e.g /product-page/a-product. */
    path?: string;
}
interface Discount$2 {
    /**
     * Discount type:
     * + `"AMOUNT"`
     * + `"PERCENT"`
     */
    type?: DiscountType$4;
    /** Discount value */
    value?: number;
}
declare enum DiscountType$4 {
    UNDEFINED = "UNDEFINED",
    /** No discount */
    NONE = "NONE",
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface Variant$2 {
    /** Requested Variant ID */
    _id?: string;
    /** Specific choices within a selection, as option-choice key-value pairs */
    choices?: Record<string, string>;
    variant?: VariantDataWithNoStock;
    /**
     * Variant inventory status.
     * @readonly
     */
    stock?: VariantStock;
}
interface VariantDataWithNoStock {
    /** Variant price. */
    priceData?: PriceData;
    /**
     * Variant price data, converted to currency requested in header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /** Cost and profit data. */
    costAndProfitData?: CostAndProfitData;
    /** Variant weight. */
    weight?: number;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Whether the variant is visible to customers. */
    visible?: boolean;
}
interface VariantStock {
    /** Whether inventory is being tracked. */
    trackQuantity?: boolean;
    /** Quantity currently left in inventory. */
    quantity?: number | null;
    /** Whether the product is currently in stock (relevant only when tracking manually). */
    inStock?: boolean;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema$2 {
    /** SEO tag information. */
    tags?: Tag$2[];
    /** SEO general settings. */
    settings?: Settings$4;
}
interface Keyword$2 {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /** The source that added the keyword terms to the SEO settings. */
    origin?: string | null;
}
interface Tag$2 {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
     * For example: `{'name': 'description', 'content': 'the description itself'}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings$4 {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /** User-selected keyword terms for a specific page. */
    keywords?: Keyword$2[];
}
declare enum FileType$2 {
    UNSPECIFIED = "UNSPECIFIED",
    SECURE_PICTURE = "SECURE_PICTURE",
    SECURE_VIDEO = "SECURE_VIDEO",
    SECURE_DOCUMENT = "SECURE_DOCUMENT",
    SECURE_MUSIC = "SECURE_MUSIC",
    SECURE_ARCHIVE = "SECURE_ARCHIVE"
}
interface CreateProductRequest$2 {
    /** Product information. */
    product?: Product$4;
}
interface CreateProductResponse$2 {
    product?: Product$4;
}
interface UpdateProductRequest$2 {
    product: Product$4;
}
interface UpdateProductResponse$2 {
    product?: Product$4;
}
interface DeleteProductRequest {
    /** ID of the product to delete. */
    _id: string;
}
interface DeleteProductResponse {
}
interface UpdateVariantsRequest {
    /** ID of the product with managed variants. */
    _id: string;
    /** Variant info to update. */
    variants?: VariantOverride[];
}
interface VariantOverride {
    /** The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice). You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (Not relevant when passing variant IDs) */
    choices?: Record<string, string>;
    /**
     * List of variant IDs
     * (Not relevant when passing choices)
     */
    variantIds?: string[];
    /** Variant price */
    price?: number | null;
    /** Variant cost of goods */
    cost?: number | null;
    /** Variant weight */
    weight?: number | null;
    /** Variant SKU (stock keeping unit) */
    sku?: string | null;
    /** Whether the variant is visible to  customers */
    visible?: boolean | null;
}
interface UpdateVariantsResponse {
    /** List of the product's variants. */
    variants?: Variant$2[];
}
interface ResetAllVariantDataRequest {
    /** Product ID. */
    _id: string;
}
interface ResetAllVariantDataResponse {
}
interface AddProductsToCollectionRequest {
    /** Collection ID. */
    _id: string;
    /** IDs of the products to add to the collection, separated by commas. */
    productIds?: string[];
}
interface AddProductsToCollectionResponse {
}
interface RemoveProductsFromCollectionRequest {
    /** ID of the collection from which to remove products. */
    _id: string;
    /** IDs of the products to remove from the collection. */
    productIds: string[];
}
interface RemoveProductsFromCollectionResponse {
}
interface AddProductMediaRequest {
    /** Product ID. */
    _id: string;
    /** Sources of media items already uploaded to the Wix site. */
    media?: MediaDataForWrite[];
}
interface MediaDataForWrite extends MediaDataForWriteMediaSourceOneOf {
    /** Media ID. */
    mediaId?: string;
    /** Media external URL (for new media items). */
    url?: string;
    /** Assign this media item to a specific product choice. Note that you may set media items for choices under only one option (e.g., if Colors blue, green, and red have media items, Sizes S, M, and L can't have media items assigned to them). You may clear existing media from choices with the [Remove Product Media From Choices](#removeproductmediafromchoices). */
    choice?: OptionAndChoice;
}
/** @oneof */
interface MediaDataForWriteMediaSourceOneOf {
    /** Media ID. */
    mediaId?: string;
    /** Media external URL (for new media items). */
    url?: string;
}
interface OptionAndChoice {
    /** Option to add the media to. */
    option?: string;
    /** Choice to add the media to. */
    choice?: string;
}
interface AddProductMediaResponse {
}
interface RemoveProductMediaRequest {
    /** Product ID. */
    _id: string;
    /** List of media IDs to remove. Pass an empty array to delete all media items for the product. */
    mediaIds?: string[];
}
interface RemoveProductMediaResponse {
}
interface AddProductMediaToChoicesRequest {
    /** Product ID. */
    _id: string;
    /** Product media items and the choices to add the media to. */
    media?: MediaAssignmentToChoice[];
}
interface MediaAssignmentToChoice {
    /** Option name. */
    option?: string;
    /** Choice name. */
    choice?: string;
    /** Media IDs (available via the Query Product endpoint). */
    mediaIds?: string[];
}
interface AddProductMediaToChoicesResponse {
}
interface RemoveProductMediaFromChoicesRequest {
    /** Product ID from whose choices to remove media items. */
    _id: string;
    /** Media to remove from choices. If an empty array is passed, all media will be removed from all choices for the given product. */
    media?: MediaAssignmentToChoice[];
}
interface RemoveProductMediaFromChoicesResponse {
}
interface DeleteProductOptionsRequest {
    /** ID of the product with options to delete. */
    _id: string;
}
interface DeleteProductOptionsResponse {
}
interface RemoveProductBrandRequest {
    /** Product ID. */
    _id: string;
}
interface RemoveProductBrandResponse {
}
interface CreateCollectionRequest {
    /** Collection info. */
    collection: Collection;
}
interface Collection {
    /**
     * Collection ID (generated automatically by the catalog).
     * @readonly
     */
    _id?: string | null;
    /** Collection name. */
    name?: string | null;
    /**
     * Media items (images, videos etc) associated with this collection. Read only.
     * @readonly
     */
    media?: Media$4;
    /**
     * Number of products in the collection. Read only.
     * @readonly
     */
    numberOfProducts?: number;
    /** Collection description. */
    description?: string | null;
    /** Collection slug. */
    slug?: string | null;
    /** Collection visibility. Only impacts dynamic pages, no impact on static pages. Default: `true`. */
    visible?: boolean | null;
}
interface CreateCollectionResponse {
    /** Collection. */
    collection?: Collection;
}
interface UpdateCollectionRequest {
    /** Collection info. */
    collection: Collection;
}
interface UpdateCollectionResponse {
    /** Updated collection. */
    collection?: Collection;
}
interface DeleteCollectionRequest {
    /** ID of the collection to delete. */
    _id: string;
}
interface DeleteCollectionResponse {
}
interface RemoveProductRibbonRequest {
    /** Product ID. */
    _id: string;
}
interface RemoveProductRibbonResponse {
}
interface BulkUpdateProductsRequest$2 {
    /** Product IDs. */
    ids: string[];
    /** Field to update. */
    set?: SetValue;
}
interface SetValue extends SetValueValueOneOf {
    /**
     * Set product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variant prices will be calculated according to the set product price.
     * If variant price is negative after setting new price, the update will fail.
     */
    price?: number;
    /**
     * Set product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be set per variant.
     */
    cost?: number;
    /**
     * Set product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be set per variant.
     */
    weight?: number;
    /** Set product ribbon. Pass empty string to remove existing ribbon. */
    ribbon?: string;
    /** Set product brand. Pass empty string to remove existing brand. */
    brand?: string;
}
/** @oneof */
interface SetValueValueOneOf {
    /**
     * Set product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variant prices will be calculated according to the set product price.
     * If variant price is negative after setting new price, the update will fail.
     */
    price?: number;
    /**
     * Set product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be set per variant.
     */
    cost?: number;
    /**
     * Set product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be set per variant.
     */
    weight?: number;
    /** Set product ribbon. Pass empty string to remove existing ribbon. */
    ribbon?: string;
    /** Set product brand. Pass empty string to remove existing brand. */
    brand?: string;
}
interface BulkUpdateProductsResponse$2 {
    /** Bulk action results. */
    results?: BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$a;
}
interface BulkProductResult {
    /** Item metadata. */
    itemMetadata?: ItemMetadata$a;
}
interface ItemMetadata$a {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$c;
}
interface ApplicationError$c {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$a {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkAdjustProductPropertiesRequest {
    /** Product IDs. */
    ids: string[];
    /** Numerical property to adjust. */
    adjust?: AdjustValue;
}
interface AdjustValue extends AdjustValueValueOneOf {
    /**
     * Adjust product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variants prices will be calculated according to the adjusted price.
     * If variant price is negative after the adjustment, the update will fail.
     */
    price?: PropertyAdjustmentData;
    /**
     * Adjust product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be adjusted per variant.
     */
    cost?: PropertyAdjustmentData;
    /**
     * Adjust product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be adjusted per variant.
     */
    weight?: PropertyAdjustmentData;
}
/** @oneof */
interface AdjustValueValueOneOf {
    /**
     * Adjust product price.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * variants prices will be calculated according to the adjusted price.
     * If variant price is negative after the adjustment, the update will fail.
     */
    price?: PropertyAdjustmentData;
    /**
     * Adjust product cost of goods.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * cost of goods will be adjusted per variant.
     */
    cost?: PropertyAdjustmentData;
    /**
     * Adjust product weight.
     * If [variant management](https://support.wix.com/en/article/wix-stores-adding-and-customizing-product-options#setting-different-prices-for-variants) is enabled,
     * weight will be adjusted per variant.
     */
    weight?: PropertyAdjustmentData;
}
interface PropertyAdjustmentData extends PropertyAdjustmentDataByOneOf {
    /** Adjust by percentage. */
    percentage?: PercentageData;
    /** Adjust by amount. */
    amount?: number;
}
/** @oneof */
interface PropertyAdjustmentDataByOneOf {
    /** Adjust by percentage. */
    percentage?: PercentageData;
    /** Adjust by amount. */
    amount?: number;
}
interface PercentageData {
    /**
     * If `true`, result will be rounded to the nearest whole number.
     * If `false`, result will be rounded to 2 places after the decimal point.
     */
    roundToInt?: boolean;
    /**
     * Percentage value, as a whole number (integer) between `-100` and `1000`.
     *
     * For example:
     * + Pass `100` to increase value by 100% (multiply original value by 2).
     * + Pass `1000` to increase value by 1000% (multiply original value by 10).
     * + Pass `-50` to decrease value by 50% (original value is halved).
     */
    rate?: number;
}
interface BulkAdjustProductPropertiesResponse {
    /** Bulk action results. */
    results?: BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$a;
}
interface Paging$4 {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface PagingMetadata$4 {
    /** Amount of items to load per page */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number;
}
interface QueryProductsPlatformizedRequest {
    query?: PlatformQuery;
}
interface PlatformQuery extends PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$c;
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Sorting options. For example, `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]`. */
    sort?: Sorting$c[];
}
/** @oneof */
interface PlatformQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: PlatformPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: CursorPaging$c;
}
interface Sorting$c {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$c;
}
declare enum SortOrder$c {
    ASC = "ASC",
    DESC = "DESC"
}
interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface CursorPaging$c {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryProductsPlatformizedResponse {
    products?: Product$4[];
    metadata?: PlatformPagingMetadata;
}
interface PlatformPagingMetadata {
    /** The number of items returned in this response. */
    count?: number | null;
    /** The offset which was requested. Returned if offset paging was used. */
    offset?: number | null;
    /** The total number of items that match the query. Returned if offset paging was used. */
    total?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$c;
}
interface Cursors$c {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface GetProductRequest {
    /** Requested product ID. */
    _id: string;
    /** Whether merchant specific data, such as cost and profit data, should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface GetProductResponse {
    /** Requested product data. */
    product?: Product$4;
}
interface GetCollectionBySlugRequest {
    /** Slug of the collection to retrieve. */
    slug: string;
}
interface GetCollectionBySlugResponse {
    /** The requested collection. */
    collection?: Collection;
}
interface ProductOptionsAvailabilityRequest {
    /** Requested product ID. */
    _id: string;
    /** Array containing the selected options. For example, `["color": "Blue", "size": "Large"]`. */
    options?: Record<string, string>;
}
interface ProductOptionsAvailabilityResponse {
    /** Variant information, given that all the choices were provided. */
    selectedVariant?: VariantData;
    /** Information about media items (images, videos, etc.) associated with this choice. */
    media?: Media$4;
    /** Options information (color, size, etc.) for this product, with the inventory and visibility fields updated based on the provided choices. */
    productOptions?: ProductOption[];
    /** Whether all the selected choices result in a visible, in-stock variant. */
    availableForPurchase?: boolean;
}
interface VariantData {
    /** Variant price. */
    price?: PriceData;
    /**
     * Variant price data converted to currency provided in header.
     * @readonly
     */
    convertedPriceData?: PriceData;
    /** Variant weight. */
    weight?: number | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Quantity currently in inventory (relevant only when tracking by inventory). */
    quantity?: number | null;
    /** Whether the product is currently in stock (relevant only when tracking manually). */
    inStock?: boolean;
    /** Whether the variant is visible to customers. */
    visible?: boolean;
}
interface QueryProductVariantsRequest {
    /** Requested product ID. */
    _id: string;
    /**
     * The specific choices available or chosen from within a selection (e.g., choosing the red Selection triggers the red Choice).
     * You may specify all the relevant choices for a specific variant, or only some of the options, which will return all corresponding variants (not relevant when passing variant IDs).
     */
    choices?: Record<string, string>;
    /** List of variant IDs (not relevant when passing choices). */
    variantIds?: string[];
    paging?: Paging$4;
    /** Whether merchant specific data should be included in the response. Requires permissions to manage products. */
    includeMerchantSpecificData?: boolean;
}
interface QueryProductVariantsResponse {
    /** List of variants based on the specified filters and sorting. */
    variants?: Variant$2[];
    metadata?: PagingMetadata$4;
    totalResults?: number;
}
interface QueryStoreVariantsRequest {
    /** Query options. */
    query?: PlatformQuery;
}
interface QueryStoreVariantsResponse {
    /** List of variants based on the specified filters and sorting. */
    variants?: StoreVariant[];
    /** Details on the paged set of results returned. */
    metadata?: PlatformPagingMetadata;
}
interface StoreVariant {
    /** Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen: {productId}.{variantId}. */
    _id?: string;
    /** Variant ID. */
    variantId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant name. */
    variantName?: string;
    /** Product name. */
    productName?: string;
    /** Whether the variant is managed or represents a product. */
    managedVariant?: boolean;
    /** Variant SKU (stock keeping unit). */
    sku?: string;
    /** Variant inventory status. */
    stock?: VariantStock;
    /** The selected options of this variant. For example, `{"Color": "Blue", "Size": "Large"}`. */
    choices?: Record<string, string>;
    /** Collections that include this variant. */
    collectionIds?: string[];
    /**
     * Media items (images, videos) associated with this variant.
     * @readonly
     */
    media?: PlatformMedia;
    /** Preorder information. */
    preorderInfo?: PreorderInfo$6;
}
interface PlatformMedia extends PlatformMediaMediaOneOf {
    image?: string;
    video?: string;
}
/** @oneof */
interface PlatformMediaMediaOneOf {
    image?: string;
    video?: string;
}
interface PreorderInfo$6 {
    /** Whether the item is available for preorder. */
    enabled?: boolean;
    /** A message the buyer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /** Number of products that can be preordered after stock reaches zero. */
    limit?: number | null;
}
interface GetStoreVariantRequest {
    /** Store variant ID. Comprised of the `productId` and the `variantId`, separated by a hyphen. For example, `{productId}-{variantId}`. */
    _id: string;
}
interface GetStoreVariantResponse {
    /** The requested store variant. */
    variant?: StoreVariant;
}
interface NumericPropertyRangeNonNullableFields {
    minValue: number;
    maxValue: number;
}
interface StockNonNullableFields {
    trackInventory: boolean;
    inStock: boolean;
    inventoryStatus: InventoryStatus$2;
}
interface FormattedPriceNonNullableFields {
    price: string;
    discountedPrice: string;
}
interface PriceDataNonNullableFields {
    currency: string;
    discountedPrice: number;
    formatted?: FormattedPriceNonNullableFields;
}
interface CostAndProfitDataNonNullableFields {
    formattedItemCost: string;
    profit: number;
    formattedProfit: string;
    profitMargin: number;
}
interface PricePerUnitDataNonNullableFields {
    totalQuantity: number;
    totalMeasurementUnit: MeasurementUnit$2;
    baseQuantity: number;
    baseMeasurementUnit: MeasurementUnit$2;
}
interface AdditionalInfoSectionNonNullableFields {
    title: string;
    description: string;
}
interface RibbonNonNullableFields$2 {
    text: string;
}
interface MediaItemUrlAndSizeNonNullableFields {
    url: string;
    width: number;
    height: number;
}
interface MediaItemVideoNonNullableFields {
    files: MediaItemUrlAndSizeNonNullableFields[];
    stillFrameMediaId: string;
}
interface MediaItemNonNullableFields {
    image?: MediaItemUrlAndSizeNonNullableFields;
    video?: MediaItemVideoNonNullableFields;
    thumbnail?: MediaItemUrlAndSizeNonNullableFields;
    mediaType: MediaItemType;
    title: string;
    _id: string;
}
interface MediaNonNullableFields$2 {
    mainMedia?: MediaItemNonNullableFields;
    items: MediaItemNonNullableFields[];
}
interface CustomTextFieldNonNullableFields {
    title: string;
    maxLength: number;
    mandatory: boolean;
}
interface ChoiceNonNullableFields$2 {
    value: string;
    description: string;
    media?: MediaNonNullableFields$2;
    inStock: boolean;
    visible: boolean;
}
interface ProductOptionNonNullableFields {
    optionType: OptionType;
    name: string;
    choices: ChoiceNonNullableFields$2[];
}
interface PageUrlNonNullableFields {
    base: string;
    path: string;
}
interface DiscountNonNullableFields$2 {
    type: DiscountType$4;
    value: number;
}
interface VariantDataWithNoStockNonNullableFields {
    priceData?: PriceDataNonNullableFields;
    convertedPriceData?: PriceDataNonNullableFields;
    costAndProfitData?: CostAndProfitDataNonNullableFields;
    weight: number;
    sku: string;
    visible: boolean;
}
interface VariantStockNonNullableFields {
    trackQuantity: boolean;
    inStock: boolean;
}
interface VariantNonNullableFields$2 {
    _id: string;
    variant?: VariantDataWithNoStockNonNullableFields;
    stock?: VariantStockNonNullableFields;
}
interface TagNonNullableFields$2 {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields$2 {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields$4 {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields$2[];
}
interface SeoSchemaNonNullableFields$2 {
    tags: TagNonNullableFields$2[];
    settings?: SettingsNonNullableFields$4;
}
interface SecuredMediaNonNullableFields$2 {
    _id: string;
    fileName: string;
    fileType: FileType$2;
}
interface ProductNonNullableFields$4 {
    _id: string;
    slug: string;
    productType: ProductType$2;
    weightRange?: NumericPropertyRangeNonNullableFields;
    stock?: StockNonNullableFields;
    price?: PriceDataNonNullableFields;
    priceData?: PriceDataNonNullableFields;
    convertedPriceData?: PriceDataNonNullableFields;
    priceRange?: NumericPropertyRangeNonNullableFields;
    costAndProfitData?: CostAndProfitDataNonNullableFields;
    costRange?: NumericPropertyRangeNonNullableFields;
    pricePerUnitData?: PricePerUnitDataNonNullableFields;
    additionalInfoSections: AdditionalInfoSectionNonNullableFields[];
    ribbons: RibbonNonNullableFields$2[];
    media?: MediaNonNullableFields$2;
    customTextFields: CustomTextFieldNonNullableFields[];
    productOptions: ProductOptionNonNullableFields[];
    productPageUrl?: PageUrlNonNullableFields;
    numericId: string;
    inventoryItemId: string;
    discount?: DiscountNonNullableFields$2;
    collectionIds: string[];
    variants: VariantNonNullableFields$2[];
    seoData?: SeoSchemaNonNullableFields$2;
    exportProductId: string;
    digitalFile?: SecuredMediaNonNullableFields$2;
}
interface CreateProductResponseNonNullableFields$2 {
    product?: ProductNonNullableFields$4;
}
interface UpdateProductResponseNonNullableFields$2 {
    product?: ProductNonNullableFields$4;
}
interface UpdateVariantsResponseNonNullableFields {
    variants: VariantNonNullableFields$2[];
}
interface CollectionNonNullableFields {
    media?: MediaNonNullableFields$2;
    numberOfProducts: number;
    seoSchema?: SeoSchemaNonNullableFields$2;
}
interface CreateCollectionResponseNonNullableFields {
    collection?: CollectionNonNullableFields;
}
interface UpdateCollectionResponseNonNullableFields {
    collection?: CollectionNonNullableFields;
}
interface ApplicationErrorNonNullableFields$c {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$a {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$c;
}
interface BulkProductResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$a;
}
interface BulkActionMetadataNonNullableFields$a {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkUpdateProductsResponseNonNullableFields$2 {
    results: BulkProductResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$a;
}
interface BulkAdjustProductPropertiesResponseNonNullableFields {
    results: BulkProductResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$a;
}
interface QueryProductsPlatformizedResponseNonNullableFields {
    products: ProductNonNullableFields$4[];
}
interface GetProductResponseNonNullableFields {
    product?: ProductNonNullableFields$4;
}
interface GetCollectionBySlugResponseNonNullableFields {
    collection?: CollectionNonNullableFields;
}
interface VariantDataNonNullableFields {
    price?: PriceDataNonNullableFields;
    convertedPriceData?: PriceDataNonNullableFields;
    sku: string;
    inStock: boolean;
    visible: boolean;
    variantId: string;
}
interface ProductOptionsAvailabilityResponseNonNullableFields {
    selectedVariant?: VariantDataNonNullableFields;
    media?: MediaNonNullableFields$2;
    productOptions: ProductOptionNonNullableFields[];
    availableForPurchase: boolean;
    managedProduct: boolean;
}
interface PagingMetadataNonNullableFields$4 {
    items: number;
    offset: number;
}
interface QueryProductVariantsResponseNonNullableFields {
    variants: VariantNonNullableFields$2[];
    metadata?: PagingMetadataNonNullableFields$4;
    totalResults: number;
}
interface PlatformMediaNonNullableFields {
    image: string;
    video: string;
}
interface PreorderInfoNonNullableFields$2 {
    enabled: boolean;
}
interface StoreVariantNonNullableFields {
    _id: string;
    variantId: string;
    productId: string;
    variantName: string;
    productName: string;
    managedVariant: boolean;
    sku: string;
    stock?: VariantStockNonNullableFields;
    collectionIds: string[];
    media?: PlatformMediaNonNullableFields;
    preorderInfo?: PreorderInfoNonNullableFields$2;
}
interface QueryStoreVariantsResponseNonNullableFields {
    variants: StoreVariantNonNullableFields[];
}
interface GetStoreVariantResponseNonNullableFields {
    variant?: StoreVariantNonNullableFields;
}

type __PublicMethodMetaInfo$a<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createProduct$1(): __PublicMethodMetaInfo$a<'POST', {}, CreateProductRequest$2, CreateProductRequest$3, CreateProductResponse$2 & CreateProductResponseNonNullableFields$2, CreateProductResponse$3 & CreateProductResponseNonNullableFields$3>;
declare function updateProduct$1(): __PublicMethodMetaInfo$a<'PATCH', {
    productId: string;
}, UpdateProductRequest$2, UpdateProductRequest$3, UpdateProductResponse$2 & UpdateProductResponseNonNullableFields$2, UpdateProductResponse$3 & UpdateProductResponseNonNullableFields$3>;
declare function deleteProduct$1(): __PublicMethodMetaInfo$a<'DELETE', {
    id: string;
}, DeleteProductRequest, DeleteProductRequest$1, DeleteProductResponse, DeleteProductResponse$1>;
declare function updateProductVariants(): __PublicMethodMetaInfo$a<'PATCH', {
    id: string;
}, UpdateVariantsRequest, UpdateVariantsRequest$1, UpdateVariantsResponse & UpdateVariantsResponseNonNullableFields, UpdateVariantsResponse$1 & UpdateVariantsResponseNonNullableFields$1>;
declare function resetAllProductVariantData(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, ResetAllVariantDataRequest, ResetAllVariantDataRequest$1, ResetAllVariantDataResponse, ResetAllVariantDataResponse$1>;
declare function addProductsToCollection(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, AddProductsToCollectionRequest, AddProductsToCollectionRequest$1, AddProductsToCollectionResponse, AddProductsToCollectionResponse$1>;
declare function removeProductsFromCollection(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, RemoveProductsFromCollectionRequest, RemoveProductsFromCollectionRequest$1, RemoveProductsFromCollectionResponse, RemoveProductsFromCollectionResponse$1>;
declare function addProductMedia(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, AddProductMediaRequest, AddProductMediaRequest$1, AddProductMediaResponse, AddProductMediaResponse$1>;
declare function removeProductMedia(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, RemoveProductMediaRequest, RemoveProductMediaRequest$1, RemoveProductMediaResponse, RemoveProductMediaResponse$1>;
declare function addProductMediaToChoices(): __PublicMethodMetaInfo$a<'PATCH', {
    id: string;
}, AddProductMediaToChoicesRequest, AddProductMediaToChoicesRequest$1, AddProductMediaToChoicesResponse, AddProductMediaToChoicesResponse$1>;
declare function removeProductMediaFromChoices(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, RemoveProductMediaFromChoicesRequest, RemoveProductMediaFromChoicesRequest$1, RemoveProductMediaFromChoicesResponse, RemoveProductMediaFromChoicesResponse$1>;
declare function deleteProductOptions(): __PublicMethodMetaInfo$a<'DELETE', {
    id: string;
}, DeleteProductOptionsRequest, DeleteProductOptionsRequest$1, DeleteProductOptionsResponse, DeleteProductOptionsResponse$1>;
declare function removeBrand(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, RemoveProductBrandRequest, RemoveProductBrandRequest$1, RemoveProductBrandResponse, RemoveProductBrandResponse$1>;
declare function createCollection(): __PublicMethodMetaInfo$a<'POST', {}, CreateCollectionRequest, CreateCollectionRequest$1, CreateCollectionResponse & CreateCollectionResponseNonNullableFields, CreateCollectionResponse$1 & CreateCollectionResponseNonNullableFields$1>;
declare function updateCollection(): __PublicMethodMetaInfo$a<'PATCH', {
    collectionId: string;
}, UpdateCollectionRequest, UpdateCollectionRequest$1, UpdateCollectionResponse & UpdateCollectionResponseNonNullableFields, UpdateCollectionResponse$1 & UpdateCollectionResponseNonNullableFields$1>;
declare function deleteCollection(): __PublicMethodMetaInfo$a<'DELETE', {
    id: string;
}, DeleteCollectionRequest, DeleteCollectionRequest$1, DeleteCollectionResponse, DeleteCollectionResponse$1>;
declare function removeRibbon(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, RemoveProductRibbonRequest, RemoveProductRibbonRequest$1, RemoveProductRibbonResponse, RemoveProductRibbonResponse$1>;
declare function bulkUpdateProductsProperty(): __PublicMethodMetaInfo$a<'POST', {}, BulkUpdateProductsRequest$2, BulkUpdateProductsRequest$3, BulkUpdateProductsResponse$2 & BulkUpdateProductsResponseNonNullableFields$2, BulkUpdateProductsResponse$3 & BulkUpdateProductsResponseNonNullableFields$3>;
declare function bulkAdjustProductProperty(): __PublicMethodMetaInfo$a<'POST', {}, BulkAdjustProductPropertiesRequest, BulkAdjustProductPropertiesRequest$1, BulkAdjustProductPropertiesResponse & BulkAdjustProductPropertiesResponseNonNullableFields, BulkAdjustProductPropertiesResponse$1 & BulkAdjustProductPropertiesResponseNonNullableFields$1>;
declare function queryProducts$1(): __PublicMethodMetaInfo$a<'GET', {}, QueryProductsPlatformizedRequest, QueryProductsPlatformizedRequest$1, QueryProductsPlatformizedResponse & QueryProductsPlatformizedResponseNonNullableFields, QueryProductsPlatformizedResponse$1 & QueryProductsPlatformizedResponseNonNullableFields$1>;
declare function getProduct$1(): __PublicMethodMetaInfo$a<'GET', {
    id: string;
}, GetProductRequest, GetProductRequest$1, GetProductResponse & GetProductResponseNonNullableFields, GetProductResponse$1 & GetProductResponseNonNullableFields$1>;
declare function getCollectionBySlug(): __PublicMethodMetaInfo$a<'GET', {
    slug: string;
}, GetCollectionBySlugRequest, GetCollectionBySlugRequest$1, GetCollectionBySlugResponse & GetCollectionBySlugResponseNonNullableFields, GetCollectionBySlugResponse$1 & GetCollectionBySlugResponseNonNullableFields$1>;
declare function getProductOptionsAvailability(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, ProductOptionsAvailabilityRequest, ProductOptionsAvailabilityRequest$1, ProductOptionsAvailabilityResponse & ProductOptionsAvailabilityResponseNonNullableFields, ProductOptionsAvailabilityResponse$1 & ProductOptionsAvailabilityResponseNonNullableFields$1>;
declare function queryProductVariants(): __PublicMethodMetaInfo$a<'POST', {
    id: string;
}, QueryProductVariantsRequest, QueryProductVariantsRequest$1, QueryProductVariantsResponse & QueryProductVariantsResponseNonNullableFields, QueryProductVariantsResponse$1 & QueryProductVariantsResponseNonNullableFields$1>;
declare function queryStoreVariants(): __PublicMethodMetaInfo$a<'POST', {}, QueryStoreVariantsRequest, QueryStoreVariantsRequest$1, QueryStoreVariantsResponse & QueryStoreVariantsResponseNonNullableFields, QueryStoreVariantsResponse$1 & QueryStoreVariantsResponseNonNullableFields$1>;
declare function getStoreVariant(): __PublicMethodMetaInfo$a<'GET', {
    id: string;
}, GetStoreVariantRequest, GetStoreVariantRequest$1, GetStoreVariantResponse & GetStoreVariantResponseNonNullableFields, GetStoreVariantResponse$1 & GetStoreVariantResponseNonNullableFields$1>;

declare const meta$a_addProductMedia: typeof addProductMedia;
declare const meta$a_addProductMediaToChoices: typeof addProductMediaToChoices;
declare const meta$a_addProductsToCollection: typeof addProductsToCollection;
declare const meta$a_bulkAdjustProductProperty: typeof bulkAdjustProductProperty;
declare const meta$a_bulkUpdateProductsProperty: typeof bulkUpdateProductsProperty;
declare const meta$a_createCollection: typeof createCollection;
declare const meta$a_deleteCollection: typeof deleteCollection;
declare const meta$a_deleteProductOptions: typeof deleteProductOptions;
declare const meta$a_getCollectionBySlug: typeof getCollectionBySlug;
declare const meta$a_getProductOptionsAvailability: typeof getProductOptionsAvailability;
declare const meta$a_getStoreVariant: typeof getStoreVariant;
declare const meta$a_queryProductVariants: typeof queryProductVariants;
declare const meta$a_queryStoreVariants: typeof queryStoreVariants;
declare const meta$a_removeBrand: typeof removeBrand;
declare const meta$a_removeProductMedia: typeof removeProductMedia;
declare const meta$a_removeProductMediaFromChoices: typeof removeProductMediaFromChoices;
declare const meta$a_removeProductsFromCollection: typeof removeProductsFromCollection;
declare const meta$a_removeRibbon: typeof removeRibbon;
declare const meta$a_resetAllProductVariantData: typeof resetAllProductVariantData;
declare const meta$a_updateCollection: typeof updateCollection;
declare const meta$a_updateProductVariants: typeof updateProductVariants;
declare namespace meta$a {
  export { type __PublicMethodMetaInfo$a as __PublicMethodMetaInfo, meta$a_addProductMedia as addProductMedia, meta$a_addProductMediaToChoices as addProductMediaToChoices, meta$a_addProductsToCollection as addProductsToCollection, meta$a_bulkAdjustProductProperty as bulkAdjustProductProperty, meta$a_bulkUpdateProductsProperty as bulkUpdateProductsProperty, meta$a_createCollection as createCollection, createProduct$1 as createProduct, meta$a_deleteCollection as deleteCollection, deleteProduct$1 as deleteProduct, meta$a_deleteProductOptions as deleteProductOptions, meta$a_getCollectionBySlug as getCollectionBySlug, getProduct$1 as getProduct, meta$a_getProductOptionsAvailability as getProductOptionsAvailability, meta$a_getStoreVariant as getStoreVariant, meta$a_queryProductVariants as queryProductVariants, queryProducts$1 as queryProducts, meta$a_queryStoreVariants as queryStoreVariants, meta$a_removeBrand as removeBrand, meta$a_removeProductMedia as removeProductMedia, meta$a_removeProductMediaFromChoices as removeProductMediaFromChoices, meta$a_removeProductsFromCollection as removeProductsFromCollection, meta$a_removeRibbon as removeRibbon, meta$a_resetAllProductVariantData as resetAllProductVariantData, meta$a_updateCollection as updateCollection, updateProduct$1 as updateProduct, meta$a_updateProductVariants as updateProductVariants };
}

/**
 * A brand is a visible property of a product.
 * Adding brands to your products can help improve site and product visibility on search engines.
 */
interface Brand$3 {
    /**
     * Brand ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the brand is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the brand.
     *
     * Ignored when creating a brand.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the brand was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the brand was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Brand name.
     * >**Note:** `name` must be unique.
     */
    name?: string;
    /**
     * Number of products this brand is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Brand API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
interface CreateBrandRequest$1 {
    /** Brand to create. */
    brand: Brand$3;
}
interface CreateBrandResponse$1 {
    /** Created brand. */
    brand?: Brand$3;
}
interface GetBrandRequest$1 {
    /** Brand ID. */
    brandId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$9[];
}
declare enum RequestedFields$9 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetBrandResponse$1 {
    /** Brand. */
    brand?: Brand$3;
}
interface UpdateBrandRequest$1 {
    /** Brand to update. */
    brand: Brand$3;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$9[];
}
interface UpdateBrandResponse$1 {
    /** Updated brand. */
    brand?: Brand$3;
}
interface DeleteBrandRequest$1 {
    /** Brand ID. */
    brandId: string;
}
interface DeleteBrandResponse$1 {
}
interface QueryBrandsRequest$1 {
    /** Query options. */
    query?: CursorQuery$9;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$9[];
}
interface CursorQuery$9 extends CursorQueryPagingMethodOneOf$9 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$b;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$b[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$9 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$b;
}
interface Sorting$b {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$b;
}
declare enum SortOrder$b {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$b {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryBrandsResponse$1 {
    /** List of brands. */
    brands?: Brand$3[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata$b;
}
interface CursorPagingMetadata$b {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$b;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$b {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateBrandsRequest$1 {
    /** Brands to create. */
    brands: Brand$3[];
    /**
     * Whether to return the full created brand entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateBrandsResponse$1 {
    /** Brands created by bulk action. */
    results?: BulkBrandsResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$9;
}
interface BulkBrandsResult$1 {
    /** Bulk action metadata for brand. */
    itemMetadata?: ItemMetadata$9;
    /**
     * Full brand entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: Brand$3;
}
interface ItemMetadata$9 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$b;
}
interface ApplicationError$b {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$9 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateBrandsRequest$1 {
    /** List of brands to update. */
    brands: MaskedBrand$1[];
    /**
     * Whether to return the full updated brand entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$9[];
}
interface MaskedBrand$1 {
    /** Brand to update. */
    brand?: Brand$3;
}
interface BulkUpdateBrandsResponse$1 {
    /** Brands updated by bulk action. */
    results?: BulkBrandsResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$9;
}
interface GetOrCreateBrandRequest$1 {
    /** Brand name to retrieve or create. */
    brandName: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$9[];
}
interface GetOrCreateBrandResponse$1 {
    /** Brand. */
    brand?: Brand$3;
}
interface BulkGetOrCreateBrandsRequest$1 {
    /** Brand names to retrieve or create. */
    brandNames: string[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$9[];
}
interface BulkGetOrCreateBrandsResponse$1 {
    /** Brands retrieved or created by bulk action. */
    results?: BulkBrandsResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$9;
}
interface BulkDeleteBrandsRequest$1 {
    /** IDs of brands to delete. */
    brandIds: string[];
}
interface BulkDeleteBrandsResponse$1 {
    /** Brands deleted by bulk action. */
    results?: BulkDeleteBrandsResponseBulkBrandsResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$9;
}
interface BulkDeleteBrandsResponseBulkBrandsResult$1 {
    /** Bulk action metadata for brand. */
    itemMetadata?: ItemMetadata$9;
}
interface BrandNonNullableFields$1 {
    name: string;
}
interface CreateBrandResponseNonNullableFields$1 {
    brand?: BrandNonNullableFields$1;
}
interface GetBrandResponseNonNullableFields$1 {
    brand?: BrandNonNullableFields$1;
}
interface UpdateBrandResponseNonNullableFields$1 {
    brand?: BrandNonNullableFields$1;
}
interface QueryBrandsResponseNonNullableFields$1 {
    brands: BrandNonNullableFields$1[];
}
interface ApplicationErrorNonNullableFields$b {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$9 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$b;
}
interface BulkBrandsResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$9;
    item?: BrandNonNullableFields$1;
}
interface BulkActionMetadataNonNullableFields$9 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateBrandsResponseNonNullableFields$1 {
    results: BulkBrandsResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$9;
}
interface BulkUpdateBrandsResponseNonNullableFields$1 {
    results: BulkBrandsResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$9;
}
interface GetOrCreateBrandResponseNonNullableFields$1 {
    brand?: BrandNonNullableFields$1;
}
interface BulkGetOrCreateBrandsResponseNonNullableFields$1 {
    results: BulkBrandsResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$9;
}
interface BulkDeleteBrandsResponseBulkBrandsResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$9;
}
interface BulkDeleteBrandsResponseNonNullableFields$1 {
    results: BulkDeleteBrandsResponseBulkBrandsResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$9;
}

/**
 * A brand is a visible property of a product.
 * Adding brands to your products can help improve site and product visibility on search engines.
 */
interface Brand$2 {
    /**
     * Brand ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the brand is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the brand.
     *
     * Ignored when creating a brand.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the brand was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the brand was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Brand name.
     * >**Note:** `name` must be unique.
     */
    name?: string;
    /**
     * Number of products this brand is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Brand API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
interface CreateBrandRequest {
    /** Brand to create. */
    brand: Brand$2;
}
interface CreateBrandResponse {
    /** Created brand. */
    brand?: Brand$2;
}
interface GetBrandRequest {
    /** Brand ID. */
    brandId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$8[];
}
declare enum RequestedFields$8 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetBrandResponse {
    /** Brand. */
    brand?: Brand$2;
}
interface UpdateBrandRequest {
    /** Brand to update. */
    brand: Brand$2;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$8[];
}
interface UpdateBrandResponse {
    /** Updated brand. */
    brand?: Brand$2;
}
interface DeleteBrandRequest {
    /** Brand ID. */
    brandId: string;
}
interface DeleteBrandResponse {
}
interface QueryBrandsRequest {
    /** Query options. */
    query?: CursorQuery$8;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$8[];
}
interface CursorQuery$8 extends CursorQueryPagingMethodOneOf$8 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$a;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$a[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$8 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$a;
}
interface Sorting$a {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$a;
}
declare enum SortOrder$a {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$a {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryBrandsResponse {
    /** List of brands. */
    brands?: Brand$2[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata$a;
}
interface CursorPagingMetadata$a {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$a;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$a {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateBrandsRequest {
    /** Brands to create. */
    brands: Brand$2[];
    /**
     * Whether to return the full created brand entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateBrandsResponse {
    /** Brands created by bulk action. */
    results?: BulkBrandsResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$8;
}
interface BulkBrandsResult {
    /** Bulk action metadata for brand. */
    itemMetadata?: ItemMetadata$8;
    /**
     * Full brand entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: Brand$2;
}
interface ItemMetadata$8 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$a;
}
interface ApplicationError$a {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$8 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateBrandsRequest {
    /** List of brands to update. */
    brands: MaskedBrand[];
    /**
     * Whether to return the full updated brand entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$8[];
}
interface MaskedBrand {
    /** Brand to update. */
    brand?: Brand$2;
}
interface BulkUpdateBrandsResponse {
    /** Brands updated by bulk action. */
    results?: BulkBrandsResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$8;
}
interface GetOrCreateBrandRequest {
    /** Brand name to retrieve or create. */
    brandName: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$8[];
}
interface GetOrCreateBrandResponse {
    /** Brand. */
    brand?: Brand$2;
}
interface BulkGetOrCreateBrandsRequest {
    /** Brand names to retrieve or create. */
    brandNames: string[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$8[];
}
interface BulkGetOrCreateBrandsResponse {
    /** Brands retrieved or created by bulk action. */
    results?: BulkBrandsResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$8;
}
interface BulkDeleteBrandsRequest {
    /** IDs of brands to delete. */
    brandIds: string[];
}
interface BulkDeleteBrandsResponse {
    /** Brands deleted by bulk action. */
    results?: BulkDeleteBrandsResponseBulkBrandsResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$8;
}
interface BulkDeleteBrandsResponseBulkBrandsResult {
    /** Bulk action metadata for brand. */
    itemMetadata?: ItemMetadata$8;
}
interface BrandNonNullableFields {
    name: string;
}
interface CreateBrandResponseNonNullableFields {
    brand?: BrandNonNullableFields;
}
interface GetBrandResponseNonNullableFields {
    brand?: BrandNonNullableFields;
}
interface UpdateBrandResponseNonNullableFields {
    brand?: BrandNonNullableFields;
}
interface QueryBrandsResponseNonNullableFields {
    brands: BrandNonNullableFields[];
}
interface ApplicationErrorNonNullableFields$a {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$8 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$a;
}
interface BulkBrandsResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$8;
    item?: BrandNonNullableFields;
}
interface BulkActionMetadataNonNullableFields$8 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateBrandsResponseNonNullableFields {
    results: BulkBrandsResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$8;
}
interface BulkUpdateBrandsResponseNonNullableFields {
    results: BulkBrandsResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$8;
}
interface GetOrCreateBrandResponseNonNullableFields {
    brand?: BrandNonNullableFields;
}
interface BulkGetOrCreateBrandsResponseNonNullableFields {
    results: BulkBrandsResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$8;
}
interface BulkDeleteBrandsResponseBulkBrandsResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$8;
}
interface BulkDeleteBrandsResponseNonNullableFields {
    results: BulkDeleteBrandsResponseBulkBrandsResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$8;
}

type __PublicMethodMetaInfo$9<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createBrand(): __PublicMethodMetaInfo$9<'POST', {}, CreateBrandRequest, CreateBrandRequest$1, CreateBrandResponse & CreateBrandResponseNonNullableFields, CreateBrandResponse$1 & CreateBrandResponseNonNullableFields$1>;
declare function getBrand(): __PublicMethodMetaInfo$9<'GET', {
    brandId: string;
}, GetBrandRequest, GetBrandRequest$1, GetBrandResponse & GetBrandResponseNonNullableFields, GetBrandResponse$1 & GetBrandResponseNonNullableFields$1>;
declare function updateBrand(): __PublicMethodMetaInfo$9<'PATCH', {
    brandId: string;
}, UpdateBrandRequest, UpdateBrandRequest$1, UpdateBrandResponse & UpdateBrandResponseNonNullableFields, UpdateBrandResponse$1 & UpdateBrandResponseNonNullableFields$1>;
declare function deleteBrand(): __PublicMethodMetaInfo$9<'DELETE', {
    brandId: string;
}, DeleteBrandRequest, DeleteBrandRequest$1, DeleteBrandResponse, DeleteBrandResponse$1>;
declare function queryBrands(): __PublicMethodMetaInfo$9<'POST', {}, QueryBrandsRequest, QueryBrandsRequest$1, QueryBrandsResponse & QueryBrandsResponseNonNullableFields, QueryBrandsResponse$1 & QueryBrandsResponseNonNullableFields$1>;
declare function bulkCreateBrands(): __PublicMethodMetaInfo$9<'POST', {}, BulkCreateBrandsRequest, BulkCreateBrandsRequest$1, BulkCreateBrandsResponse & BulkCreateBrandsResponseNonNullableFields, BulkCreateBrandsResponse$1 & BulkCreateBrandsResponseNonNullableFields$1>;
declare function bulkUpdateBrands(): __PublicMethodMetaInfo$9<'POST', {}, BulkUpdateBrandsRequest, BulkUpdateBrandsRequest$1, BulkUpdateBrandsResponse & BulkUpdateBrandsResponseNonNullableFields, BulkUpdateBrandsResponse$1 & BulkUpdateBrandsResponseNonNullableFields$1>;
declare function getOrCreateBrand(): __PublicMethodMetaInfo$9<'POST', {}, GetOrCreateBrandRequest, GetOrCreateBrandRequest$1, GetOrCreateBrandResponse & GetOrCreateBrandResponseNonNullableFields, GetOrCreateBrandResponse$1 & GetOrCreateBrandResponseNonNullableFields$1>;
declare function bulkGetOrCreateBrands(): __PublicMethodMetaInfo$9<'POST', {}, BulkGetOrCreateBrandsRequest, BulkGetOrCreateBrandsRequest$1, BulkGetOrCreateBrandsResponse & BulkGetOrCreateBrandsResponseNonNullableFields, BulkGetOrCreateBrandsResponse$1 & BulkGetOrCreateBrandsResponseNonNullableFields$1>;
declare function bulkDeleteBrands(): __PublicMethodMetaInfo$9<'POST', {}, BulkDeleteBrandsRequest, BulkDeleteBrandsRequest$1, BulkDeleteBrandsResponse & BulkDeleteBrandsResponseNonNullableFields, BulkDeleteBrandsResponse$1 & BulkDeleteBrandsResponseNonNullableFields$1>;

declare const meta$9_bulkCreateBrands: typeof bulkCreateBrands;
declare const meta$9_bulkDeleteBrands: typeof bulkDeleteBrands;
declare const meta$9_bulkGetOrCreateBrands: typeof bulkGetOrCreateBrands;
declare const meta$9_bulkUpdateBrands: typeof bulkUpdateBrands;
declare const meta$9_createBrand: typeof createBrand;
declare const meta$9_deleteBrand: typeof deleteBrand;
declare const meta$9_getBrand: typeof getBrand;
declare const meta$9_getOrCreateBrand: typeof getOrCreateBrand;
declare const meta$9_queryBrands: typeof queryBrands;
declare const meta$9_updateBrand: typeof updateBrand;
declare namespace meta$9 {
  export { type __PublicMethodMetaInfo$9 as __PublicMethodMetaInfo, meta$9_bulkCreateBrands as bulkCreateBrands, meta$9_bulkDeleteBrands as bulkDeleteBrands, meta$9_bulkGetOrCreateBrands as bulkGetOrCreateBrands, meta$9_bulkUpdateBrands as bulkUpdateBrands, meta$9_createBrand as createBrand, meta$9_deleteBrand as deleteBrand, meta$9_getBrand as getBrand, meta$9_getOrCreateBrand as getOrCreateBrand, meta$9_queryBrands as queryBrands, meta$9_updateBrand as updateBrand };
}

/**
 * Customizations include options and modifiers which can later be applied to products.
 * Options are designed to add variations to a product, where modifiers add a customizable change to the product but without creating another variant.
 */
interface Customization$1 extends CustomizationCustomizationSettingsOneOf$1 {
    /**
     * Free text input settings.
     *
     * > **Note:** To be passed along with `customizationRenderType: FREE_TEXT`.
     */
    freeTextInput?: FreeTextSettings$3;
    /**
     * Choices settings.
     *
     * > **Note:** Must be passed along with `customizationRenderType` of `SWATCH_CHOICES` and `TEXT_CHOICES`.
     */
    choicesSettings?: ChoicesSettings$3;
    /**
     * Customization ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the customization is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the customization.
     *
     * Ignored when creating a customization.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the customization was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the customization was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Customization name for options (for example, `"color"`, `"size"`) and modifiers (for example, `"greeting card"`). */
    name?: string;
    /** Customization type. */
    customizationType?: CustomizationType$1;
    /**
     * Customization render type.
     *
     * Defines how the customization will be displayed in the storefront.
     */
    customizationRenderType?: CustomizationRenderType$1;
    /**
     * Number of products this customization is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Customizations API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
/** @oneof */
interface CustomizationCustomizationSettingsOneOf$1 {
    /**
     * Free text input settings.
     *
     * > **Note:** To be passed along with `customizationRenderType: FREE_TEXT`.
     */
    freeTextInput?: FreeTextSettings$3;
    /**
     * Choices settings.
     *
     * > **Note:** Must be passed along with `customizationRenderType` of `SWATCH_CHOICES` and `TEXT_CHOICES`.
     */
    choicesSettings?: ChoicesSettings$3;
}
declare enum CustomizationType$1 {
    UNKNOWN_CUSTOMIZATION_TYPE = "UNKNOWN_CUSTOMIZATION_TYPE",
    PRODUCT_OPTION = "PRODUCT_OPTION",
    MODIFIER = "MODIFIER"
}
declare enum CustomizationRenderType$1 {
    UNKNOWN_CUSTOMIZATION_RENDER_TYPE = "UNKNOWN_CUSTOMIZATION_RENDER_TYPE",
    FREE_TEXT = "FREE_TEXT",
    TEXT_CHOICES = "TEXT_CHOICES",
    SWATCH_CHOICES = "SWATCH_CHOICES"
}
interface FreeTextSettings$3 {
    /** Minimum text character length. */
    minCharCount?: number;
    /** Maximum text character length. */
    maxCharCount?: number;
    /** Default amount added to a product's price when this choice is assigned to a modifier. */
    defaultAddedPrice?: string | null;
    /** Title to display to customer for their free-text input. */
    title?: string;
}
interface ChoicesSettings$3 {
    /** List of choices. */
    choices?: Choice$1[];
}
interface Choice$1 extends ChoiceValueOneOf$1 {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
    /**
     * Choice ID.
     * @readonly
     */
    id?: string;
    /**
     * Choice type.
     *
     * > **Notes:**
     * > + For `customizationRenderType: SWATCH_CHOICES`, the supported `choiceType` values are: `ONE_COLOR`, `MULTIPLE_COLORS`, or `IMAGE`.
     * > + For a `customizationRenderType` of `TEXT_CHOICES` and `FREE_TEXT`, the supported `choiceType` value is: `CHOICE_TEXT`.
     */
    choiceType?: ChoiceType$3;
    /**
     * A read-only key generated based on choice name. Used for eCommerce integration.
     * @readonly
     */
    key?: string | null;
    /** Choice name. */
    name?: string;
    /** Default amount added to a product's price when this customization is assigned to a modifier. */
    defaultAddedPrice?: string | null;
    /**
     * Number of products this choice is assigned to .
     * @readonly
     */
    assignedProductsCount?: number;
}
/** @oneof */
interface ChoiceValueOneOf$1 {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
}
declare enum ChoiceType$3 {
    UNKNOWN_CHOICE_TYPE = "UNKNOWN_CHOICE_TYPE",
    CHOICE_TEXT = "CHOICE_TEXT",
    ONE_COLOR = "ONE_COLOR",
    MULTIPLE_COLORS = "MULTIPLE_COLORS",
    IMAGE = "IMAGE"
}
interface CreateCustomizationRequest$1 {
    /** Customization to create. */
    customization: Customization$1;
}
interface CreateCustomizationResponse$1 {
    /** Created customization. */
    customization?: Customization$1;
}
interface GetCustomizationRequest$1 {
    /** Customization ID. */
    customizationId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
declare enum RequestedFields$7 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetCustomizationResponse$1 {
    /** Customization. */
    customization?: Customization$1;
}
interface UpdateCustomizationRequest$1 {
    /** Customization to update. */
    customization: Customization$1;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface UpdateCustomizationResponse$1 {
    /** Updated customization. */
    customization?: Customization$1;
}
interface DeleteCustomizationRequest$1 {
    /** Customization ID. */
    customizationId: string;
}
interface DeleteCustomizationResponse$1 {
}
interface QueryCustomizationsRequest$1 {
    /** Query options. */
    query?: CursorQuery$7;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface CursorQuery$7 extends CursorQueryPagingMethodOneOf$7 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$9;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$9[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$7 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$9;
}
interface Sorting$9 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$9;
}
declare enum SortOrder$9 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$9 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryCustomizationsResponse$1 {
    /** List of customizations. */
    customizations?: Customization$1[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$9;
}
interface CursorPagingMetadata$9 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$9;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$9 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateCustomizationsRequest$1 {
    /** Customizations to create. */
    customizations: Customization$1[];
    /**
     * Whether to return the full customization entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateCustomizationsResponse$1 {
    /** Customizations created by bulk action. */
    results?: BulkCustomizationResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$7;
}
interface BulkCustomizationResult$1 {
    /** Bulk action metadata for customization. */
    itemMetadata?: ItemMetadata$7;
    /**
     * Full customization entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    customization?: Customization$1;
}
interface ItemMetadata$7 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$9;
}
interface ApplicationError$9 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$7 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface AddCustomizationChoicesRequest$1 {
    /** Customization ID. */
    customizationId: string;
    /** Choices to add. */
    choices: Choice$1[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface AddCustomizationChoicesResponse$1 {
    /** Updated customization. */
    customization?: Customization$1;
}
interface SetCustomizationChoicesRequest$1 {
    /** Customization ID. */
    customizationId: string;
    /** Choices to set. */
    choices: Choice$1[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface SetCustomizationChoicesResponse$1 {
    /** Updated customization. */
    customization?: Customization$1;
}
interface RemoveCustomizationChoicesRequest$1 {
    /** Customization ID. */
    customizationId: string;
    /** IDs of choices to remove. */
    choiceIds: string[];
    /** Customization revision. */
    revision?: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface RemoveCustomizationChoicesResponse$1 {
    /** Updated customization. */
    customization?: Customization$1;
}
interface BulkAddCustomizationChoicesRequest$1 {
    /** List of customization IDs and choices. */
    customizationsChoices: CustomizationChoices$1[];
    /**
     * Whether to return the full customization entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface CustomizationChoices$1 {
    /** Customization ID. */
    customizationId?: string;
    /** Choices to add. */
    choices?: Choice$1[];
}
interface BulkAddCustomizationChoicesResponse$1 {
    /** Customizations updated by bulk action. */
    results?: BulkCustomizationResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$7;
}
interface BulkUpdateCustomizationsRequest$1 {
    /** List of customizations to update. */
    customizations: MaskedCustomization$1[];
    /**
     * Whether to return the full customization entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$7[];
}
interface MaskedCustomization$1 {
    /** Customization to update. */
    customization?: Customization$1;
}
interface BulkUpdateCustomizationsResponse$1 {
    /** Customizations updated by bulk action. */
    results?: BulkCustomizationResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$7;
}
interface FreeTextSettingsNonNullableFields$3 {
    minCharCount: number;
    maxCharCount: number;
    title: string;
}
interface MultipleColorsNonNullableFields$3 {
    colorCodes: string[];
}
interface ImageNonNullableFields$4 {
    id: string;
    url: string;
    height: number;
    width: number;
}
interface ChoiceNonNullableFields$1 {
    colorCode: string;
    colorCodes?: MultipleColorsNonNullableFields$3;
    image?: ImageNonNullableFields$4;
    id: string;
    choiceType: ChoiceType$3;
    name: string;
    assignedProductsCount: number;
}
interface ChoicesSettingsNonNullableFields$3 {
    choices: ChoiceNonNullableFields$1[];
}
interface CustomizationNonNullableFields$1 {
    freeTextInput?: FreeTextSettingsNonNullableFields$3;
    choicesSettings?: ChoicesSettingsNonNullableFields$3;
    name: string;
    customizationType: CustomizationType$1;
    customizationRenderType: CustomizationRenderType$1;
}
interface CreateCustomizationResponseNonNullableFields$1 {
    customization?: CustomizationNonNullableFields$1;
}
interface GetCustomizationResponseNonNullableFields$1 {
    customization?: CustomizationNonNullableFields$1;
}
interface UpdateCustomizationResponseNonNullableFields$1 {
    customization?: CustomizationNonNullableFields$1;
}
interface QueryCustomizationsResponseNonNullableFields$1 {
    customizations: CustomizationNonNullableFields$1[];
}
interface ApplicationErrorNonNullableFields$9 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$7 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$9;
}
interface BulkCustomizationResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$7;
    customization?: CustomizationNonNullableFields$1;
}
interface BulkActionMetadataNonNullableFields$7 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateCustomizationsResponseNonNullableFields$1 {
    results: BulkCustomizationResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$7;
}
interface AddCustomizationChoicesResponseNonNullableFields$1 {
    customization?: CustomizationNonNullableFields$1;
}
interface SetCustomizationChoicesResponseNonNullableFields$1 {
    customization?: CustomizationNonNullableFields$1;
}
interface RemoveCustomizationChoicesResponseNonNullableFields$1 {
    customization?: CustomizationNonNullableFields$1;
}
interface BulkAddCustomizationChoicesResponseNonNullableFields$1 {
    results: BulkCustomizationResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$7;
}
interface BulkUpdateCustomizationsResponseNonNullableFields$1 {
    results: BulkCustomizationResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$7;
}

/**
 * Customizations include options and modifiers which can later be applied to products.
 * Options are designed to add variations to a product, where modifiers add a customizable change to the product but without creating another variant.
 */
interface Customization extends CustomizationCustomizationSettingsOneOf {
    /**
     * Free text input settings.
     *
     * > **Note:** To be passed along with `customizationRenderType: FREE_TEXT`.
     */
    freeTextInput?: FreeTextSettings$2;
    /**
     * Choices settings.
     *
     * > **Note:** Must be passed along with `customizationRenderType` of `SWATCH_CHOICES` and `TEXT_CHOICES`.
     */
    choicesSettings?: ChoicesSettings$2;
    /**
     * Customization ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the customization is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the customization.
     *
     * Ignored when creating a customization.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the customization was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the customization was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Customization name for options (for example, `"color"`, `"size"`) and modifiers (for example, `"greeting card"`). */
    name?: string;
    /** Customization type. */
    customizationType?: CustomizationType;
    /**
     * Customization render type.
     *
     * Defines how the customization will be displayed in the storefront.
     */
    customizationRenderType?: CustomizationRenderType;
    /**
     * Number of products this customization is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Customizations API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
/** @oneof */
interface CustomizationCustomizationSettingsOneOf {
    /**
     * Free text input settings.
     *
     * > **Note:** To be passed along with `customizationRenderType: FREE_TEXT`.
     */
    freeTextInput?: FreeTextSettings$2;
    /**
     * Choices settings.
     *
     * > **Note:** Must be passed along with `customizationRenderType` of `SWATCH_CHOICES` and `TEXT_CHOICES`.
     */
    choicesSettings?: ChoicesSettings$2;
}
declare enum CustomizationType {
    UNKNOWN_CUSTOMIZATION_TYPE = "UNKNOWN_CUSTOMIZATION_TYPE",
    PRODUCT_OPTION = "PRODUCT_OPTION",
    MODIFIER = "MODIFIER"
}
declare enum CustomizationRenderType {
    UNKNOWN_CUSTOMIZATION_RENDER_TYPE = "UNKNOWN_CUSTOMIZATION_RENDER_TYPE",
    FREE_TEXT = "FREE_TEXT",
    TEXT_CHOICES = "TEXT_CHOICES",
    SWATCH_CHOICES = "SWATCH_CHOICES"
}
interface FreeTextSettings$2 {
    /** Minimum text character length. */
    minCharCount?: number;
    /** Maximum text character length. */
    maxCharCount?: number;
    /** Default amount added to a product's price when this choice is assigned to a modifier. */
    defaultAddedPrice?: string | null;
    /** Title to display to customer for their free-text input. */
    title?: string;
}
interface ChoicesSettings$2 {
    /** List of choices. */
    choices?: Choice[];
}
interface Choice extends ChoiceValueOneOf {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
    /**
     * Choice ID.
     * @readonly
     */
    _id?: string;
    /**
     * Choice type.
     *
     * > **Notes:**
     * > + For `customizationRenderType: SWATCH_CHOICES`, the supported `choiceType` values are: `ONE_COLOR`, `MULTIPLE_COLORS`, or `IMAGE`.
     * > + For a `customizationRenderType` of `TEXT_CHOICES` and `FREE_TEXT`, the supported `choiceType` value is: `CHOICE_TEXT`.
     */
    choiceType?: ChoiceType$2;
    /**
     * A read-only key generated based on choice name. Used for eCommerce integration.
     * @readonly
     */
    key?: string | null;
    /** Choice name. */
    name?: string;
    /** Default amount added to a product's price when this customization is assigned to a modifier. */
    defaultAddedPrice?: string | null;
    /**
     * Number of products this choice is assigned to .
     * @readonly
     */
    assignedProductsCount?: number;
}
/** @oneof */
interface ChoiceValueOneOf {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
}
declare enum ChoiceType$2 {
    UNKNOWN_CHOICE_TYPE = "UNKNOWN_CHOICE_TYPE",
    CHOICE_TEXT = "CHOICE_TEXT",
    ONE_COLOR = "ONE_COLOR",
    MULTIPLE_COLORS = "MULTIPLE_COLORS",
    IMAGE = "IMAGE"
}
interface CreateCustomizationRequest {
    /** Customization to create. */
    customization: Customization;
}
interface CreateCustomizationResponse {
    /** Created customization. */
    customization?: Customization;
}
interface GetCustomizationRequest {
    /** Customization ID. */
    customizationId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
declare enum RequestedFields$6 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetCustomizationResponse {
    /** Customization. */
    customization?: Customization;
}
interface UpdateCustomizationRequest {
    /** Customization to update. */
    customization: Customization;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface UpdateCustomizationResponse {
    /** Updated customization. */
    customization?: Customization;
}
interface DeleteCustomizationRequest {
    /** Customization ID. */
    customizationId: string;
}
interface DeleteCustomizationResponse {
}
interface QueryCustomizationsRequest {
    /** Query options. */
    query?: CursorQuery$6;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface CursorQuery$6 extends CursorQueryPagingMethodOneOf$6 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$8;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$8[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$6 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$8;
}
interface Sorting$8 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$8;
}
declare enum SortOrder$8 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$8 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryCustomizationsResponse {
    /** List of customizations. */
    customizations?: Customization[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$8;
}
interface CursorPagingMetadata$8 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$8;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$8 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateCustomizationsRequest {
    /** Customizations to create. */
    customizations: Customization[];
    /**
     * Whether to return the full customization entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateCustomizationsResponse {
    /** Customizations created by bulk action. */
    results?: BulkCustomizationResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$6;
}
interface BulkCustomizationResult {
    /** Bulk action metadata for customization. */
    itemMetadata?: ItemMetadata$6;
    /**
     * Full customization entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    customization?: Customization;
}
interface ItemMetadata$6 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$8;
}
interface ApplicationError$8 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$6 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface AddCustomizationChoicesRequest {
    /** Customization ID. */
    customizationId: string;
    /** Choices to add. */
    choices: Choice[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface AddCustomizationChoicesResponse {
    /** Updated customization. */
    customization?: Customization;
}
interface SetCustomizationChoicesRequest {
    /** Customization ID. */
    customizationId: string;
    /** Choices to set. */
    choices: Choice[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface SetCustomizationChoicesResponse {
    /** Updated customization. */
    customization?: Customization;
}
interface RemoveCustomizationChoicesRequest {
    /** Customization ID. */
    customizationId: string;
    /** IDs of choices to remove. */
    choiceIds: string[];
    /** Customization revision. */
    revision?: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface RemoveCustomizationChoicesResponse {
    /** Updated customization. */
    customization?: Customization;
}
interface BulkAddCustomizationChoicesRequest {
    /** List of customization IDs and choices. */
    customizationsChoices: CustomizationChoices[];
    /**
     * Whether to return the full customization entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface CustomizationChoices {
    /** Customization ID. */
    customizationId?: string;
    /** Choices to add. */
    choices?: Choice[];
}
interface BulkAddCustomizationChoicesResponse {
    /** Customizations updated by bulk action. */
    results?: BulkCustomizationResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$6;
}
interface BulkUpdateCustomizationsRequest {
    /** List of customizations to update. */
    customizations: MaskedCustomization[];
    /**
     * Whether to return the full customization entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$6[];
}
interface MaskedCustomization {
    /** Customization to update. */
    customization?: Customization;
}
interface BulkUpdateCustomizationsResponse {
    /** Customizations updated by bulk action. */
    results?: BulkCustomizationResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$6;
}
interface FreeTextSettingsNonNullableFields$2 {
    minCharCount: number;
    maxCharCount: number;
    title: string;
}
interface MultipleColorsNonNullableFields$2 {
    colorCodes: string[];
}
interface ChoiceNonNullableFields {
    colorCode: string;
    colorCodes?: MultipleColorsNonNullableFields$2;
    image: string;
    _id: string;
    choiceType: ChoiceType$2;
    name: string;
    assignedProductsCount: number;
}
interface ChoicesSettingsNonNullableFields$2 {
    choices: ChoiceNonNullableFields[];
}
interface CustomizationNonNullableFields {
    freeTextInput?: FreeTextSettingsNonNullableFields$2;
    choicesSettings?: ChoicesSettingsNonNullableFields$2;
    name: string;
    customizationType: CustomizationType;
    customizationRenderType: CustomizationRenderType;
}
interface CreateCustomizationResponseNonNullableFields {
    customization?: CustomizationNonNullableFields;
}
interface GetCustomizationResponseNonNullableFields {
    customization?: CustomizationNonNullableFields;
}
interface UpdateCustomizationResponseNonNullableFields {
    customization?: CustomizationNonNullableFields;
}
interface QueryCustomizationsResponseNonNullableFields {
    customizations: CustomizationNonNullableFields[];
}
interface ApplicationErrorNonNullableFields$8 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$6 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$8;
}
interface BulkCustomizationResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$6;
    customization?: CustomizationNonNullableFields;
}
interface BulkActionMetadataNonNullableFields$6 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateCustomizationsResponseNonNullableFields {
    results: BulkCustomizationResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$6;
}
interface AddCustomizationChoicesResponseNonNullableFields {
    customization?: CustomizationNonNullableFields;
}
interface SetCustomizationChoicesResponseNonNullableFields {
    customization?: CustomizationNonNullableFields;
}
interface RemoveCustomizationChoicesResponseNonNullableFields {
    customization?: CustomizationNonNullableFields;
}
interface BulkAddCustomizationChoicesResponseNonNullableFields {
    results: BulkCustomizationResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$6;
}
interface BulkUpdateCustomizationsResponseNonNullableFields {
    results: BulkCustomizationResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$6;
}

type __PublicMethodMetaInfo$8<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createCustomization(): __PublicMethodMetaInfo$8<'POST', {}, CreateCustomizationRequest, CreateCustomizationRequest$1, CreateCustomizationResponse & CreateCustomizationResponseNonNullableFields, CreateCustomizationResponse$1 & CreateCustomizationResponseNonNullableFields$1>;
declare function getCustomization(): __PublicMethodMetaInfo$8<'GET', {
    customizationId: string;
}, GetCustomizationRequest, GetCustomizationRequest$1, GetCustomizationResponse & GetCustomizationResponseNonNullableFields, GetCustomizationResponse$1 & GetCustomizationResponseNonNullableFields$1>;
declare function updateCustomization(): __PublicMethodMetaInfo$8<'PATCH', {
    customizationId: string;
}, UpdateCustomizationRequest, UpdateCustomizationRequest$1, UpdateCustomizationResponse & UpdateCustomizationResponseNonNullableFields, UpdateCustomizationResponse$1 & UpdateCustomizationResponseNonNullableFields$1>;
declare function deleteCustomization(): __PublicMethodMetaInfo$8<'DELETE', {
    customizationId: string;
}, DeleteCustomizationRequest, DeleteCustomizationRequest$1, DeleteCustomizationResponse, DeleteCustomizationResponse$1>;
declare function queryCustomizations(): __PublicMethodMetaInfo$8<'POST', {}, QueryCustomizationsRequest, QueryCustomizationsRequest$1, QueryCustomizationsResponse & QueryCustomizationsResponseNonNullableFields, QueryCustomizationsResponse$1 & QueryCustomizationsResponseNonNullableFields$1>;
declare function bulkCreateCustomizations(): __PublicMethodMetaInfo$8<'POST', {}, BulkCreateCustomizationsRequest, BulkCreateCustomizationsRequest$1, BulkCreateCustomizationsResponse & BulkCreateCustomizationsResponseNonNullableFields, BulkCreateCustomizationsResponse$1 & BulkCreateCustomizationsResponseNonNullableFields$1>;
declare function addCustomizationChoices(): __PublicMethodMetaInfo$8<'POST', {
    customizationId: string;
}, AddCustomizationChoicesRequest, AddCustomizationChoicesRequest$1, AddCustomizationChoicesResponse & AddCustomizationChoicesResponseNonNullableFields, AddCustomizationChoicesResponse$1 & AddCustomizationChoicesResponseNonNullableFields$1>;
declare function setCustomizationChoices(): __PublicMethodMetaInfo$8<'POST', {
    customizationId: string;
}, SetCustomizationChoicesRequest, SetCustomizationChoicesRequest$1, SetCustomizationChoicesResponse & SetCustomizationChoicesResponseNonNullableFields, SetCustomizationChoicesResponse$1 & SetCustomizationChoicesResponseNonNullableFields$1>;
declare function removeCustomizationChoices(): __PublicMethodMetaInfo$8<'POST', {
    customizationId: string;
}, RemoveCustomizationChoicesRequest, RemoveCustomizationChoicesRequest$1, RemoveCustomizationChoicesResponse & RemoveCustomizationChoicesResponseNonNullableFields, RemoveCustomizationChoicesResponse$1 & RemoveCustomizationChoicesResponseNonNullableFields$1>;
declare function bulkAddCustomizationChoices(): __PublicMethodMetaInfo$8<'POST', {}, BulkAddCustomizationChoicesRequest, BulkAddCustomizationChoicesRequest$1, BulkAddCustomizationChoicesResponse & BulkAddCustomizationChoicesResponseNonNullableFields, BulkAddCustomizationChoicesResponse$1 & BulkAddCustomizationChoicesResponseNonNullableFields$1>;
declare function bulkUpdateCustomizations(): __PublicMethodMetaInfo$8<'POST', {}, BulkUpdateCustomizationsRequest, BulkUpdateCustomizationsRequest$1, BulkUpdateCustomizationsResponse & BulkUpdateCustomizationsResponseNonNullableFields, BulkUpdateCustomizationsResponse$1 & BulkUpdateCustomizationsResponseNonNullableFields$1>;

declare const meta$8_addCustomizationChoices: typeof addCustomizationChoices;
declare const meta$8_bulkAddCustomizationChoices: typeof bulkAddCustomizationChoices;
declare const meta$8_bulkCreateCustomizations: typeof bulkCreateCustomizations;
declare const meta$8_bulkUpdateCustomizations: typeof bulkUpdateCustomizations;
declare const meta$8_createCustomization: typeof createCustomization;
declare const meta$8_deleteCustomization: typeof deleteCustomization;
declare const meta$8_getCustomization: typeof getCustomization;
declare const meta$8_queryCustomizations: typeof queryCustomizations;
declare const meta$8_removeCustomizationChoices: typeof removeCustomizationChoices;
declare const meta$8_setCustomizationChoices: typeof setCustomizationChoices;
declare const meta$8_updateCustomization: typeof updateCustomization;
declare namespace meta$8 {
  export { type __PublicMethodMetaInfo$8 as __PublicMethodMetaInfo, meta$8_addCustomizationChoices as addCustomizationChoices, meta$8_bulkAddCustomizationChoices as bulkAddCustomizationChoices, meta$8_bulkCreateCustomizations as bulkCreateCustomizations, meta$8_bulkUpdateCustomizations as bulkUpdateCustomizations, meta$8_createCustomization as createCustomization, meta$8_deleteCustomization as deleteCustomization, meta$8_getCustomization as getCustomization, meta$8_queryCustomizations as queryCustomizations, meta$8_removeCustomizationChoices as removeCustomizationChoices, meta$8_setCustomizationChoices as setCustomizationChoices, meta$8_updateCustomization as updateCustomization };
}

/**
 * An info section is a visible property of a product
 * Add info sections to a product to provide all the explanations your customers need.
 */
interface InfoSection$3 {
    /**
     * Info section ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the info section is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the info section.
     *
     * Ignored when creating an info section.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the info section was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the info section was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Unique name. Used as an identifier. */
    uniqueName?: string;
    /** Info section title. */
    title?: string;
    /**
     * Info section description using rich content.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    description?: RichContent$3;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
    /**
     * Number of products this info section is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Info Sections API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
interface RichContent$3 {
    /** Node objects representing a rich content document. */
    nodes?: Node$3[];
    /** Object metadata. */
    metadata?: Metadata$3;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle$3;
}
interface Node$3 extends NodeDataOneOf$3 {
    /** Data for a button node. */
    buttonData?: ButtonData$3;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData$3;
    /** Data for a divider node. */
    dividerData?: DividerData$3;
    /** Data for a file node. */
    fileData?: FileData$3;
    /** Data for a gallery node. */
    galleryData?: GalleryData$3;
    /** Data for a GIF node. */
    gifData?: GIFData$3;
    /** Data for a heading node. */
    headingData?: HeadingData$3;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData$3;
    /** Data for an image node. */
    imageData?: ImageData$3;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData$3;
    /** Data for a map node. */
    mapData?: MapData$3;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData$3;
    /** Data for a poll node. */
    pollData?: PollData$3;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData$3;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData$3;
    /** Data for a video node. */
    videoData?: VideoData$3;
    /** Data for an oEmbed node. */
    embedData?: EmbedData$3;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData$3;
    /** Data for a table node. */
    tableData?: TableData$3;
    /** Data for a table cell node. */
    tableCellData?: TableCellData$3;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData$3;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData$3;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData$3;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData$3;
    /** Data for a caption node. */
    captionData?: CaptionData$3;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeType$3;
    /** Node ID. */
    id?: string;
    /** A list of child nodes. */
    nodes?: Node$3[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle$3;
}
/** @oneof */
interface NodeDataOneOf$3 {
    /** Data for a button node. */
    buttonData?: ButtonData$3;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData$3;
    /** Data for a divider node. */
    dividerData?: DividerData$3;
    /** Data for a file node. */
    fileData?: FileData$3;
    /** Data for a gallery node. */
    galleryData?: GalleryData$3;
    /** Data for a GIF node. */
    gifData?: GIFData$3;
    /** Data for a heading node. */
    headingData?: HeadingData$3;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData$3;
    /** Data for an image node. */
    imageData?: ImageData$3;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData$3;
    /** Data for a map node. */
    mapData?: MapData$3;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData$3;
    /** Data for a poll node. */
    pollData?: PollData$3;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData$3;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData$3;
    /** Data for a video node. */
    videoData?: VideoData$3;
    /** Data for an oEmbed node. */
    embedData?: EmbedData$3;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData$3;
    /** Data for a table node. */
    tableData?: TableData$3;
    /** Data for a table cell node. */
    tableCellData?: TableCellData$3;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData$3;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData$3;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData$3;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData$3;
    /** Data for a caption node. */
    captionData?: CaptionData$3;
}
declare enum NodeType$3 {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION"
}
interface NodeStyle$3 {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData$3 {
    /** Styling for the button's container. */
    containerData?: PluginContainerData$3;
    /** The button type. */
    type?: Type$3;
    /** Styling for the button. */
    styles?: Styles$3;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link$3;
}
interface Border$3 {
    /** Border width in pixels. */
    width?: number | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface Colors$3 {
    /** The text color as a hexadecimal value. */
    text?: string | null;
    /** The border color as a hexadecimal value. */
    border?: string | null;
    /** The background color as a hexadecimal value. */
    background?: string | null;
}
interface PluginContainerData$3 {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth$3;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignment$3;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler$3;
    /** The height of the node when it's displayed. */
    height?: Height$3;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType$3 {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
interface PluginContainerDataWidth$3 extends PluginContainerDataWidthDataOneOf$3 {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType$3;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf$3 {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType$3;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment$3 {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
interface Spoiler$3 {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height$3 {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum Type$3 {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
interface Styles$3 {
    /** Border attributes. */
    border?: Border$3;
    /** Color attributes. */
    colors?: Colors$3;
}
interface Link$3 extends LinkDataOneOf$3 {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: Target$3;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel$3;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf$3 {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target$3 {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
interface Rel$3 {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData$3 {
    /** Styling for the code block's text. */
    textStyle?: TextStyle$3;
}
interface TextStyle$3 {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignment$3;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment$3 {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
interface DividerData$3 {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData$3;
    /** Divider line style. */
    lineStyle?: LineStyle$3;
    /** Divider width. */
    width?: Width$3;
    /** Divider alignment. */
    alignment?: Alignment$3;
}
declare enum LineStyle$3 {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
declare enum Width$3 {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
declare enum Alignment$3 {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
interface FileData$3 {
    /** Styling for the file's container. */
    containerData?: PluginContainerData$3;
    /** The source for the file's data. */
    src?: FileSource$3;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings$3;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode$3 {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
interface FileSource$3 extends FileSourceDataOneOf$3 {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf$3 {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
}
interface PDFSettings$3 {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewMode$3;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData$3 {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData$3;
    /** The items in the gallery. */
    items?: Item$3[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions$3;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface Media$3 {
    /** The source for the media's data. */
    src?: FileSource$3;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface Image$3 {
    /** Image file details. */
    media?: Media$3;
    /** Link details for images that are links. */
    link?: Link$3;
}
interface Video$3 {
    /** Video file details. */
    media?: Media$3;
    /** Video thumbnail file details. */
    thumbnail?: Media$3;
}
interface Item$3 extends ItemDataOneOf$3 {
    /** An image item. */
    image?: Image$3;
    /** A video item. */
    video?: Video$3;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf$3 {
    /** An image item. */
    image?: Image$3;
    /** A video item. */
    video?: Video$3;
}
interface GalleryOptions$3 {
    /** Gallery layout. */
    layout?: Layout$3;
    /** Styling for gallery items. */
    item?: ItemStyle$3;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails$3;
}
declare enum LayoutType$3 {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
declare enum Orientation$3 {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
declare enum Crop$3 {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
declare enum ThumbnailsAlignment$3 {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
interface Layout$3 {
    /** Gallery layout type. */
    type?: LayoutType$3;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: Orientation$3;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle$3 {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: Crop$3;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails$3 {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignment$3;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData$3 {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData$3;
    /** The source of the full size GIF. */
    original?: GIF$3;
    /** The source of the downsized GIF. */
    downsized?: GIF$3;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
}
interface GIF$3 {
    /** GIF format URL. */
    gif?: string | null;
    /** MP4 format URL. */
    mp4?: string | null;
    /** Thumbnail URL. */
    still?: string | null;
}
interface HeadingData$3 {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle$3;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData$3 extends HTMLDataDataOneOf$3 {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. */
    containerData?: PluginContainerData$3;
    /** The type of HTML code. */
    source?: Source$3;
}
/** @oneof */
interface HTMLDataDataOneOf$3 {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source$3 {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
interface ImageData$3 {
    /** Styling for the image's container. */
    containerData?: PluginContainerData$3;
    /** Image file details. */
    image?: Media$3;
    /** Link details for images that are links. */
    link?: Link$3;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface LinkPreviewData$3 {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData$3;
    /** Link details. */
    link?: Link$3;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
}
interface MapData$3 {
    /** Styling for the map's container. */
    containerData?: PluginContainerData$3;
    /** Map settings. */
    mapSettings?: MapSettings$3;
}
interface MapSettings$3 {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapType$3;
}
declare enum MapType$3 {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
interface ParagraphData$3 {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle$3;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData$3 {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData$3;
    /** Poll data. */
    poll?: Poll$3;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout$3;
    /** Styling for the poll and voting options. */
    design?: Design$3;
}
declare enum ViewRole$3 {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
declare enum VoteRole$3 {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
interface Permissions$3 {
    /** Sets who can view the poll results. */
    view?: ViewRole$3;
    /** Sets who can vote. */
    vote?: VoteRole$3;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option$3 {
    /** Option ID. */
    id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: Media$3;
}
interface Settings$3 {
    /** Permissions settings for voting. */
    permissions?: Permissions$3;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType$3 {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
declare enum PollLayoutDirection$3 {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface PollLayout$3 {
    /** The layout for displaying the voting options. */
    type?: PollLayoutType$3;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirection$3;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout$3 {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType$3 {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
interface Gradient$3 {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /** The start color as a hexademical value. */
    startColor?: string | null;
    /** The end color as a hexademical value. */
    lastColor?: string | null;
}
interface Background$3 extends BackgroundBackgroundOneOf$3 {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media$3;
    /** Details for a gradient background. */
    gradient?: Gradient$3;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundType$3;
}
/** @oneof */
interface BackgroundBackgroundOneOf$3 {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media$3;
    /** Details for a gradient background. */
    gradient?: Gradient$3;
}
interface PollDesign$3 {
    /** Background styling. */
    background?: Background$3;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign$3 {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll$3 {
    /** Poll ID. */
    id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: Media$3;
    /** Voting options. */
    options?: Option$3[];
    /** The poll's permissions and display settings. */
    settings?: Settings$3;
}
interface PollDataLayout$3 {
    /** Poll layout settings. */
    poll?: PollLayout$3;
    /** Voting otpions layout settings. */
    options?: OptionLayout$3;
}
interface Design$3 {
    /** Styling for the poll. */
    poll?: PollDesign$3;
    /** Styling for voting options. */
    options?: OptionDesign$3;
}
interface TextData$3 {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration$3[];
}
/** Adds appearence changes to text */
interface Decoration$3 extends DecorationDataOneOf$3 {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData$3;
    /** Data for a color decoration. */
    colorData?: ColorData$3;
    /** Data for an external link decoration. */
    linkData?: LinkData$3;
    /** Data for a mention decoration. */
    mentionData?: MentionData$3;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData$3;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData$3;
    /** The type of decoration to apply. */
    type?: DecorationType$3;
}
/** @oneof */
interface DecorationDataOneOf$3 {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData$3;
    /** Data for a color decoration. */
    colorData?: ColorData$3;
    /** Data for an external link decoration. */
    linkData?: LinkData$3;
    /** Data for a mention decoration. */
    mentionData?: MentionData$3;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData$3;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData$3;
}
declare enum DecorationType$3 {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL"
}
interface AnchorData$3 {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData$3 {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData$3 {
    /** Link details. */
    link?: Link$3;
}
interface MentionData$3 {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    id?: string | null;
}
interface FontSizeData$3 {
    /** The units used for the font size. */
    unit?: FontType$3;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType$3 {
    PX = "PX",
    EM = "EM"
}
interface SpoilerData$3 {
    /** Spoiler ID. */
    id?: string | null;
}
interface AppEmbedData$3 extends AppEmbedDataAppDataOneOf$3 {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData$3;
    /** Data for embedded Wix Events content. */
    eventData?: EventData$3;
    /** The type of Wix App content being embedded. */
    type?: AppType$3;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: Media$3;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf$3 {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData$3;
    /** Data for embedded Wix Events content. */
    eventData?: EventData$3;
}
declare enum AppType$3 {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
interface BookingData$3 {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData$3 {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface VideoData$3 {
    /** Styling for the video's container. */
    containerData?: PluginContainerData$3;
    /** Video details. */
    video?: Media$3;
    /** Video thumbnail details. */
    thumbnail?: Media$3;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions$3;
}
interface PlaybackOptions$3 {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData$3 {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData$3;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed$3;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed$3 {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData$3 {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData$3;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItems$3;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: Direction$3;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems$3 {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
declare enum Direction$3 {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface TableData$3 {
    /** Styling for the table's container. */
    containerData?: PluginContainerData$3;
    /** The table's dimensions. */
    dimensions?: Dimensions$3;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions$3 {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData$3 {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle$3;
    /** The cell's border colors. */
    borderColors?: BorderColors$3;
}
declare enum VerticalAlignment$3 {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
interface CellStyle$3 {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignment$3;
    /** Cell background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface BorderColors$3 {
    /** Left border color as a hexadecimal value. */
    left?: string | null;
    /** Right border color as a hexadecimal value. */
    right?: string | null;
    /** Top border color as a hexadecimal value. */
    top?: string | null;
    /** Bottom border color as a hexadecimal value. */
    bottom?: string | null;
}
interface AudioData$3 {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData$3;
    /** Audio file details. */
    audio?: Media$3;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: Media$3;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData$3 {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData$3 {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData$3 {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData$3 {
    textStyle?: TextStyle$3;
}
interface Metadata$3 {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    id?: string | null;
}
interface DocumentStyle$3 {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle$3;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle$3;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle$3;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle$3;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle$3;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle$3;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle$3;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle$3;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle$3;
}
interface TextNodeStyle$3 {
    /** The decorations to apply to the node. */
    decorations?: Decoration$3[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle$3;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface CreateInfoSectionRequest$1 {
    /** Info section to create. */
    infoSection: InfoSection$3;
}
interface CreateInfoSectionResponse$1 {
    /** Created info section. */
    infoSection?: InfoSection$3;
}
interface GetInfoSectionRequest$1 {
    /** Info section ID. */
    infoSectionId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$5[];
}
declare enum RequestedFields$5 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetInfoSectionResponse$1 {
    /** Info section. */
    infoSection?: InfoSection$3;
}
interface GetOrCreateInfoSectionRequest$1 {
    /** Info section to retrieve or create. */
    infoSection?: InfoSectionForGetOrCreate$1;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$5[];
}
interface InfoSectionForGetOrCreate$1 {
    /**
     * Info section ID.
     * Pass an ID to retrieve an existing info section.
     */
    id?: string | null;
    /**
     * Info section unique name.
     *
     * > **Note:**
     * > + Pass the `uniqueName` of an existing info section to return it.
     * > + If no such info section exists - pass `uniqueName` and `title` to create an info section.
     */
    uniqueName?: string | null;
    /**
     * Info section title.
     *
     * Required when passing `uniqueName` to create a new info section.
     */
    title?: string | null;
    /**
     * Info section description using rich content.
     *
     * Learn more about [Working with Rich Content](https://dev.wix.com/docs/go-headless/tutorials-templates/other-tutorials/working-with-rich-content).
     */
    description?: RichContent$3;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
}
interface GetOrCreateInfoSectionResponse$1 {
    /** Info section. */
    infoSection?: InfoSection$3;
}
interface BulkGetOrCreateInfoSectionsRequest$1 {
    /** Info sections to retrieve or create. */
    infoSections?: InfoSectionForGetOrCreate$1[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$5[];
}
interface BulkGetOrCreateInfoSectionsResponse$1 {
    /** Info sections retrieved or created by bulk action. */
    results?: BulkInfoSectionItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$5;
}
interface BulkInfoSectionItemResult$1 {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata$5;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InfoSection$3;
}
interface ItemMetadata$5 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$7;
}
interface ApplicationError$7 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$5 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateInfoSectionRequest$1 {
    /** Info section to update. */
    infoSection: InfoSection$3;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$5[];
}
interface UpdateInfoSectionResponse$1 {
    /** Updated info section. */
    infoSection?: InfoSection$3;
}
interface DeleteInfoSectionRequest$1 {
    /** Info section ID */
    infoSectionId: string;
}
interface DeleteInfoSectionResponse$1 {
}
interface QueryInfoSectionsRequest$1 {
    /** Query options. */
    query?: CursorQuery$5;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$5[];
}
interface CursorQuery$5 extends CursorQueryPagingMethodOneOf$5 {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$7;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting$7[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$5 {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$7;
}
interface Sorting$7 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$7;
}
declare enum SortOrder$7 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$7 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryInfoSectionsResponse$1 {
    /** List of info sections. */
    infoSections?: InfoSection$3[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$7;
}
interface CursorPagingMetadata$7 {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$7;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$7 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateInfoSectionsRequest$1 {
    /** Info sections to create. */
    infoSections: InfoSection$3[];
    /**
     * Whether to return the full created info section entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInfoSectionsResponse$1 {
    /** Info sections created by bulk action. */
    results?: BulkInfoSectionItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$5;
}
interface BulkUpdateInfoSectionsRequest$1 {
    /** List of info sections to update. */
    infoSections: MaskedInfoSection$1[];
    /**
     * Whether to return the full updated info sections entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$5[];
}
interface MaskedInfoSection$1 {
    /** Info section to update. */
    infoSection?: InfoSection$3;
}
interface BulkUpdateInfoSectionsResponse$1 {
    /** Info sections updated by bulk action. */
    results?: BulkInfoSectionItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$5;
}
interface BulkDeleteInfoSectionsRequest$1 {
    /** IDs of info sections to delete. */
    infoSectionIds: string[];
}
interface BulkDeleteInfoSectionsResponse$1 {
    /** Info sections deleted by bulk action */
    results?: BulkInfoSectionResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$5;
}
interface BulkInfoSectionResult$1 {
    /** Bulk action metadata for info section. */
    itemMetadata?: ItemMetadata$5;
}
interface PluginContainerDataWidthNonNullableFields$3 {
    size: WidthType$3;
}
interface PluginContainerDataNonNullableFields$3 {
    width?: PluginContainerDataWidthNonNullableFields$3;
    alignment: PluginContainerDataAlignment$3;
}
interface LinkNonNullableFields$3 {
    url: string;
    anchor: string;
    target: Target$3;
}
interface ButtonDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    type: Type$3;
    link?: LinkNonNullableFields$3;
}
interface TextStyleNonNullableFields$3 {
    textAlignment: TextAlignment$3;
}
interface CodeBlockDataNonNullableFields$3 {
    textStyle?: TextStyleNonNullableFields$3;
}
interface DividerDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    lineStyle: LineStyle$3;
    width: Width$3;
    alignment: Alignment$3;
}
interface PDFSettingsNonNullableFields$3 {
    viewMode: ViewMode$3;
}
interface FileDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    pdfSettings?: PDFSettingsNonNullableFields$3;
}
interface ImageNonNullableFields$3 {
    link?: LinkNonNullableFields$3;
}
interface ItemNonNullableFields$3 {
    image?: ImageNonNullableFields$3;
}
interface LayoutNonNullableFields$3 {
    type: LayoutType$3;
    orientation: Orientation$3;
}
interface ItemStyleNonNullableFields$3 {
    crop: Crop$3;
}
interface ThumbnailsNonNullableFields$3 {
    placement: ThumbnailsAlignment$3;
}
interface GalleryOptionsNonNullableFields$3 {
    layout?: LayoutNonNullableFields$3;
    item?: ItemStyleNonNullableFields$3;
    thumbnails?: ThumbnailsNonNullableFields$3;
}
interface GalleryDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    items: ItemNonNullableFields$3[];
    options?: GalleryOptionsNonNullableFields$3;
}
interface GIFDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    height: number;
    width: number;
}
interface HeadingDataNonNullableFields$3 {
    level: number;
    textStyle?: TextStyleNonNullableFields$3;
}
interface HTMLDataNonNullableFields$3 {
    url: string;
    html: string;
    containerData?: PluginContainerDataNonNullableFields$3;
    source: Source$3;
}
interface ImageDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    link?: LinkNonNullableFields$3;
}
interface LinkPreviewDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    link?: LinkNonNullableFields$3;
}
interface MapSettingsNonNullableFields$3 {
    mapType: MapType$3;
}
interface MapDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    mapSettings?: MapSettingsNonNullableFields$3;
}
interface ParagraphDataNonNullableFields$3 {
    textStyle?: TextStyleNonNullableFields$3;
}
interface PermissionsNonNullableFields$3 {
    view: ViewRole$3;
    vote: VoteRole$3;
}
interface SettingsNonNullableFields$3 {
    permissions?: PermissionsNonNullableFields$3;
}
interface PollNonNullableFields$3 {
    settings?: SettingsNonNullableFields$3;
}
interface PollLayoutNonNullableFields$3 {
    type: PollLayoutType$3;
    direction: PollLayoutDirection$3;
}
interface PollDataLayoutNonNullableFields$3 {
    poll?: PollLayoutNonNullableFields$3;
}
interface BackgroundNonNullableFields$3 {
    type: BackgroundType$3;
}
interface PollDesignNonNullableFields$3 {
    background?: BackgroundNonNullableFields$3;
}
interface DesignNonNullableFields$3 {
    poll?: PollDesignNonNullableFields$3;
}
interface PollDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    poll?: PollNonNullableFields$3;
    layout?: PollDataLayoutNonNullableFields$3;
    design?: DesignNonNullableFields$3;
}
interface AnchorDataNonNullableFields$3 {
    anchor: string;
}
interface LinkDataNonNullableFields$3 {
    link?: LinkNonNullableFields$3;
}
interface MentionDataNonNullableFields$3 {
    name: string;
    slug: string;
}
interface FontSizeDataNonNullableFields$3 {
    unit: FontType$3;
}
interface DecorationNonNullableFields$3 {
    anchorData?: AnchorDataNonNullableFields$3;
    linkData?: LinkDataNonNullableFields$3;
    mentionData?: MentionDataNonNullableFields$3;
    fontSizeData?: FontSizeDataNonNullableFields$3;
    type: DecorationType$3;
}
interface TextDataNonNullableFields$3 {
    text: string;
    decorations: DecorationNonNullableFields$3[];
}
interface AppEmbedDataNonNullableFields$3 {
    type: AppType$3;
}
interface VideoDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
}
interface EmbedDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
}
interface CollapsibleListDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    initialExpandedItems: InitialExpandedItems$3;
    direction: Direction$3;
}
interface DimensionsNonNullableFields$3 {
    colsWidthRatio: number[];
    rowsHeight: number[];
    colsMinWidth: number[];
}
interface TableDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
    dimensions?: DimensionsNonNullableFields$3;
}
interface CellStyleNonNullableFields$3 {
    verticalAlignment: VerticalAlignment$3;
}
interface TableCellDataNonNullableFields$3 {
    cellStyle?: CellStyleNonNullableFields$3;
}
interface AudioDataNonNullableFields$3 {
    containerData?: PluginContainerDataNonNullableFields$3;
}
interface OrderedListDataNonNullableFields$3 {
    indentation: number;
}
interface BulletedListDataNonNullableFields$3 {
    indentation: number;
}
interface BlockquoteDataNonNullableFields$3 {
    indentation: number;
}
interface CaptionDataNonNullableFields$3 {
    textStyle?: TextStyleNonNullableFields$3;
}
interface NodeNonNullableFields$3 {
    buttonData?: ButtonDataNonNullableFields$3;
    codeBlockData?: CodeBlockDataNonNullableFields$3;
    dividerData?: DividerDataNonNullableFields$3;
    fileData?: FileDataNonNullableFields$3;
    galleryData?: GalleryDataNonNullableFields$3;
    gifData?: GIFDataNonNullableFields$3;
    headingData?: HeadingDataNonNullableFields$3;
    htmlData?: HTMLDataNonNullableFields$3;
    imageData?: ImageDataNonNullableFields$3;
    linkPreviewData?: LinkPreviewDataNonNullableFields$3;
    mapData?: MapDataNonNullableFields$3;
    paragraphData?: ParagraphDataNonNullableFields$3;
    pollData?: PollDataNonNullableFields$3;
    textData?: TextDataNonNullableFields$3;
    appEmbedData?: AppEmbedDataNonNullableFields$3;
    videoData?: VideoDataNonNullableFields$3;
    embedData?: EmbedDataNonNullableFields$3;
    collapsibleListData?: CollapsibleListDataNonNullableFields$3;
    tableData?: TableDataNonNullableFields$3;
    tableCellData?: TableCellDataNonNullableFields$3;
    audioData?: AudioDataNonNullableFields$3;
    orderedListData?: OrderedListDataNonNullableFields$3;
    bulletedListData?: BulletedListDataNonNullableFields$3;
    blockquoteData?: BlockquoteDataNonNullableFields$3;
    captionData?: CaptionDataNonNullableFields$3;
    type: NodeType$3;
    id: string;
    nodes: NodeNonNullableFields$3[];
}
interface MetadataNonNullableFields$3 {
    version: number;
}
interface TextNodeStyleNonNullableFields$3 {
    decorations: DecorationNonNullableFields$3[];
}
interface DocumentStyleNonNullableFields$3 {
    headerOne?: TextNodeStyleNonNullableFields$3;
    headerTwo?: TextNodeStyleNonNullableFields$3;
    headerThree?: TextNodeStyleNonNullableFields$3;
    headerFour?: TextNodeStyleNonNullableFields$3;
    headerFive?: TextNodeStyleNonNullableFields$3;
    headerSix?: TextNodeStyleNonNullableFields$3;
    paragraph?: TextNodeStyleNonNullableFields$3;
    blockquote?: TextNodeStyleNonNullableFields$3;
    codeBlock?: TextNodeStyleNonNullableFields$3;
}
interface RichContentNonNullableFields$3 {
    nodes: NodeNonNullableFields$3[];
    metadata?: MetadataNonNullableFields$3;
    documentStyle?: DocumentStyleNonNullableFields$3;
}
interface InfoSectionNonNullableFields$3 {
    uniqueName: string;
    title: string;
    description?: RichContentNonNullableFields$3;
}
interface CreateInfoSectionResponseNonNullableFields$1 {
    infoSection?: InfoSectionNonNullableFields$3;
}
interface GetInfoSectionResponseNonNullableFields$1 {
    infoSection?: InfoSectionNonNullableFields$3;
}
interface GetOrCreateInfoSectionResponseNonNullableFields$1 {
    infoSection?: InfoSectionNonNullableFields$3;
}
interface ApplicationErrorNonNullableFields$7 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$5 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$7;
}
interface BulkInfoSectionItemResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$5;
    item?: InfoSectionNonNullableFields$3;
}
interface BulkActionMetadataNonNullableFields$5 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkGetOrCreateInfoSectionsResponseNonNullableFields$1 {
    results: BulkInfoSectionItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$5;
}
interface UpdateInfoSectionResponseNonNullableFields$1 {
    infoSection?: InfoSectionNonNullableFields$3;
}
interface QueryInfoSectionsResponseNonNullableFields$1 {
    infoSections: InfoSectionNonNullableFields$3[];
}
interface BulkCreateInfoSectionsResponseNonNullableFields$1 {
    results: BulkInfoSectionItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$5;
}
interface BulkUpdateInfoSectionsResponseNonNullableFields$1 {
    results: BulkInfoSectionItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$5;
}
interface BulkInfoSectionResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$5;
}
interface BulkDeleteInfoSectionsResponseNonNullableFields$1 {
    results: BulkInfoSectionResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$5;
}

/**
 * An info section is a visible property of a product
 * Add info sections to a product to provide all the explanations your customers need.
 */
interface InfoSection$2 {
    /**
     * Info section ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the info section is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the info section.
     *
     * Ignored when creating an info section.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the info section was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the info section was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Unique name. Used as an identifier. */
    uniqueName?: string;
    /** Info section title. */
    title?: string;
    /**
     * Info section description using rich content.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    description?: RichContent$2;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
    /**
     * Number of products this info section is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCTS_COUNT"` to the `fields` array in Info Sections API requests.
     * @readonly
     */
    assignedProductsCount?: number | null;
}
interface RichContent$2 {
    /** Node objects representing a rich content document. */
    nodes?: Node$2[];
    /** Object metadata. */
    metadata?: Metadata$2;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle$2;
}
interface Node$2 extends NodeDataOneOf$2 {
    /** Data for a button node. */
    buttonData?: ButtonData$2;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData$2;
    /** Data for a divider node. */
    dividerData?: DividerData$2;
    /** Data for a file node. */
    fileData?: FileData$2;
    /** Data for a gallery node. */
    galleryData?: GalleryData$2;
    /** Data for a GIF node. */
    gifData?: GIFData$2;
    /** Data for a heading node. */
    headingData?: HeadingData$2;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData$2;
    /** Data for an image node. */
    imageData?: ImageData$2;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData$2;
    /** Data for a map node. */
    mapData?: MapData$2;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData$2;
    /** Data for a poll node. */
    pollData?: PollData$2;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData$2;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData$2;
    /** Data for a video node. */
    videoData?: VideoData$2;
    /** Data for an oEmbed node. */
    embedData?: EmbedData$2;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData$2;
    /** Data for a table node. */
    tableData?: TableData$2;
    /** Data for a table cell node. */
    tableCellData?: TableCellData$2;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData$2;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData$2;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData$2;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData$2;
    /** Data for a caption node. */
    captionData?: CaptionData$2;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeType$2;
    /** Node ID. */
    _id?: string;
    /** A list of child nodes. */
    nodes?: Node$2[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle$2;
}
/** @oneof */
interface NodeDataOneOf$2 {
    /** Data for a button node. */
    buttonData?: ButtonData$2;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData$2;
    /** Data for a divider node. */
    dividerData?: DividerData$2;
    /** Data for a file node. */
    fileData?: FileData$2;
    /** Data for a gallery node. */
    galleryData?: GalleryData$2;
    /** Data for a GIF node. */
    gifData?: GIFData$2;
    /** Data for a heading node. */
    headingData?: HeadingData$2;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData$2;
    /** Data for an image node. */
    imageData?: ImageData$2;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData$2;
    /** Data for a map node. */
    mapData?: MapData$2;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData$2;
    /** Data for a poll node. */
    pollData?: PollData$2;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData$2;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData$2;
    /** Data for a video node. */
    videoData?: VideoData$2;
    /** Data for an oEmbed node. */
    embedData?: EmbedData$2;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData$2;
    /** Data for a table node. */
    tableData?: TableData$2;
    /** Data for a table cell node. */
    tableCellData?: TableCellData$2;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData$2;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData$2;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData$2;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData$2;
    /** Data for a caption node. */
    captionData?: CaptionData$2;
}
declare enum NodeType$2 {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION"
}
interface NodeStyle$2 {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData$2 {
    /** Styling for the button's container. */
    containerData?: PluginContainerData$2;
    /** The button type. */
    type?: Type$2;
    /** Styling for the button. */
    styles?: Styles$2;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link$2;
}
interface Border$2 {
    /** Border width in pixels. */
    width?: number | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface Colors$2 {
    /** The text color as a hexadecimal value. */
    text?: string | null;
    /** The border color as a hexadecimal value. */
    border?: string | null;
    /** The background color as a hexadecimal value. */
    background?: string | null;
}
interface PluginContainerData$2 {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth$2;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignment$2;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler$2;
    /** The height of the node when it's displayed. */
    height?: Height$2;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType$2 {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
interface PluginContainerDataWidth$2 extends PluginContainerDataWidthDataOneOf$2 {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType$2;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf$2 {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType$2;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment$2 {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
interface Spoiler$2 {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height$2 {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum Type$2 {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
interface Styles$2 {
    /** Border attributes. */
    border?: Border$2;
    /** Color attributes. */
    colors?: Colors$2;
}
interface Link$2 extends LinkDataOneOf$2 {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: Target$2;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel$2;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf$2 {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target$2 {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
interface Rel$2 {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData$2 {
    /** Styling for the code block's text. */
    textStyle?: TextStyle$2;
}
interface TextStyle$2 {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignment$2;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment$2 {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
interface DividerData$2 {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData$2;
    /** Divider line style. */
    lineStyle?: LineStyle$2;
    /** Divider width. */
    width?: Width$2;
    /** Divider alignment. */
    alignment?: Alignment$2;
}
declare enum LineStyle$2 {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
declare enum Width$2 {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
declare enum Alignment$2 {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
interface FileData$2 {
    /** Styling for the file's container. */
    containerData?: PluginContainerData$2;
    /** The source for the file's data. */
    src?: FileSource$2;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings$2;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode$2 {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
interface FileSource$2 extends FileSourceDataOneOf$2 {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    _id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf$2 {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    _id?: string | null;
}
interface PDFSettings$2 {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewMode$2;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData$2 {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData$2;
    /** The items in the gallery. */
    items?: Item$2[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions$2;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface Media$2 {
    /** The source for the media's data. */
    src?: FileSource$2;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface Image$2 {
    /** Image file details. */
    media?: Media$2;
    /** Link details for images that are links. */
    link?: Link$2;
}
interface Video$2 {
    /** Video file details. */
    media?: Media$2;
    /** Video thumbnail file details. */
    thumbnail?: Media$2;
}
interface Item$2 extends ItemDataOneOf$2 {
    /** An image item. */
    image?: Image$2;
    /** A video item. */
    video?: Video$2;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf$2 {
    /** An image item. */
    image?: Image$2;
    /** A video item. */
    video?: Video$2;
}
interface GalleryOptions$2 {
    /** Gallery layout. */
    layout?: Layout$2;
    /** Styling for gallery items. */
    item?: ItemStyle$2;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails$2;
}
declare enum LayoutType$2 {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
declare enum Orientation$2 {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
declare enum Crop$2 {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
declare enum ThumbnailsAlignment$2 {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
interface Layout$2 {
    /** Gallery layout type. */
    type?: LayoutType$2;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: Orientation$2;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle$2 {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: Crop$2;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails$2 {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignment$2;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData$2 {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData$2;
    /** The source of the full size GIF. */
    original?: GIF$2;
    /** The source of the downsized GIF. */
    downsized?: GIF$2;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
}
interface GIF$2 {
    /** GIF format URL. */
    gif?: string | null;
    /** MP4 format URL. */
    mp4?: string | null;
    /** Thumbnail URL. */
    still?: string | null;
}
interface HeadingData$2 {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle$2;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData$2 extends HTMLDataDataOneOf$2 {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. */
    containerData?: PluginContainerData$2;
    /** The type of HTML code. */
    source?: Source$2;
}
/** @oneof */
interface HTMLDataDataOneOf$2 {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source$2 {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
interface ImageData$2 {
    /** Styling for the image's container. */
    containerData?: PluginContainerData$2;
    /** Image file details. */
    image?: Media$2;
    /** Link details for images that are links. */
    link?: Link$2;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface LinkPreviewData$2 {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData$2;
    /** Link details. */
    link?: Link$2;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
}
interface MapData$2 {
    /** Styling for the map's container. */
    containerData?: PluginContainerData$2;
    /** Map settings. */
    mapSettings?: MapSettings$2;
}
interface MapSettings$2 {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapType$2;
}
declare enum MapType$2 {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
interface ParagraphData$2 {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle$2;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData$2 {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData$2;
    /** Poll data. */
    poll?: Poll$2;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout$2;
    /** Styling for the poll and voting options. */
    design?: Design$2;
}
declare enum ViewRole$2 {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
declare enum VoteRole$2 {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
interface Permissions$2 {
    /** Sets who can view the poll results. */
    view?: ViewRole$2;
    /** Sets who can vote. */
    vote?: VoteRole$2;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option$2 {
    /** Option ID. */
    _id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: Media$2;
}
interface Settings$2 {
    /** Permissions settings for voting. */
    permissions?: Permissions$2;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType$2 {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
declare enum PollLayoutDirection$2 {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface PollLayout$2 {
    /** The layout for displaying the voting options. */
    type?: PollLayoutType$2;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirection$2;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout$2 {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType$2 {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
interface Gradient$2 {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /** The start color as a hexademical value. */
    startColor?: string | null;
    /** The end color as a hexademical value. */
    lastColor?: string | null;
}
interface Background$2 extends BackgroundBackgroundOneOf$2 {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media$2;
    /** Details for a gradient background. */
    gradient?: Gradient$2;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundType$2;
}
/** @oneof */
interface BackgroundBackgroundOneOf$2 {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: Media$2;
    /** Details for a gradient background. */
    gradient?: Gradient$2;
}
interface PollDesign$2 {
    /** Background styling. */
    background?: Background$2;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign$2 {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll$2 {
    /** Poll ID. */
    _id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: Media$2;
    /** Voting options. */
    options?: Option$2[];
    /** The poll's permissions and display settings. */
    settings?: Settings$2;
}
interface PollDataLayout$2 {
    /** Poll layout settings. */
    poll?: PollLayout$2;
    /** Voting otpions layout settings. */
    options?: OptionLayout$2;
}
interface Design$2 {
    /** Styling for the poll. */
    poll?: PollDesign$2;
    /** Styling for voting options. */
    options?: OptionDesign$2;
}
interface TextData$2 {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration$2[];
}
/** Adds appearence changes to text */
interface Decoration$2 extends DecorationDataOneOf$2 {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData$2;
    /** Data for a color decoration. */
    colorData?: ColorData$2;
    /** Data for an external link decoration. */
    linkData?: LinkData$2;
    /** Data for a mention decoration. */
    mentionData?: MentionData$2;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData$2;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData$2;
    /** The type of decoration to apply. */
    type?: DecorationType$2;
}
/** @oneof */
interface DecorationDataOneOf$2 {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData$2;
    /** Data for a color decoration. */
    colorData?: ColorData$2;
    /** Data for an external link decoration. */
    linkData?: LinkData$2;
    /** Data for a mention decoration. */
    mentionData?: MentionData$2;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData$2;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData$2;
}
declare enum DecorationType$2 {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL"
}
interface AnchorData$2 {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData$2 {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData$2 {
    /** Link details. */
    link?: Link$2;
}
interface MentionData$2 {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    _id?: string | null;
}
interface FontSizeData$2 {
    /** The units used for the font size. */
    unit?: FontType$2;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType$2 {
    PX = "PX",
    EM = "EM"
}
interface SpoilerData$2 {
    /** Spoiler ID. */
    _id?: string | null;
}
interface AppEmbedData$2 extends AppEmbedDataAppDataOneOf$2 {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData$2;
    /** Data for embedded Wix Events content. */
    eventData?: EventData$2;
    /** The type of Wix App content being embedded. */
    type?: AppType$2;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: Media$2;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf$2 {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData$2;
    /** Data for embedded Wix Events content. */
    eventData?: EventData$2;
}
declare enum AppType$2 {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
interface BookingData$2 {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData$2 {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface VideoData$2 {
    /** Styling for the video's container. */
    containerData?: PluginContainerData$2;
    /** Video details. */
    video?: Media$2;
    /** Video thumbnail details. */
    thumbnail?: Media$2;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions$2;
}
interface PlaybackOptions$2 {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData$2 {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData$2;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed$2;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed$2 {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData$2 {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData$2;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItems$2;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: Direction$2;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems$2 {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
declare enum Direction$2 {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface TableData$2 {
    /** Styling for the table's container. */
    containerData?: PluginContainerData$2;
    /** The table's dimensions. */
    dimensions?: Dimensions$2;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions$2 {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData$2 {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle$2;
    /** The cell's border colors. */
    borderColors?: BorderColors$2;
}
declare enum VerticalAlignment$2 {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
interface CellStyle$2 {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignment$2;
    /** Cell background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface BorderColors$2 {
    /** Left border color as a hexadecimal value. */
    left?: string | null;
    /** Right border color as a hexadecimal value. */
    right?: string | null;
    /** Top border color as a hexadecimal value. */
    top?: string | null;
    /** Bottom border color as a hexadecimal value. */
    bottom?: string | null;
}
interface AudioData$2 {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData$2;
    /** Audio file details. */
    audio?: Media$2;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: Media$2;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData$2 {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData$2 {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData$2 {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData$2 {
    textStyle?: TextStyle$2;
}
interface Metadata$2 {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    _id?: string | null;
}
interface DocumentStyle$2 {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle$2;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle$2;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle$2;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle$2;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle$2;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle$2;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle$2;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle$2;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle$2;
}
interface TextNodeStyle$2 {
    /** The decorations to apply to the node. */
    decorations?: Decoration$2[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle$2;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface CreateInfoSectionRequest {
    /** Info section to create. */
    infoSection: InfoSection$2;
}
interface CreateInfoSectionResponse {
    /** Created info section. */
    infoSection?: InfoSection$2;
}
interface GetInfoSectionRequest {
    /** Info section ID. */
    infoSectionId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$4[];
}
declare enum RequestedFields$4 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCTS_COUNT = "ASSIGNED_PRODUCTS_COUNT"
}
interface GetInfoSectionResponse {
    /** Info section. */
    infoSection?: InfoSection$2;
}
interface GetOrCreateInfoSectionRequest {
    /** Info section to retrieve or create. */
    infoSection?: InfoSectionForGetOrCreate;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$4[];
}
interface InfoSectionForGetOrCreate {
    /**
     * Info section ID.
     * Pass an ID to retrieve an existing info section.
     */
    _id?: string | null;
    /**
     * Info section unique name.
     *
     * > **Note:**
     * > + Pass the `uniqueName` of an existing info section to return it.
     * > + If no such info section exists - pass `uniqueName` and `title` to create an info section.
     */
    uniqueName?: string | null;
    /**
     * Info section title.
     *
     * Required when passing `uniqueName` to create a new info section.
     */
    title?: string | null;
    /**
     * Info section description using rich content.
     *
     * Learn more about [Working with Rich Content](https://dev.wix.com/docs/go-headless/tutorials-templates/other-tutorials/working-with-rich-content).
     */
    description?: RichContent$2;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     */
    plainDescription?: string | null;
}
interface GetOrCreateInfoSectionResponse {
    /** Info section. */
    infoSection?: InfoSection$2;
}
interface BulkGetOrCreateInfoSectionsRequest {
    /** Info sections to retrieve or create. */
    infoSections?: InfoSectionForGetOrCreate[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$4[];
}
interface BulkGetOrCreateInfoSectionsResponse {
    /** Info sections retrieved or created by bulk action. */
    results?: BulkInfoSectionItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$4;
}
interface BulkInfoSectionItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata$4;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InfoSection$2;
}
interface ItemMetadata$4 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$6;
}
interface ApplicationError$6 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$4 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateInfoSectionRequest {
    /** Info section to update. */
    infoSection: InfoSection$2;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$4[];
}
interface UpdateInfoSectionResponse {
    /** Updated info section. */
    infoSection?: InfoSection$2;
}
interface DeleteInfoSectionRequest {
    /** Info section ID */
    infoSectionId: string;
}
interface DeleteInfoSectionResponse {
}
interface QueryInfoSectionsRequest {
    /** Query options. */
    query?: CursorQuery$4;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$4[];
}
interface CursorQuery$4 extends CursorQueryPagingMethodOneOf$4 {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$6;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting$6[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$4 {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$6;
}
interface Sorting$6 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$6;
}
declare enum SortOrder$6 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$6 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryInfoSectionsResponse {
    /** List of info sections. */
    infoSections?: InfoSection$2[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$6;
}
interface CursorPagingMetadata$6 {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$6;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$6 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateInfoSectionsRequest {
    /** Info sections to create. */
    infoSections: InfoSection$2[];
    /**
     * Whether to return the full created info section entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInfoSectionsResponse {
    /** Info sections created by bulk action. */
    results?: BulkInfoSectionItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$4;
}
interface BulkUpdateInfoSectionsRequest {
    /** List of info sections to update. */
    infoSections: MaskedInfoSection[];
    /**
     * Whether to return the full updated info sections entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$4[];
}
interface MaskedInfoSection {
    /** Info section to update. */
    infoSection?: InfoSection$2;
}
interface BulkUpdateInfoSectionsResponse {
    /** Info sections updated by bulk action. */
    results?: BulkInfoSectionItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$4;
}
interface BulkDeleteInfoSectionsRequest {
    /** IDs of info sections to delete. */
    infoSectionIds: string[];
}
interface BulkDeleteInfoSectionsResponse {
    /** Info sections deleted by bulk action */
    results?: BulkInfoSectionResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$4;
}
interface BulkInfoSectionResult {
    /** Bulk action metadata for info section. */
    itemMetadata?: ItemMetadata$4;
}
interface PluginContainerDataWidthNonNullableFields$2 {
    size: WidthType$2;
}
interface PluginContainerDataNonNullableFields$2 {
    width?: PluginContainerDataWidthNonNullableFields$2;
    alignment: PluginContainerDataAlignment$2;
}
interface LinkNonNullableFields$2 {
    url: string;
    anchor: string;
    target: Target$2;
}
interface ButtonDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    type: Type$2;
    link?: LinkNonNullableFields$2;
}
interface TextStyleNonNullableFields$2 {
    textAlignment: TextAlignment$2;
}
interface CodeBlockDataNonNullableFields$2 {
    textStyle?: TextStyleNonNullableFields$2;
}
interface DividerDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    lineStyle: LineStyle$2;
    width: Width$2;
    alignment: Alignment$2;
}
interface PDFSettingsNonNullableFields$2 {
    viewMode: ViewMode$2;
}
interface FileDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    pdfSettings?: PDFSettingsNonNullableFields$2;
}
interface ImageNonNullableFields$2 {
    link?: LinkNonNullableFields$2;
}
interface ItemNonNullableFields$2 {
    image?: ImageNonNullableFields$2;
}
interface LayoutNonNullableFields$2 {
    type: LayoutType$2;
    orientation: Orientation$2;
}
interface ItemStyleNonNullableFields$2 {
    crop: Crop$2;
}
interface ThumbnailsNonNullableFields$2 {
    placement: ThumbnailsAlignment$2;
}
interface GalleryOptionsNonNullableFields$2 {
    layout?: LayoutNonNullableFields$2;
    item?: ItemStyleNonNullableFields$2;
    thumbnails?: ThumbnailsNonNullableFields$2;
}
interface GalleryDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    items: ItemNonNullableFields$2[];
    options?: GalleryOptionsNonNullableFields$2;
}
interface GIFDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    height: number;
    width: number;
}
interface HeadingDataNonNullableFields$2 {
    level: number;
    textStyle?: TextStyleNonNullableFields$2;
}
interface HTMLDataNonNullableFields$2 {
    url: string;
    html: string;
    containerData?: PluginContainerDataNonNullableFields$2;
    source: Source$2;
}
interface ImageDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    link?: LinkNonNullableFields$2;
}
interface LinkPreviewDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    link?: LinkNonNullableFields$2;
}
interface MapSettingsNonNullableFields$2 {
    mapType: MapType$2;
}
interface MapDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    mapSettings?: MapSettingsNonNullableFields$2;
}
interface ParagraphDataNonNullableFields$2 {
    textStyle?: TextStyleNonNullableFields$2;
}
interface PermissionsNonNullableFields$2 {
    view: ViewRole$2;
    vote: VoteRole$2;
}
interface SettingsNonNullableFields$2 {
    permissions?: PermissionsNonNullableFields$2;
}
interface PollNonNullableFields$2 {
    settings?: SettingsNonNullableFields$2;
}
interface PollLayoutNonNullableFields$2 {
    type: PollLayoutType$2;
    direction: PollLayoutDirection$2;
}
interface PollDataLayoutNonNullableFields$2 {
    poll?: PollLayoutNonNullableFields$2;
}
interface BackgroundNonNullableFields$2 {
    type: BackgroundType$2;
}
interface PollDesignNonNullableFields$2 {
    background?: BackgroundNonNullableFields$2;
}
interface DesignNonNullableFields$2 {
    poll?: PollDesignNonNullableFields$2;
}
interface PollDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    poll?: PollNonNullableFields$2;
    layout?: PollDataLayoutNonNullableFields$2;
    design?: DesignNonNullableFields$2;
}
interface AnchorDataNonNullableFields$2 {
    anchor: string;
}
interface LinkDataNonNullableFields$2 {
    link?: LinkNonNullableFields$2;
}
interface MentionDataNonNullableFields$2 {
    name: string;
    slug: string;
}
interface FontSizeDataNonNullableFields$2 {
    unit: FontType$2;
}
interface DecorationNonNullableFields$2 {
    anchorData?: AnchorDataNonNullableFields$2;
    linkData?: LinkDataNonNullableFields$2;
    mentionData?: MentionDataNonNullableFields$2;
    fontSizeData?: FontSizeDataNonNullableFields$2;
    type: DecorationType$2;
}
interface TextDataNonNullableFields$2 {
    text: string;
    decorations: DecorationNonNullableFields$2[];
}
interface AppEmbedDataNonNullableFields$2 {
    type: AppType$2;
}
interface VideoDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
}
interface EmbedDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
}
interface CollapsibleListDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    initialExpandedItems: InitialExpandedItems$2;
    direction: Direction$2;
}
interface DimensionsNonNullableFields$2 {
    colsWidthRatio: number[];
    rowsHeight: number[];
    colsMinWidth: number[];
}
interface TableDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
    dimensions?: DimensionsNonNullableFields$2;
}
interface CellStyleNonNullableFields$2 {
    verticalAlignment: VerticalAlignment$2;
}
interface TableCellDataNonNullableFields$2 {
    cellStyle?: CellStyleNonNullableFields$2;
}
interface AudioDataNonNullableFields$2 {
    containerData?: PluginContainerDataNonNullableFields$2;
}
interface OrderedListDataNonNullableFields$2 {
    indentation: number;
}
interface BulletedListDataNonNullableFields$2 {
    indentation: number;
}
interface BlockquoteDataNonNullableFields$2 {
    indentation: number;
}
interface CaptionDataNonNullableFields$2 {
    textStyle?: TextStyleNonNullableFields$2;
}
interface NodeNonNullableFields$2 {
    buttonData?: ButtonDataNonNullableFields$2;
    codeBlockData?: CodeBlockDataNonNullableFields$2;
    dividerData?: DividerDataNonNullableFields$2;
    fileData?: FileDataNonNullableFields$2;
    galleryData?: GalleryDataNonNullableFields$2;
    gifData?: GIFDataNonNullableFields$2;
    headingData?: HeadingDataNonNullableFields$2;
    htmlData?: HTMLDataNonNullableFields$2;
    imageData?: ImageDataNonNullableFields$2;
    linkPreviewData?: LinkPreviewDataNonNullableFields$2;
    mapData?: MapDataNonNullableFields$2;
    paragraphData?: ParagraphDataNonNullableFields$2;
    pollData?: PollDataNonNullableFields$2;
    textData?: TextDataNonNullableFields$2;
    appEmbedData?: AppEmbedDataNonNullableFields$2;
    videoData?: VideoDataNonNullableFields$2;
    embedData?: EmbedDataNonNullableFields$2;
    collapsibleListData?: CollapsibleListDataNonNullableFields$2;
    tableData?: TableDataNonNullableFields$2;
    tableCellData?: TableCellDataNonNullableFields$2;
    audioData?: AudioDataNonNullableFields$2;
    orderedListData?: OrderedListDataNonNullableFields$2;
    bulletedListData?: BulletedListDataNonNullableFields$2;
    blockquoteData?: BlockquoteDataNonNullableFields$2;
    captionData?: CaptionDataNonNullableFields$2;
    type: NodeType$2;
    _id: string;
    nodes: NodeNonNullableFields$2[];
}
interface MetadataNonNullableFields$2 {
    version: number;
}
interface TextNodeStyleNonNullableFields$2 {
    decorations: DecorationNonNullableFields$2[];
}
interface DocumentStyleNonNullableFields$2 {
    headerOne?: TextNodeStyleNonNullableFields$2;
    headerTwo?: TextNodeStyleNonNullableFields$2;
    headerThree?: TextNodeStyleNonNullableFields$2;
    headerFour?: TextNodeStyleNonNullableFields$2;
    headerFive?: TextNodeStyleNonNullableFields$2;
    headerSix?: TextNodeStyleNonNullableFields$2;
    paragraph?: TextNodeStyleNonNullableFields$2;
    blockquote?: TextNodeStyleNonNullableFields$2;
    codeBlock?: TextNodeStyleNonNullableFields$2;
}
interface RichContentNonNullableFields$2 {
    nodes: NodeNonNullableFields$2[];
    metadata?: MetadataNonNullableFields$2;
    documentStyle?: DocumentStyleNonNullableFields$2;
}
interface InfoSectionNonNullableFields$2 {
    uniqueName: string;
    title: string;
    description?: RichContentNonNullableFields$2;
}
interface CreateInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields$2;
}
interface GetInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields$2;
}
interface GetOrCreateInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields$2;
}
interface ApplicationErrorNonNullableFields$6 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$4 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$6;
}
interface BulkInfoSectionItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$4;
    item?: InfoSectionNonNullableFields$2;
}
interface BulkActionMetadataNonNullableFields$4 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkGetOrCreateInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$4;
}
interface UpdateInfoSectionResponseNonNullableFields {
    infoSection?: InfoSectionNonNullableFields$2;
}
interface QueryInfoSectionsResponseNonNullableFields {
    infoSections: InfoSectionNonNullableFields$2[];
}
interface BulkCreateInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$4;
}
interface BulkUpdateInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$4;
}
interface BulkInfoSectionResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$4;
}
interface BulkDeleteInfoSectionsResponseNonNullableFields {
    results: BulkInfoSectionResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$4;
}

type __PublicMethodMetaInfo$7<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createInfoSection(): __PublicMethodMetaInfo$7<'POST', {}, CreateInfoSectionRequest, CreateInfoSectionRequest$1, CreateInfoSectionResponse & CreateInfoSectionResponseNonNullableFields, CreateInfoSectionResponse$1 & CreateInfoSectionResponseNonNullableFields$1>;
declare function getInfoSection(): __PublicMethodMetaInfo$7<'GET', {
    infoSectionId: string;
}, GetInfoSectionRequest, GetInfoSectionRequest$1, GetInfoSectionResponse & GetInfoSectionResponseNonNullableFields, GetInfoSectionResponse$1 & GetInfoSectionResponseNonNullableFields$1>;
declare function getOrCreateInfoSection(): __PublicMethodMetaInfo$7<'POST', {}, GetOrCreateInfoSectionRequest, GetOrCreateInfoSectionRequest$1, GetOrCreateInfoSectionResponse & GetOrCreateInfoSectionResponseNonNullableFields, GetOrCreateInfoSectionResponse$1 & GetOrCreateInfoSectionResponseNonNullableFields$1>;
declare function bulkGetOrCreateInfoSections(): __PublicMethodMetaInfo$7<'POST', {}, BulkGetOrCreateInfoSectionsRequest, BulkGetOrCreateInfoSectionsRequest$1, BulkGetOrCreateInfoSectionsResponse & BulkGetOrCreateInfoSectionsResponseNonNullableFields, BulkGetOrCreateInfoSectionsResponse$1 & BulkGetOrCreateInfoSectionsResponseNonNullableFields$1>;
declare function updateInfoSection(): __PublicMethodMetaInfo$7<'PATCH', {
    infoSectionId: string;
}, UpdateInfoSectionRequest, UpdateInfoSectionRequest$1, UpdateInfoSectionResponse & UpdateInfoSectionResponseNonNullableFields, UpdateInfoSectionResponse$1 & UpdateInfoSectionResponseNonNullableFields$1>;
declare function deleteInfoSection(): __PublicMethodMetaInfo$7<'DELETE', {
    infoSectionId: string;
}, DeleteInfoSectionRequest, DeleteInfoSectionRequest$1, DeleteInfoSectionResponse, DeleteInfoSectionResponse$1>;
declare function queryInfoSections(): __PublicMethodMetaInfo$7<'POST', {}, QueryInfoSectionsRequest, QueryInfoSectionsRequest$1, QueryInfoSectionsResponse & QueryInfoSectionsResponseNonNullableFields, QueryInfoSectionsResponse$1 & QueryInfoSectionsResponseNonNullableFields$1>;
declare function bulkCreateInfoSections(): __PublicMethodMetaInfo$7<'POST', {}, BulkCreateInfoSectionsRequest, BulkCreateInfoSectionsRequest$1, BulkCreateInfoSectionsResponse & BulkCreateInfoSectionsResponseNonNullableFields, BulkCreateInfoSectionsResponse$1 & BulkCreateInfoSectionsResponseNonNullableFields$1>;
declare function bulkUpdateInfoSections(): __PublicMethodMetaInfo$7<'POST', {}, BulkUpdateInfoSectionsRequest, BulkUpdateInfoSectionsRequest$1, BulkUpdateInfoSectionsResponse & BulkUpdateInfoSectionsResponseNonNullableFields, BulkUpdateInfoSectionsResponse$1 & BulkUpdateInfoSectionsResponseNonNullableFields$1>;
declare function bulkDeleteInfoSections(): __PublicMethodMetaInfo$7<'POST', {}, BulkDeleteInfoSectionsRequest, BulkDeleteInfoSectionsRequest$1, BulkDeleteInfoSectionsResponse & BulkDeleteInfoSectionsResponseNonNullableFields, BulkDeleteInfoSectionsResponse$1 & BulkDeleteInfoSectionsResponseNonNullableFields$1>;

declare const meta$7_bulkCreateInfoSections: typeof bulkCreateInfoSections;
declare const meta$7_bulkDeleteInfoSections: typeof bulkDeleteInfoSections;
declare const meta$7_bulkGetOrCreateInfoSections: typeof bulkGetOrCreateInfoSections;
declare const meta$7_bulkUpdateInfoSections: typeof bulkUpdateInfoSections;
declare const meta$7_createInfoSection: typeof createInfoSection;
declare const meta$7_deleteInfoSection: typeof deleteInfoSection;
declare const meta$7_getInfoSection: typeof getInfoSection;
declare const meta$7_getOrCreateInfoSection: typeof getOrCreateInfoSection;
declare const meta$7_queryInfoSections: typeof queryInfoSections;
declare const meta$7_updateInfoSection: typeof updateInfoSection;
declare namespace meta$7 {
  export { type __PublicMethodMetaInfo$7 as __PublicMethodMetaInfo, meta$7_bulkCreateInfoSections as bulkCreateInfoSections, meta$7_bulkDeleteInfoSections as bulkDeleteInfoSections, meta$7_bulkGetOrCreateInfoSections as bulkGetOrCreateInfoSections, meta$7_bulkUpdateInfoSections as bulkUpdateInfoSections, meta$7_createInfoSection as createInfoSection, meta$7_deleteInfoSection as deleteInfoSection, meta$7_getInfoSection as getInfoSection, meta$7_getOrCreateInfoSection as getOrCreateInfoSection, meta$7_queryInfoSections as queryInfoSections, meta$7_updateInfoSection as updateInfoSection };
}

/** Inventory Item. */
interface InventoryItem$3 extends InventoryItemTrackingMethodOneOf$3 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus$3;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo$5;
    /**
     * Product.
     * @readonly
     */
    product?: Product$3;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields$3;
}
/** @oneof */
interface InventoryItemTrackingMethodOneOf$3 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
declare enum AvailabilityStatus$3 {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    IN_STOCK = "IN_STOCK",
    /**
     * Whether the variant is available for preorder. InventoryItem will be available only when all below conditions are met:
     * 1. the variant is out of stock
     * 2. preorder is enabled on inventory item level (preorder_setting.enabled is true)
     * 3. preorder limit wasn't reached (preorder_setting.limit)
     */
    PREORDER = "PREORDER"
}
interface PreorderInfo$5 {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /** A message the customer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
interface Product$3 {
    /** Product name. */
    name?: string | null;
    /** List of category IDs that this product is included in directly. */
    directCategoryIds?: string[];
    /** Variant name. */
    variantName?: string | null;
    /** Variant SKU (stock keeping unit). */
    variantSku?: string | null;
}
interface ExtendedFields$3 {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface CreateInventoryItemRequest$1 {
    /** Inventory item to create. */
    inventoryItem: InventoryItem$3;
}
interface CreateInventoryItemResponse$1 {
    /** Created inventory item. */
    inventoryItem?: InventoryItem$3;
}
interface BulkCreateInventoryItemsRequest$1 {
    /** Inventory items to create. */
    inventoryItems: InventoryItem$3[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInventoryItemsResponse$1 {
    /** Inventory items created by bulk action. */
    results?: V3BulkInventoryItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface V3BulkInventoryItemResult$1 {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata$3;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem$3;
}
interface ItemMetadata$3 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$5;
}
interface ApplicationError$5 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$3 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface GetInventoryItemRequest$1 {
    /** Inventory item ID. */
    inventoryItemId: string;
}
interface GetInventoryItemResponse$1 {
    /** Inventory item. */
    inventoryItem?: InventoryItem$3;
}
interface UpdateInventoryItemRequest$1 {
    /** Inventory item to update. */
    inventoryItem: InventoryItem$3;
    /** Reason for update. */
    reason?: ReasonType$1;
}
/** The reason for the inventory change. */
declare enum ReasonType$1 {
    UNKNOWN = "UNKNOWN",
    ORDER = "ORDER",
    MANUAL = "MANUAL",
    REVERT_INVENTORY_CHANGE = "REVERT_INVENTORY_CHANGE"
}
interface UpdateInventoryItemResponse$1 {
    /** Updated inventory item. */
    inventoryItem?: InventoryItem$3;
}
interface BulkUpdateInventoryItemsRequest$1 {
    /** Inventory items to update. */
    inventoryItems: MaskedInventoryItem$1[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonType$1;
}
interface MaskedInventoryItem$1 {
    /** Inventory item to update. */
    inventoryItem?: InventoryItem$3;
}
interface BulkUpdateInventoryItemsResponse$1 {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface BulkUpdateInventoryItemsByFilterRequest$1 {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Inventory item to update. */
    inventoryItem: InventoryItem$3;
    /** Free text to match in searchable fields. */
    search?: SearchDetails$1;
}
interface SearchDetails$1 {
    /** Defines how separate search terms in `expression` are combined. */
    mode?: Mode$1;
    /** Search term or expression. */
    expression?: string | null;
    /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path. */
    fields?: string[];
    /** Whether to use auto fuzzy search (allowing typos by a managed proximity algorithm). */
    fuzzy?: boolean;
}
declare enum Mode$1 {
    /** Any of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
interface BulkUpdateInventoryItemsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     */
    jobId?: string;
}
interface DeleteInventoryItemRequest$1 {
    /** Inventory item ID. */
    inventoryItemId: string;
}
interface DeleteInventoryItemResponse$1 {
}
interface BulkDeleteInventoryItemsRequest$1 {
    /** IDs of inventory items to delete. */
    inventoryItemIds: string[];
}
interface BulkDeleteInventoryItemsResponse$1 {
    /** Inventory items deleted by bulk action. */
    results?: BulkInventoryItemResult$3[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface BulkInventoryItemResult$3 {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata$3;
}
interface QueryInventoryItemsRequest$1 {
    /** Query options. */
    query?: InventoryQuery$1;
}
interface InventoryQuery$1 extends InventoryQueryPagingMethodOneOf$1 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: InventoryPaging$1;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: InventoryCursorPaging$1;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$5[];
}
/** @oneof */
interface InventoryQueryPagingMethodOneOf$1 {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: InventoryPaging$1;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: InventoryCursorPaging$1;
}
interface Sorting$5 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$5;
}
declare enum SortOrder$5 {
    ASC = "ASC",
    DESC = "DESC"
}
interface InventoryPaging$1 {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface InventoryCursorPaging$1 {
    /**
     * Number of items to load.
     * Cursor token returned in the query response. To be used on the next query request, but not the first query request.
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryInventoryItemsResponse$1 {
    /** List of inventory items. */
    inventoryItems?: InventoryItem$3[];
    /** Paging metadata. */
    pagingMetadata?: PlatformPagingMetadataV2$1;
}
interface PlatformPagingMetadataV2$1 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$5;
}
interface Cursors$5 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface SearchInventoryItemsRequest$1 {
    /** Search options. */
    search?: CursorSearch$1;
}
interface CursorSearch$1 extends CursorSearchPagingMethodOneOf$1 {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$5;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * List of sort objects.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting$5[];
    /** Aggregations are a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: Aggregation$1[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails$1;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome.
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. For example, `"2023-12-20T10:52:34.795Z"`.
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf$1 {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$5;
}
interface Aggregation$1 extends AggregationKindOneOf$1 {
    /** Value aggregation. */
    value?: ValueAggregation$1;
    /** Range aggregation. */
    range?: RangeAggregation$1;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation$1;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation$1;
    /** Nested aggregation. */
    nested?: NestedAggregation$1;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: AggregationType$1;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
    /**
     * Deprecated. Use `nested` instead.
     * @deprecated Deprecated. Use `nested` instead.
     * @replacedBy kind.nested
     * @targetRemovalDate 2024-03-30
     */
    groupBy?: GroupByAggregation$1;
}
/** @oneof */
interface AggregationKindOneOf$1 {
    /** Value aggregation. */
    value?: ValueAggregation$1;
    /** Range aggregation. */
    range?: RangeAggregation$1;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation$1;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation$1;
    /** Nested aggregation. */
    nested?: NestedAggregation$1;
}
interface RangeBucket$1 {
    /** Inclusive lower bound of the range. Required if `to` is not provided. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` is not provided. */
    to?: number | null;
}
declare enum SortType$1 {
    /** Sort by number of matches. */
    COUNT = "COUNT",
    /** Sort by value of the field alphabetically. */
    VALUE = "VALUE"
}
declare enum SortDirection$1 {
    /** Sort in descending order. */
    DESC = "DESC",
    /** Sort in ascending order. */
    ASC = "ASC"
}
declare enum MissingValues$1 {
    /** Exclude missing values from the aggregation results. */
    EXCLUDE = "EXCLUDE",
    /** Include missing values in the aggregation results. */
    INCLUDE = "INCLUDE"
}
interface IncludeMissingValuesOptions$1 {
    /** Specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
    addToBucket?: string;
}
declare enum ScalarType$1 {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX",
    /** Sum of values. */
    SUM = "SUM",
    /** Average of values. */
    AVG = "AVG"
}
interface ValueAggregation$1 extends ValueAggregationOptionsOneOf$1 {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions$1;
    /** Whether to sort by number of matches or value of the field. */
    sortType?: SortType$1;
    /** Whether to sort in ascending or descending order. */
    sortDirection?: SortDirection$1;
    /** How many aggregations to return. Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Whether to include or exclude missing values from the aggregation results. Default: `EXCLUDE`. */
    missingValues?: MissingValues$1;
}
/** @oneof */
interface ValueAggregationOptionsOneOf$1 {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions$1;
}
declare enum NestedAggregationType$1 {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
interface RangeAggregation$1 {
    /** List of range buckets, where during aggregation each entity will be placed in the first bucket its value falls into, based on the provided range bounds. */
    buckets?: RangeBucket$1[];
}
interface ScalarAggregation$1 {
    /** Define the operator for the scalar aggregation. */
    type?: ScalarType$1;
}
interface DateHistogramAggregation$1 {
    /** Interval for date histogram aggregation. */
    interval?: Interval$1;
}
declare enum Interval$1 {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
interface NestedAggregationItem$1 extends NestedAggregationItemKindOneOf$1 {
    /** Value aggregation. */
    value?: ValueAggregation$1;
    /** Range aggregation. */
    range?: RangeAggregation$1;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation$1;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation$1;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: NestedAggregationType$1;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf$1 {
    /** Value aggregation. */
    value?: ValueAggregation$1;
    /** Range aggregation. */
    range?: RangeAggregation$1;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation$1;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation$1;
}
declare enum AggregationType$1 {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one. */
    NESTED = "NESTED"
}
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one. */
interface NestedAggregation$1 {
    /** Flattened list of aggregations, where each next aggregation is nested within previous one. */
    nestedAggregations?: NestedAggregationItem$1[];
}
interface GroupByAggregation$1 extends GroupByAggregationKindOneOf$1 {
    /** Value aggregation configuration. */
    value?: ValueAggregation$1;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Field to aggregate by. */
    fieldPath?: string;
}
/** @oneof */
interface GroupByAggregationKindOneOf$1 {
    /** Value aggregation configuration. */
    value?: ValueAggregation$1;
}
interface CursorPaging$5 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface SearchInventoryItemsResponse$1 {
    /** List of inventory items. */
    inventoryItems?: InventoryItem$3[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata$5;
    /** Aggregation data. */
    aggregationData?: AggregationData$1;
}
interface CursorPagingMetadata$5 {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$5;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface AggregationData$1 {
    /** key = aggregation name (as derived from search request). */
    results?: AggregationResults$1[];
}
interface ValueAggregationResult$1 {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number;
}
interface RangeAggregationResult$1 {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number;
}
interface NestedAggregationResults$1 extends NestedAggregationResultsResultOneOf$1 {
    /** Value aggregation results. */
    values?: ValueResults$1;
    /** Range aggregation results. */
    ranges?: RangeResults$1;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult$1;
    /** User-defined name of aggregation, matches the one provided in request. */
    name?: string;
    /** Type of aggregation that matches result. */
    type?: AggregationType$1;
    /** Field to aggregate by, matches the one provided in request. */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationResultsResultOneOf$1 {
    /** Value aggregation results. */
    values?: ValueResults$1;
    /** Range aggregation results. */
    ranges?: RangeResults$1;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult$1;
}
interface ValueResults$1 {
    /** List of value aggregations. */
    results?: ValueAggregationResult$1[];
}
interface RangeResults$1 {
    /** List of ranges returned in same order as requested. */
    results?: RangeAggregationResult$1[];
}
interface AggregationResultsScalarResult$1 {
    /** Type of scalar aggregation. */
    type?: ScalarType$1;
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedValueAggregationResult$1 {
    /** Value of the field. */
    value?: string;
    /** Nested aggregations. */
    nestedResults?: NestedAggregationResults$1;
}
interface ValueResult$1 {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number | null;
}
interface RangeResult$1 {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number | null;
}
interface ScalarResult$1 {
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedResultValue$1 extends NestedResultValueResultOneOf$1 {
    /** Value aggregation result. */
    value?: ValueResult$1;
    /** Range aggregation result. */
    range?: RangeResult$1;
    /** Scalar aggregation result. */
    scalar?: ScalarResult$1;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult$1;
}
/** @oneof */
interface NestedResultValueResultOneOf$1 {
    /** Value aggregation result. */
    value?: ValueResult$1;
    /** Range aggregation result. */
    range?: RangeResult$1;
    /** Scalar aggregation result. */
    scalar?: ScalarResult$1;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult$1;
}
interface Results$1 {
    /** List of nested aggregations. */
    results?: Record<string, NestedResultValue$1>;
}
interface DateHistogramResult$1 {
    /** Date in ISO 8601 format. */
    value?: string;
    /** Count of documents in the bucket. */
    count?: number;
}
interface GroupByValueResults$1 {
    /** List of value aggregations. */
    results?: NestedValueAggregationResult$1[];
}
interface DateHistogramResults$1 {
    /** List of date histogram aggregations. */
    results?: DateHistogramResult$1[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form.
 * Aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface NestedResults$1 {
    /** List of nested aggregations. */
    results?: Results$1[];
}
interface AggregationResults$1 extends AggregationResultsResultOneOf$1 {
    /** Value aggregation results. */
    values?: ValueResults$1;
    /** Range aggregation results. */
    ranges?: RangeResults$1;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult$1;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults$1;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults$1;
    /** Nested aggregation results. */
    nested?: NestedResults$1;
    /** User-defined name of aggregation as derived from search request. */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request. */
    type?: AggregationType$1;
    /** Field to aggregate by as derived from search request. */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsResultOneOf$1 {
    /** Value aggregation results. */
    values?: ValueResults$1;
    /** Range aggregation results. */
    ranges?: RangeResults$1;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult$1;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults$1;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults$1;
    /** Nested aggregation results. */
    nested?: NestedResults$1;
}
interface BulkDecrementInventoryItemsRequest$1 {
    /** Inventory item IDs and decrement data. */
    decrementData: DecrementDataById$1[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType$1;
}
interface DecrementDataById$1 {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsResponse$1 {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface BulkIncrementInventoryItemsRequest$1 {
    /** Inventory item IDs and increment data. */
    incrementData: IncrementDataById$1[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType$1;
}
interface IncrementDataById$1 {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to increment by. */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsResponse$1 {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface BulkDecrementInventoryItemsByVariantAndLocationRequest$1 {
    /** Variant and location IDs, as well as decrement data. */
    decrementData: DecrementDataByVariantAndLocation$1[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType$1;
}
interface DecrementDataByVariantAndLocation$1 {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponse$1 {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface BulkIncrementInventoryItemsByVariantAndLocationRequest$1 {
    /** Variant and location IDs, as well as increment data. */
    incrementData: IncrementDataByVariantAndLocation$1[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType$1;
}
interface IncrementDataByVariantAndLocation$1 {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to increment by. */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponse$1 {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult$1[];
    /** Bulk action metadata details as: totalSuccess and totalFailure. */
    bulkActionMetadata?: BulkActionMetadata$3;
}
interface ProductNonNullableFields$3 {
    directCategoryIds: string[];
}
interface InventoryItemNonNullableFields$3 {
    inStock: boolean;
    quantity: number;
    variantId: string;
    productId: string;
    trackQuantity: boolean;
    availabilityStatus: AvailabilityStatus$3;
    product?: ProductNonNullableFields$3;
}
interface CreateInventoryItemResponseNonNullableFields$1 {
    inventoryItem?: InventoryItemNonNullableFields$3;
}
interface ApplicationErrorNonNullableFields$5 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$3 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$5;
}
interface V3BulkInventoryItemResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$3;
    item?: InventoryItemNonNullableFields$3;
}
interface BulkActionMetadataNonNullableFields$3 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateInventoryItemsResponseNonNullableFields$1 {
    results: V3BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}
interface GetInventoryItemResponseNonNullableFields$1 {
    inventoryItem?: InventoryItemNonNullableFields$3;
}
interface UpdateInventoryItemResponseNonNullableFields$1 {
    inventoryItem?: InventoryItemNonNullableFields$3;
}
interface BulkUpdateInventoryItemsResponseNonNullableFields$1 {
    results: V3BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}
interface BulkUpdateInventoryItemsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface BulkInventoryItemResultNonNullableFields$3 {
    itemMetadata?: ItemMetadataNonNullableFields$3;
}
interface BulkDeleteInventoryItemsResponseNonNullableFields$1 {
    results: BulkInventoryItemResultNonNullableFields$3[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}
interface QueryInventoryItemsResponseNonNullableFields$1 {
    inventoryItems: InventoryItemNonNullableFields$3[];
}
interface ValueAggregationResultNonNullableFields$1 {
    value: string;
    count: number;
}
interface ValueResultsNonNullableFields$1 {
    results: ValueAggregationResultNonNullableFields$1[];
}
interface RangeAggregationResultNonNullableFields$1 {
    count: number;
}
interface RangeResultsNonNullableFields$1 {
    results: RangeAggregationResultNonNullableFields$1[];
}
interface AggregationResultsScalarResultNonNullableFields$1 {
    type: ScalarType$1;
    value: number;
}
interface NestedAggregationResultsNonNullableFields$1 {
    values?: ValueResultsNonNullableFields$1;
    ranges?: RangeResultsNonNullableFields$1;
    scalar?: AggregationResultsScalarResultNonNullableFields$1;
    name: string;
    type: AggregationType$1;
    fieldPath: string;
}
interface NestedValueAggregationResultNonNullableFields$1 {
    value: string;
    nestedResults?: NestedAggregationResultsNonNullableFields$1;
}
interface GroupByValueResultsNonNullableFields$1 {
    results: NestedValueAggregationResultNonNullableFields$1[];
}
interface DateHistogramResultNonNullableFields$1 {
    value: string;
    count: number;
}
interface DateHistogramResultsNonNullableFields$1 {
    results: DateHistogramResultNonNullableFields$1[];
}
interface AggregationResultsNonNullableFields$1 {
    values?: ValueResultsNonNullableFields$1;
    ranges?: RangeResultsNonNullableFields$1;
    scalar?: AggregationResultsScalarResultNonNullableFields$1;
    groupedByValue?: GroupByValueResultsNonNullableFields$1;
    dateHistogram?: DateHistogramResultsNonNullableFields$1;
    name: string;
    type: AggregationType$1;
    fieldPath: string;
}
interface AggregationDataNonNullableFields$1 {
    results: AggregationResultsNonNullableFields$1[];
}
interface SearchInventoryItemsResponseNonNullableFields$1 {
    inventoryItems: InventoryItemNonNullableFields$3[];
    aggregationData?: AggregationDataNonNullableFields$1;
}
interface BulkDecrementInventoryItemsResponseNonNullableFields$1 {
    results: V3BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}
interface BulkIncrementInventoryItemsResponseNonNullableFields$1 {
    results: V3BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields$1 {
    results: V3BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields$1 {
    results: V3BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$3;
}

/** Inventory Item. */
interface InventoryItem$2 extends InventoryItemTrackingMethodOneOf$2 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus$2;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo$4;
    /**
     * Product.
     * @readonly
     */
    product?: Product$2;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields$2;
}
/** @oneof */
interface InventoryItemTrackingMethodOneOf$2 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
declare enum AvailabilityStatus$2 {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    IN_STOCK = "IN_STOCK",
    /**
     * Whether the variant is available for preorder. InventoryItem will be available only when all below conditions are met:
     * 1. the variant is out of stock
     * 2. preorder is enabled on inventory item level (preorder_setting.enabled is true)
     * 3. preorder limit wasn't reached (preorder_setting.limit)
     */
    PREORDER = "PREORDER"
}
interface PreorderInfo$4 {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /** A message the customer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
interface Product$2 {
    /** Product name. */
    name?: string | null;
    /** List of category IDs that this product is included in directly. */
    directCategoryIds?: string[];
    /** Variant name. */
    variantName?: string | null;
    /** Variant SKU (stock keeping unit). */
    variantSku?: string | null;
}
interface ExtendedFields$2 {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface CreateInventoryItemRequest {
    /** Inventory item to create. */
    inventoryItem: InventoryItem$2;
}
interface CreateInventoryItemResponse {
    /** Created inventory item. */
    inventoryItem?: InventoryItem$2;
}
interface BulkCreateInventoryItemsRequest {
    /** Inventory items to create. */
    inventoryItems: InventoryItem$2[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInventoryItemsResponse {
    /** Inventory items created by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface V3BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata$2;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem$2;
}
interface ItemMetadata$2 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$4;
}
interface ApplicationError$4 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$2 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface GetInventoryItemRequest {
    /** Inventory item ID. */
    inventoryItemId: string;
}
interface GetInventoryItemResponse {
    /** Inventory item. */
    inventoryItem?: InventoryItem$2;
}
interface UpdateInventoryItemRequest {
    /** Inventory item to update. */
    inventoryItem: InventoryItem$2;
    /** Reason for update. */
    reason?: ReasonType;
}
/** The reason for the inventory change. */
declare enum ReasonType {
    UNKNOWN = "UNKNOWN",
    ORDER = "ORDER",
    MANUAL = "MANUAL",
    REVERT_INVENTORY_CHANGE = "REVERT_INVENTORY_CHANGE"
}
interface UpdateInventoryItemResponse {
    /** Updated inventory item. */
    inventoryItem?: InventoryItem$2;
}
interface BulkUpdateInventoryItemsRequest {
    /** Inventory items to update. */
    inventoryItems: MaskedInventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonType;
}
interface MaskedInventoryItem {
    /** Inventory item to update. */
    inventoryItem?: InventoryItem$2;
}
interface BulkUpdateInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface BulkUpdateInventoryItemsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Inventory item to update. */
    inventoryItem: InventoryItem$2;
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
interface SearchDetails {
    /** Defines how separate search terms in `expression` are combined. */
    mode?: Mode;
    /** Search term or expression. */
    expression?: string | null;
    /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path. */
    fields?: string[];
    /** Whether to use auto fuzzy search (allowing typos by a managed proximity algorithm). */
    fuzzy?: boolean;
}
declare enum Mode {
    /** Any of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
interface BulkUpdateInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     */
    jobId?: string;
}
interface DeleteInventoryItemRequest {
    /** Inventory item ID. */
    inventoryItemId: string;
}
interface DeleteInventoryItemResponse {
}
interface BulkDeleteInventoryItemsRequest {
    /** IDs of inventory items to delete. */
    inventoryItemIds: string[];
}
interface BulkDeleteInventoryItemsResponse {
    /** Inventory items deleted by bulk action. */
    results?: BulkInventoryItemResult$2[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface BulkInventoryItemResult$2 {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata$2;
}
interface QueryInventoryItemsRequest {
    /** Query options. */
    query?: InventoryQuery;
}
interface InventoryQuery extends InventoryQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: InventoryPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: InventoryCursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$4[];
}
/** @oneof */
interface InventoryQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: InventoryPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: InventoryCursorPaging;
}
interface Sorting$4 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$4;
}
declare enum SortOrder$4 {
    ASC = "ASC",
    DESC = "DESC"
}
interface InventoryPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface InventoryCursorPaging {
    /**
     * Number of items to load.
     * Cursor token returned in the query response. To be used on the next query request, but not the first query request.
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryInventoryItemsResponse {
    /** List of inventory items. */
    inventoryItems?: InventoryItem$2[];
    /** Paging metadata. */
    pagingMetadata?: PlatformPagingMetadataV2;
}
interface PlatformPagingMetadataV2 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors$4;
}
interface Cursors$4 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface SearchInventoryItemsRequest {
    /** Search options. */
    search?: CursorSearch;
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$4;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * List of sort objects.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting$4[];
    /** Aggregations are a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome.
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. For example, `"2023-12-20T10:52:34.795Z"`.
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging$4;
}
interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation. */
    nested?: NestedAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: AggregationType;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
    /**
     * Deprecated. Use `nested` instead.
     * @deprecated Deprecated. Use `nested` instead.
     * @replacedBy kind.nested
     * @targetRemovalDate 2024-03-30
     */
    groupBy?: GroupByAggregation;
}
/** @oneof */
interface AggregationKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation. */
    nested?: NestedAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if `to` is not provided. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` is not provided. */
    to?: number | null;
}
declare enum SortType {
    /** Sort by number of matches. */
    COUNT = "COUNT",
    /** Sort by value of the field alphabetically. */
    VALUE = "VALUE"
}
declare enum SortDirection {
    /** Sort in descending order. */
    DESC = "DESC",
    /** Sort in ascending order. */
    ASC = "ASC"
}
declare enum MissingValues {
    /** Exclude missing values from the aggregation results. */
    EXCLUDE = "EXCLUDE",
    /** Include missing values in the aggregation results. */
    INCLUDE = "INCLUDE"
}
interface IncludeMissingValuesOptions {
    /** Specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
    addToBucket?: string;
}
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX",
    /** Sum of values. */
    SUM = "SUM",
    /** Average of values. */
    AVG = "AVG"
}
interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions;
    /** Whether to sort by number of matches or value of the field. */
    sortType?: SortType;
    /** Whether to sort in ascending or descending order. */
    sortDirection?: SortDirection;
    /** How many aggregations to return. Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Whether to include or exclude missing values from the aggregation results. Default: `EXCLUDE`. */
    missingValues?: MissingValues;
}
/** @oneof */
interface ValueAggregationOptionsOneOf {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions;
}
declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
interface RangeAggregation {
    /** List of range buckets, where during aggregation each entity will be placed in the first bucket its value falls into, based on the provided range bounds. */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Define the operator for the scalar aggregation. */
    type?: ScalarType;
}
interface DateHistogramAggregation {
    /** Interval for date histogram aggregation. */
    interval?: Interval;
}
declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: NestedAggregationType;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
}
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one. */
    NESTED = "NESTED"
}
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one. */
interface NestedAggregation {
    /** Flattened list of aggregations, where each next aggregation is nested within previous one. */
    nestedAggregations?: NestedAggregationItem[];
}
interface GroupByAggregation extends GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Field to aggregate by. */
    fieldPath?: string;
}
/** @oneof */
interface GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
}
interface CursorPaging$4 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface SearchInventoryItemsResponse {
    /** List of inventory items. */
    inventoryItems?: InventoryItem$2[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata$4;
    /** Aggregation data. */
    aggregationData?: AggregationData;
}
interface CursorPagingMetadata$4 {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$4;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface AggregationData {
    /** key = aggregation name (as derived from search request). */
    results?: AggregationResults[];
}
interface ValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number;
}
interface RangeAggregationResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number;
}
interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** User-defined name of aggregation, matches the one provided in request. */
    name?: string;
    /** Type of aggregation that matches result. */
    type?: AggregationType;
    /** Field to aggregate by, matches the one provided in request. */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
}
interface ValueResults {
    /** List of value aggregations. */
    results?: ValueAggregationResult[];
}
interface RangeResults {
    /** List of ranges returned in same order as requested. */
    results?: RangeAggregationResult[];
}
interface AggregationResultsScalarResult {
    /** Type of scalar aggregation. */
    type?: ScalarType;
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Nested aggregations. */
    nestedResults?: NestedAggregationResults;
}
interface ValueResult {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number | null;
}
interface RangeResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number | null;
}
interface ScalarResult {
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedResultValue extends NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
/** @oneof */
interface NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
interface Results {
    /** List of nested aggregations. */
    results?: Record<string, NestedResultValue>;
}
interface DateHistogramResult {
    /** Date in ISO 8601 format. */
    value?: string;
    /** Count of documents in the bucket. */
    count?: number;
}
interface GroupByValueResults {
    /** List of value aggregations. */
    results?: NestedValueAggregationResult[];
}
interface DateHistogramResults {
    /** List of date histogram aggregations. */
    results?: DateHistogramResult[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form.
 * Aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface NestedResults {
    /** List of nested aggregations. */
    results?: Results[];
}
interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
    /** User-defined name of aggregation as derived from search request. */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request. */
    type?: AggregationType;
    /** Field to aggregate by as derived from search request. */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
}
interface BulkDecrementInventoryItemsRequest {
    /** Inventory item IDs and decrement data. */
    decrementData: DecrementDataById[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
interface DecrementDataById {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface BulkIncrementInventoryItemsRequest {
    /** Inventory item IDs and increment data. */
    incrementData: IncrementDataById[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
interface IncrementDataById {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to increment by. */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface BulkDecrementInventoryItemsByVariantAndLocationRequest {
    /** Variant and location IDs, as well as decrement data. */
    decrementData: DecrementDataByVariantAndLocation[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
interface DecrementDataByVariantAndLocation {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface BulkIncrementInventoryItemsByVariantAndLocationRequest {
    /** Variant and location IDs, as well as increment data. */
    incrementData: IncrementDataByVariantAndLocation[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
interface IncrementDataByVariantAndLocation {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to increment by. */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata details as: totalSuccess and totalFailure. */
    bulkActionMetadata?: BulkActionMetadata$2;
}
interface ProductNonNullableFields$2 {
    directCategoryIds: string[];
}
interface InventoryItemNonNullableFields$2 {
    inStock: boolean;
    quantity: number;
    variantId: string;
    productId: string;
    trackQuantity: boolean;
    availabilityStatus: AvailabilityStatus$2;
    product?: ProductNonNullableFields$2;
}
interface CreateInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields$2;
}
interface ApplicationErrorNonNullableFields$4 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$2 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$4;
}
interface V3BulkInventoryItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields$2;
    item?: InventoryItemNonNullableFields$2;
}
interface BulkActionMetadataNonNullableFields$2 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}
interface GetInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields$2;
}
interface UpdateInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields$2;
}
interface BulkUpdateInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}
interface BulkUpdateInventoryItemsByFilterResponseNonNullableFields {
    jobId: string;
}
interface BulkInventoryItemResultNonNullableFields$2 {
    itemMetadata?: ItemMetadataNonNullableFields$2;
}
interface BulkDeleteInventoryItemsResponseNonNullableFields {
    results: BulkInventoryItemResultNonNullableFields$2[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}
interface QueryInventoryItemsResponseNonNullableFields {
    inventoryItems: InventoryItemNonNullableFields$2[];
}
interface ValueAggregationResultNonNullableFields {
    value: string;
    count: number;
}
interface ValueResultsNonNullableFields {
    results: ValueAggregationResultNonNullableFields[];
}
interface RangeAggregationResultNonNullableFields {
    count: number;
}
interface RangeResultsNonNullableFields {
    results: RangeAggregationResultNonNullableFields[];
}
interface AggregationResultsScalarResultNonNullableFields {
    type: ScalarType;
    value: number;
}
interface NestedAggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface NestedValueAggregationResultNonNullableFields {
    value: string;
    nestedResults?: NestedAggregationResultsNonNullableFields;
}
interface GroupByValueResultsNonNullableFields {
    results: NestedValueAggregationResultNonNullableFields[];
}
interface DateHistogramResultNonNullableFields {
    value: string;
    count: number;
}
interface DateHistogramResultsNonNullableFields {
    results: DateHistogramResultNonNullableFields[];
}
interface AggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    groupedByValue?: GroupByValueResultsNonNullableFields;
    dateHistogram?: DateHistogramResultsNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface AggregationDataNonNullableFields {
    results: AggregationResultsNonNullableFields[];
}
interface SearchInventoryItemsResponseNonNullableFields {
    inventoryItems: InventoryItemNonNullableFields$2[];
    aggregationData?: AggregationDataNonNullableFields;
}
interface BulkDecrementInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}
interface BulkIncrementInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$2;
}

type __PublicMethodMetaInfo$6<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createInventoryItem(): __PublicMethodMetaInfo$6<'POST', {}, CreateInventoryItemRequest, CreateInventoryItemRequest$1, CreateInventoryItemResponse & CreateInventoryItemResponseNonNullableFields, CreateInventoryItemResponse$1 & CreateInventoryItemResponseNonNullableFields$1>;
declare function bulkCreateInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, BulkCreateInventoryItemsRequest, BulkCreateInventoryItemsRequest$1, BulkCreateInventoryItemsResponse & BulkCreateInventoryItemsResponseNonNullableFields, BulkCreateInventoryItemsResponse$1 & BulkCreateInventoryItemsResponseNonNullableFields$1>;
declare function getInventoryItem(): __PublicMethodMetaInfo$6<'GET', {
    inventoryItemId: string;
}, GetInventoryItemRequest, GetInventoryItemRequest$1, GetInventoryItemResponse & GetInventoryItemResponseNonNullableFields, GetInventoryItemResponse$1 & GetInventoryItemResponseNonNullableFields$1>;
declare function updateInventoryItem(): __PublicMethodMetaInfo$6<'PATCH', {
    inventoryItemId: string;
}, UpdateInventoryItemRequest, UpdateInventoryItemRequest$1, UpdateInventoryItemResponse & UpdateInventoryItemResponseNonNullableFields, UpdateInventoryItemResponse$1 & UpdateInventoryItemResponseNonNullableFields$1>;
declare function bulkUpdateInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, BulkUpdateInventoryItemsRequest, BulkUpdateInventoryItemsRequest$1, BulkUpdateInventoryItemsResponse & BulkUpdateInventoryItemsResponseNonNullableFields, BulkUpdateInventoryItemsResponse$1 & BulkUpdateInventoryItemsResponseNonNullableFields$1>;
declare function bulkUpdateInventoryItemsByFilter(): __PublicMethodMetaInfo$6<'POST', {}, BulkUpdateInventoryItemsByFilterRequest, BulkUpdateInventoryItemsByFilterRequest$1, BulkUpdateInventoryItemsByFilterResponse & BulkUpdateInventoryItemsByFilterResponseNonNullableFields, BulkUpdateInventoryItemsByFilterResponse$1 & BulkUpdateInventoryItemsByFilterResponseNonNullableFields$1>;
declare function deleteInventoryItem(): __PublicMethodMetaInfo$6<'DELETE', {
    inventoryItemId: string;
}, DeleteInventoryItemRequest, DeleteInventoryItemRequest$1, DeleteInventoryItemResponse, DeleteInventoryItemResponse$1>;
declare function bulkDeleteInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, BulkDeleteInventoryItemsRequest, BulkDeleteInventoryItemsRequest$1, BulkDeleteInventoryItemsResponse & BulkDeleteInventoryItemsResponseNonNullableFields, BulkDeleteInventoryItemsResponse$1 & BulkDeleteInventoryItemsResponseNonNullableFields$1>;
declare function queryInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, QueryInventoryItemsRequest, QueryInventoryItemsRequest$1, QueryInventoryItemsResponse & QueryInventoryItemsResponseNonNullableFields, QueryInventoryItemsResponse$1 & QueryInventoryItemsResponseNonNullableFields$1>;
declare function searchInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, SearchInventoryItemsRequest, SearchInventoryItemsRequest$1, SearchInventoryItemsResponse & SearchInventoryItemsResponseNonNullableFields, SearchInventoryItemsResponse$1 & SearchInventoryItemsResponseNonNullableFields$1>;
declare function bulkDecrementInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, BulkDecrementInventoryItemsRequest, BulkDecrementInventoryItemsRequest$1, BulkDecrementInventoryItemsResponse & BulkDecrementInventoryItemsResponseNonNullableFields, BulkDecrementInventoryItemsResponse$1 & BulkDecrementInventoryItemsResponseNonNullableFields$1>;
declare function bulkIncrementInventoryItems(): __PublicMethodMetaInfo$6<'POST', {}, BulkIncrementInventoryItemsRequest, BulkIncrementInventoryItemsRequest$1, BulkIncrementInventoryItemsResponse & BulkIncrementInventoryItemsResponseNonNullableFields, BulkIncrementInventoryItemsResponse$1 & BulkIncrementInventoryItemsResponseNonNullableFields$1>;
declare function bulkDecrementInventoryItemsByVariantAndLocation(): __PublicMethodMetaInfo$6<'POST', {}, BulkDecrementInventoryItemsByVariantAndLocationRequest, BulkDecrementInventoryItemsByVariantAndLocationRequest$1, BulkDecrementInventoryItemsByVariantAndLocationResponse & BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields, BulkDecrementInventoryItemsByVariantAndLocationResponse$1 & BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields$1>;
declare function bulkIncrementInventoryItemsByVariantAndLocation(): __PublicMethodMetaInfo$6<'POST', {}, BulkIncrementInventoryItemsByVariantAndLocationRequest, BulkIncrementInventoryItemsByVariantAndLocationRequest$1, BulkIncrementInventoryItemsByVariantAndLocationResponse & BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields, BulkIncrementInventoryItemsByVariantAndLocationResponse$1 & BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields$1>;

declare const meta$6_bulkCreateInventoryItems: typeof bulkCreateInventoryItems;
declare const meta$6_bulkDecrementInventoryItems: typeof bulkDecrementInventoryItems;
declare const meta$6_bulkDecrementInventoryItemsByVariantAndLocation: typeof bulkDecrementInventoryItemsByVariantAndLocation;
declare const meta$6_bulkDeleteInventoryItems: typeof bulkDeleteInventoryItems;
declare const meta$6_bulkIncrementInventoryItems: typeof bulkIncrementInventoryItems;
declare const meta$6_bulkIncrementInventoryItemsByVariantAndLocation: typeof bulkIncrementInventoryItemsByVariantAndLocation;
declare const meta$6_bulkUpdateInventoryItems: typeof bulkUpdateInventoryItems;
declare const meta$6_bulkUpdateInventoryItemsByFilter: typeof bulkUpdateInventoryItemsByFilter;
declare const meta$6_createInventoryItem: typeof createInventoryItem;
declare const meta$6_deleteInventoryItem: typeof deleteInventoryItem;
declare const meta$6_getInventoryItem: typeof getInventoryItem;
declare const meta$6_queryInventoryItems: typeof queryInventoryItems;
declare const meta$6_searchInventoryItems: typeof searchInventoryItems;
declare const meta$6_updateInventoryItem: typeof updateInventoryItem;
declare namespace meta$6 {
  export { type __PublicMethodMetaInfo$6 as __PublicMethodMetaInfo, meta$6_bulkCreateInventoryItems as bulkCreateInventoryItems, meta$6_bulkDecrementInventoryItems as bulkDecrementInventoryItems, meta$6_bulkDecrementInventoryItemsByVariantAndLocation as bulkDecrementInventoryItemsByVariantAndLocation, meta$6_bulkDeleteInventoryItems as bulkDeleteInventoryItems, meta$6_bulkIncrementInventoryItems as bulkIncrementInventoryItems, meta$6_bulkIncrementInventoryItemsByVariantAndLocation as bulkIncrementInventoryItemsByVariantAndLocation, meta$6_bulkUpdateInventoryItems as bulkUpdateInventoryItems, meta$6_bulkUpdateInventoryItemsByFilter as bulkUpdateInventoryItemsByFilter, meta$6_createInventoryItem as createInventoryItem, meta$6_deleteInventoryItem as deleteInventoryItem, meta$6_getInventoryItem as getInventoryItem, meta$6_queryInventoryItems as queryInventoryItems, meta$6_searchInventoryItems as searchInventoryItems, meta$6_updateInventoryItem as updateInventoryItem };
}

interface V3Product$1 extends V3ProductTypedPropertiesOneOf$1 {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties$1;
    /**
     * Product ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the product is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the product.
     *
     * Ignored when creating a product.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the product was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the product was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Product name. Translatable. */
    name?: string | null;
    /**
     * Product slug.
     *
     * If not provided, the slug is autogenerated based on the product name.
     */
    slug?: string | null;
    /**
     * URL to the site's product page.
     *
     * > **Note:** Returned only when you pass `"URL"` to the `fields` array in Products API requests.
     * @readonly
     */
    url?: PageUrlV2;
    /**
     * Product description using rich content.
     * > **Note:** Returned only when you pass `"DESCRIPTION"` to the `fields` array in Products API requests.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    description?: RichContent$1;
    /**
     * Product description in HTML.
     *
     * + When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * + `plainDescription` is ignored when value is also passed to the `description` field.
     * > **Note:** Returned only when you pass `"PLAIN_DESCRIPTION"` to the `fields` array in Products API requests.
     */
    plainDescription?: string | null;
    /**
     * Whether the product is visible to site visitors on the site.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /**
     * Whether the product is visible in POS (point of sale).
     *
     * Default: `true`
     * > **Note:** Always `false` for `productType: DIGITAL`.
     */
    visibleInPos?: boolean | null;
    /** Product media items. */
    media?: Media$1;
    /** Product SEO data. */
    seoData?: SeoSchema$1;
    /** Tax group ID. */
    taxGroupId?: string | null;
    /**
     * Product options. Allows the customer to customize the product. For example, selecting color, size, and more.
     *
     * Always generates variants: every variant must have exactly one choice related to each option.
     * Since options and variants tightly coupled and rely on each other they usually should be provided together in all operations.
     */
    options?: ConnectedOption$1[];
    /**
     * Product modifiers.
     *
     * Allows the customer to customize product, e.g. select Color, Size and so on similarly to `options` but with one main difference - `modifiers` never generate any variants.
     */
    modifiers?: ConnectedModifier$1[];
    /**
     * Product brand.
     *
     * + Pass `brand.name` to add a new brand while creating a product.
     * + Pass an existing brand's `id` to assign that brand to the product.
     */
    brand?: Brand$1;
    /**
     * Product info section.
     *
     * + Pass `infoSection.uniqueName`, `infoSection.title`, and `infoSection.description` to add a new info section while creating a product.
     * + Pass an existing info section's `id` or `uniqueName` to assign that info section to the product.
     */
    infoSections?: InfoSection$1[];
    /**
     * Product ribbon.
     *
     * + Pass `ribbon.name` to add a new ribbon while creating a product.
     * + Pass an existing ribbon's `id` or `name` to assign that ribbon to the product.
     */
    ribbon?: Ribbon$3;
    /**
     * List of categories that directly contain this product.
     *
     * Updated automatically when a product is added/removed from a category, when an item is moved within a category, or when a category is deleted.
     * > **Note:** Returned only when you pass `"DIRECT_CATEGORIES_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    directCategoriesInfo?: ProductCategoriesInfo$1;
    /**
     * List of categories that directly contain this product, as well as their parent categories.
     * > **Note:** Returned only when you pass `"ALL_CATEGORIES_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    allCategoriesInfo?: ProductCategoriesInfo$1;
    /** Main category ID. */
    mainCategoryId?: string | null;
    /**
     * Product base price range - minimum and maximum prices of all product variants.
     * @readonly
     */
    basePriceRange?: PriceRange$1;
    /**
     * Product sale price range - minimum and maximum sale prices of all product variants.
     * @readonly
     */
    salePriceRange?: PriceRange$1;
    /**
     * Product cost range - minimum and maximum costs of all product variants.
     *
     * > **Note:** Returned only when the following conditions are met:
     * > + You pass `"MERCHANT_DATA"` to the `fields` array in Products API requests.
     * > + Your app has the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     * @readonly
     */
    costRange?: PriceRange$1;
    /**
     * Product inventory info.
     * @readonly
     */
    inventory?: Inventory$1;
    /**
     * Product type.
     *
     * When passing `productType: PHYSICAL`, you must also pass `physicalProperties`.
     */
    productType?: ProductType$1;
    /**
     * A unique human-friendly identifier for the product.
     * Unlike the product ID, the handle can be set by the user to ensure consistency across multiple platforms.
     * In case handle wasn't given, the handle will be automatically generated.
     */
    handle?: string | null;
    /**
     * Currency used for the pricing of this product, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     *
     * Defaults to the currency defined in the site settings, unless specified in `x-wix-currency` header.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    currency?: string | null;
    /**
     * Breadcrumbs of the `mainCategoryId`. Used to navigate to parent categories.
     * > **Note:** Returned only when you pass `"BREADCRUMBS_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    breadcrumbsInfo?: BreadcrumbsInfo$1;
    /** Product variants. */
    variantsInfo?: VariantsInfo$1;
    /**
     * Custom extended fields for the product object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields$1;
    /** Product subscriptions. */
    subscriptionDetails?: SubscriptionDetails$1;
    /**
     * The total number of variants for the product.
     * @readonly
     */
    variantSummary?: VariantSummary$1;
}
/** @oneof */
interface V3ProductTypedPropertiesOneOf$1 {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties$1;
}
interface PageUrlV2 {
    /** The relative path for the page within the site. For example, `/product-page/a-product`. */
    relativePath?: string;
    /** The page's full URL. For example, `https://mysite.com/product-page/a-product`. */
    url?: string | null;
}
interface RichContent$1 {
    /** Node objects representing a rich content document. */
    nodes?: Node$1[];
    /** Object metadata. */
    metadata?: Metadata$1;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle$1;
}
interface Node$1 extends NodeDataOneOf$1 {
    /** Data for a button node. */
    buttonData?: ButtonData$1;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData$1;
    /** Data for a divider node. */
    dividerData?: DividerData$1;
    /** Data for a file node. */
    fileData?: FileData$1;
    /** Data for a gallery node. */
    galleryData?: GalleryData$1;
    /** Data for a GIF node. */
    gifData?: GIFData$1;
    /** Data for a heading node. */
    headingData?: HeadingData$1;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData$1;
    /** Data for an image node. */
    imageData?: ImageData$1;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData$1;
    /** Data for a map node. */
    mapData?: MapData$1;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData$1;
    /** Data for a poll node. */
    pollData?: PollData$1;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData$1;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData$1;
    /** Data for a video node. */
    videoData?: VideoData$1;
    /** Data for an oEmbed node. */
    embedData?: EmbedData$1;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData$1;
    /** Data for a table node. */
    tableData?: TableData$1;
    /** Data for a table cell node. */
    tableCellData?: TableCellData$1;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData$1;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData$1;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData$1;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData$1;
    /** Data for a caption node. */
    captionData?: CaptionData$1;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeType$1;
    /** Node ID. */
    id?: string;
    /** A list of child nodes. */
    nodes?: Node$1[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle$1;
}
/** @oneof */
interface NodeDataOneOf$1 {
    /** Data for a button node. */
    buttonData?: ButtonData$1;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData$1;
    /** Data for a divider node. */
    dividerData?: DividerData$1;
    /** Data for a file node. */
    fileData?: FileData$1;
    /** Data for a gallery node. */
    galleryData?: GalleryData$1;
    /** Data for a GIF node. */
    gifData?: GIFData$1;
    /** Data for a heading node. */
    headingData?: HeadingData$1;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData$1;
    /** Data for an image node. */
    imageData?: ImageData$1;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData$1;
    /** Data for a map node. */
    mapData?: MapData$1;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData$1;
    /** Data for a poll node. */
    pollData?: PollData$1;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData$1;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData$1;
    /** Data for a video node. */
    videoData?: VideoData$1;
    /** Data for an oEmbed node. */
    embedData?: EmbedData$1;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData$1;
    /** Data for a table node. */
    tableData?: TableData$1;
    /** Data for a table cell node. */
    tableCellData?: TableCellData$1;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData$1;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData$1;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData$1;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData$1;
    /** Data for a caption node. */
    captionData?: CaptionData$1;
}
declare enum NodeType$1 {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION"
}
interface NodeStyle$1 {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData$1 {
    /** Styling for the button's container. */
    containerData?: PluginContainerData$1;
    /** The button type. */
    type?: Type$1;
    /** Styling for the button. */
    styles?: Styles$1;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link$1;
}
interface Border$1 {
    /** Border width in pixels. */
    width?: number | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface Colors$1 {
    /** The text color as a hexadecimal value. */
    text?: string | null;
    /** The border color as a hexadecimal value. */
    border?: string | null;
    /** The background color as a hexadecimal value. */
    background?: string | null;
}
interface PluginContainerData$1 {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth$1;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignment$1;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler$1;
    /** The height of the node when it's displayed. */
    height?: Height$1;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType$1 {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
interface PluginContainerDataWidth$1 extends PluginContainerDataWidthDataOneOf$1 {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType$1;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf$1 {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType$1;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment$1 {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
interface Spoiler$1 {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height$1 {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum Type$1 {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
interface Styles$1 {
    /** Border attributes. */
    border?: Border$1;
    /** Color attributes. */
    colors?: Colors$1;
}
interface Link$1 extends LinkDataOneOf$1 {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: Target$1;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel$1;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf$1 {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target$1 {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
interface Rel$1 {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData$1 {
    /** Styling for the code block's text. */
    textStyle?: TextStyle$1;
}
interface TextStyle$1 {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignment$1;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment$1 {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
interface DividerData$1 {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData$1;
    /** Divider line style. */
    lineStyle?: LineStyle$1;
    /** Divider width. */
    width?: Width$1;
    /** Divider alignment. */
    alignment?: Alignment$1;
}
declare enum LineStyle$1 {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
declare enum Width$1 {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
declare enum Alignment$1 {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
interface FileData$1 {
    /** Styling for the file's container. */
    containerData?: PluginContainerData$1;
    /** The source for the file's data. */
    src?: FileSource$1;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings$1;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode$1 {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
interface FileSource$1 extends FileSourceDataOneOf$1 {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf$1 {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    id?: string | null;
}
interface PDFSettings$1 {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewMode$1;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData$1 {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData$1;
    /** The items in the gallery. */
    items?: Item$1[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions$1;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface V1Media$1 {
    /** The source for the media's data. */
    src?: FileSource$1;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface ItemImage {
    /** Image file details. */
    media?: V1Media$1;
    /** Link details for images that are links. */
    link?: Link$1;
}
interface Video$1 {
    /** Video file details. */
    media?: V1Media$1;
    /** Video thumbnail file details. */
    thumbnail?: V1Media$1;
}
interface Item$1 extends ItemDataOneOf$1 {
    /** An image item. */
    image?: ItemImage;
    /** A video item. */
    video?: Video$1;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf$1 {
    /** An image item. */
    image?: ItemImage;
    /** A video item. */
    video?: Video$1;
}
interface GalleryOptions$1 {
    /** Gallery layout. */
    layout?: Layout$1;
    /** Styling for gallery items. */
    item?: ItemStyle$1;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails$1;
}
declare enum LayoutType$1 {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
declare enum Orientation$1 {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
declare enum Crop$1 {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
declare enum ThumbnailsAlignment$1 {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
interface Layout$1 {
    /** Gallery layout type. */
    type?: LayoutType$1;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: Orientation$1;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle$1 {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: Crop$1;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails$1 {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignment$1;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData$1 {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData$1;
    /** The source of the full size GIF. */
    original?: GIF$1;
    /** The source of the downsized GIF. */
    downsized?: GIF$1;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
}
interface GIF$1 {
    /** GIF format URL. */
    gif?: string | null;
    /** MP4 format URL. */
    mp4?: string | null;
    /** Thumbnail URL. */
    still?: string | null;
}
interface HeadingData$1 {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle$1;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData$1 extends HTMLDataDataOneOf$1 {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. */
    containerData?: PluginContainerData$1;
    /** The type of HTML code. */
    source?: Source$1;
}
/** @oneof */
interface HTMLDataDataOneOf$1 {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source$1 {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
interface ImageData$1 {
    /** Styling for the image's container. */
    containerData?: PluginContainerData$1;
    /** Image file details. */
    image?: V1Media$1;
    /** Link details for images that are links. */
    link?: Link$1;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface LinkPreviewData$1 {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData$1;
    /** Link details. */
    link?: Link$1;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
}
interface MapData$1 {
    /** Styling for the map's container. */
    containerData?: PluginContainerData$1;
    /** Map settings. */
    mapSettings?: MapSettings$1;
}
interface MapSettings$1 {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapType$1;
}
declare enum MapType$1 {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
interface ParagraphData$1 {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle$1;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData$1 {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData$1;
    /** Poll data. */
    poll?: Poll$1;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout$1;
    /** Styling for the poll and voting options. */
    design?: Design$1;
}
declare enum ViewRole$1 {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
declare enum VoteRole$1 {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
interface Permissions$1 {
    /** Sets who can view the poll results. */
    view?: ViewRole$1;
    /** Sets who can vote. */
    vote?: VoteRole$1;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option$1 {
    /** Option ID. */
    id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: V1Media$1;
}
interface PollSettings$1 {
    /** Permissions settings for voting. */
    permissions?: Permissions$1;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType$1 {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
declare enum PollLayoutDirection$1 {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface PollLayout$1 {
    /** The layout for displaying the voting options. */
    type?: PollLayoutType$1;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirection$1;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout$1 {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType$1 {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
interface Gradient$1 {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /** The start color as a hexademical value. */
    startColor?: string | null;
    /** The end color as a hexademical value. */
    lastColor?: string | null;
}
interface Background$1 extends BackgroundBackgroundOneOf$1 {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: V1Media$1;
    /** Details for a gradient background. */
    gradient?: Gradient$1;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundType$1;
}
/** @oneof */
interface BackgroundBackgroundOneOf$1 {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: V1Media$1;
    /** Details for a gradient background. */
    gradient?: Gradient$1;
}
interface PollDesign$1 {
    /** Background styling. */
    background?: Background$1;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign$1 {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll$1 {
    /** Poll ID. */
    id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: V1Media$1;
    /** Voting options. */
    options?: Option$1[];
    /** The poll's permissions and display settings. */
    settings?: PollSettings$1;
}
interface PollDataLayout$1 {
    /** Poll layout settings. */
    poll?: PollLayout$1;
    /** Voting otpions layout settings. */
    options?: OptionLayout$1;
}
interface Design$1 {
    /** Styling for the poll. */
    poll?: PollDesign$1;
    /** Styling for voting options. */
    options?: OptionDesign$1;
}
interface TextData$1 {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration$1[];
}
/** Adds appearence changes to text */
interface Decoration$1 extends DecorationDataOneOf$1 {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData$1;
    /** Data for a color decoration. */
    colorData?: ColorData$1;
    /** Data for an external link decoration. */
    linkData?: LinkData$1;
    /** Data for a mention decoration. */
    mentionData?: MentionData$1;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData$1;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData$1;
    /** The type of decoration to apply. */
    type?: DecorationType$1;
}
/** @oneof */
interface DecorationDataOneOf$1 {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData$1;
    /** Data for a color decoration. */
    colorData?: ColorData$1;
    /** Data for an external link decoration. */
    linkData?: LinkData$1;
    /** Data for a mention decoration. */
    mentionData?: MentionData$1;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData$1;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData$1;
}
declare enum DecorationType$1 {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL"
}
interface AnchorData$1 {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData$1 {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData$1 {
    /** Link details. */
    link?: Link$1;
}
interface MentionData$1 {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    id?: string | null;
}
interface FontSizeData$1 {
    /** The units used for the font size. */
    unit?: FontType$1;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType$1 {
    PX = "PX",
    EM = "EM"
}
interface SpoilerData$1 {
    /** Spoiler ID. */
    id?: string | null;
}
interface AppEmbedData$1 extends AppEmbedDataAppDataOneOf$1 {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData$1;
    /** Data for embedded Wix Events content. */
    eventData?: EventData$1;
    /** The type of Wix App content being embedded. */
    type?: AppType$1;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: V1Media$1;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf$1 {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData$1;
    /** Data for embedded Wix Events content. */
    eventData?: EventData$1;
}
declare enum AppType$1 {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
interface BookingData$1 {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData$1 {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface VideoData$1 {
    /** Styling for the video's container. */
    containerData?: PluginContainerData$1;
    /** Video details. */
    video?: V1Media$1;
    /** Video thumbnail details. */
    thumbnail?: V1Media$1;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions$1;
}
interface PlaybackOptions$1 {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData$1 {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData$1;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed$1;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed$1 {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData$1 {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData$1;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItems$1;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: Direction$1;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems$1 {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
declare enum Direction$1 {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface TableData$1 {
    /** Styling for the table's container. */
    containerData?: PluginContainerData$1;
    /** The table's dimensions. */
    dimensions?: Dimensions$1;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions$1 {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData$1 {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle$1;
    /** The cell's border colors. */
    borderColors?: BorderColors$1;
}
declare enum VerticalAlignment$1 {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
interface CellStyle$1 {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignment$1;
    /** Cell background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface BorderColors$1 {
    /** Left border color as a hexadecimal value. */
    left?: string | null;
    /** Right border color as a hexadecimal value. */
    right?: string | null;
    /** Top border color as a hexadecimal value. */
    top?: string | null;
    /** Bottom border color as a hexadecimal value. */
    bottom?: string | null;
}
interface AudioData$1 {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData$1;
    /** Audio file details. */
    audio?: V1Media$1;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: V1Media$1;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData$1 {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData$1 {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData$1 {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData$1 {
    textStyle?: TextStyle$1;
}
interface Metadata$1 {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    id?: string | null;
}
interface DocumentStyle$1 {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle$1;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle$1;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle$1;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle$1;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle$1;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle$1;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle$1;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle$1;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle$1;
}
interface TextNodeStyle$1 {
    /** The decorations to apply to the node. */
    decorations?: Decoration$1[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle$1;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface Media$1 {
    /**
     * Main media (image, video, etc.) associated with this product.
     * @readonly
     */
    main?: ProductMedia$1;
    /**
     * All media items.
     * > **Note:** Returned only when you pass `"MEDIA_ITEMS_INFO"` to the `fields` array in Products API requests.
     */
    itemsInfo?: MediaItemsInfo$1;
}
interface ProductMedia$1 extends ProductMediaSetByOneOf$1, ProductMediaMediaOneOf$1 {
    /** ID of existing media from Wix Media Manager. */
    id?: string;
    /** Media URL. */
    url?: string;
    /**
     * Product image.
     * @readonly
     */
    image?: Image$1;
    /**
     * Product video.
     * @readonly
     */
    video?: VideoV2;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Media display name.
     * Allows to override the default media name. Can be passed only when `setBy: url`.
     */
    displayName?: string | null;
    /**
     * Media type.
     * @readonly
     */
    mediaType?: MediaType$1;
    /**
     * Media thumbnail.
     * > **Note:** Returned only when you pass `"THUMBNAIL"` to the `fields` array in Products API requests.
     */
    thumbnail?: Thumbnail$1;
    /**
     * ID used to upload media to Wix Media Manager.
     * @readonly
     */
    uploadId?: string;
}
/** @oneof */
interface ProductMediaSetByOneOf$1 {
    /** ID of existing media from Wix Media Manager. */
    id?: string;
    /** Media URL. */
    url?: string;
}
/** @oneof */
interface ProductMediaMediaOneOf$1 {
    /**
     * Product image.
     * @readonly
     */
    image?: Image$1;
    /**
     * Product video.
     * @readonly
     */
    video?: VideoV2;
}
interface Image$1 {
    /** WixMedia image ID. */
    id?: string;
    /** Image URL. */
    url?: string;
    /**
     * Original image height.
     * @readonly
     */
    height?: number;
    /**
     * Original image width.
     * @readonly
     */
    width?: number;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Image filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoV2 {
    /** WixMedia ID. */
    id?: string;
    /**
     * Available resolutions for the video, starting with the optimal resolution.
     * @readonly
     */
    resolutions?: VideoResolution[];
    /**
     * Video filename.
     * @readonly
     */
    filename?: string | null;
}
interface VideoResolution {
    /** Video URL. */
    url?: string;
    /** Video height. */
    height?: number;
    /** Video width. */
    width?: number;
    /** Video format for example, mp4, hls. */
    format?: string;
}
declare enum MediaType$1 {
    UNKNOWN_MEDIA_TYPE = "UNKNOWN_MEDIA_TYPE",
    IMAGE = "IMAGE",
    VIDEO = "VIDEO"
}
interface Thumbnail$1 {
    /** Thumbnail url. */
    url?: string;
    /** Thumbnail height. */
    height?: number;
    /** Thumbnail width. */
    width?: number;
    /** Thumbnail alt text. */
    altText?: string | null;
}
interface MediaItemsInfo$1 {
    /** All media items (images, videos etc) associated with this product. */
    items?: ProductMedia$1[];
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema$1 {
    /** SEO tag information. */
    tags?: Tag$1[];
    /** SEO general settings. */
    settings?: Settings$1;
}
interface Keyword$1 {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /** The source that added the keyword terms to the SEO settings. */
    origin?: string | null;
}
interface Tag$1 {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
     * For example: `{'name': 'description', 'content': 'the description itself'}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings$1 {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /** User-selected keyword terms for a specific page. */
    keywords?: Keyword$1[];
}
interface ConnectedOption$1 extends ConnectedOptionOptionSettingsOneOf$1 {
    /** Choices settings. */
    choicesSettings?: ChoicesSettings$1;
    /** ID of a customization with `customizationType: PRODUCT_OPTION`. */
    id?: string | null;
    /** Option name. */
    name?: string | null;
    /** Option render type. */
    optionRenderType?: ProductOptionRenderType$1;
}
/** @oneof */
interface ConnectedOptionOptionSettingsOneOf$1 {
    /** Choices settings. */
    choicesSettings?: ChoicesSettings$1;
}
declare enum ProductOptionRenderType$1 {
    UNKNOWN_OPTION_RENDER_TYPE = "UNKNOWN_OPTION_RENDER_TYPE",
    TEXT_CHOICES = "TEXT_CHOICES",
    SWATCH_CHOICES = "SWATCH_CHOICES"
}
interface ChoicesSettings$1 {
    /** List of available choices for the option. */
    choices?: ConnectedOptionChoice$1[];
}
interface ConnectedOptionChoice$1 extends ConnectedOptionChoiceValueOneOf$1 {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
    /** The id of the choice. */
    choiceId?: string | null;
    /**
     * Product media overrides. When not empty only these images will be shown when such choices selected by customer. Otherwise all images of product.
     * When several choices from different options selected only media filter present in `media_overrides` of ALL choices will be shown.
     * For example if Color:red has images 1,2,3 and Material:Silk has images 2,3,5 then only images 2,3 will be shown when both of them selected.
     */
    linkedMedia?: ProductMedia$1[];
    /** The type of this choice. */
    choiceType?: ChoiceType$1;
    /** Choice name. */
    name?: string | null;
    /**
     * A flag that indicates if at least one variant with this choice is in stock in the default store's location.
     * For example, a product with 'Color' and 'Size' options with variants: [Blue, Small] which is out of stock and [Red Large] which is in stock. For choice 'Blue' ths flag will be 'false' and for 'Red' the flag will be true
     * @readonly
     */
    inStock?: boolean;
    /**
     * Whether at least one variant with this choice is visible.
     *
     * Default: `false`
     * @readonly
     */
    visible?: boolean;
}
/** @oneof */
interface ConnectedOptionChoiceValueOneOf$1 {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
}
declare enum ChoiceType$1 {
    UNKNOWN_CHOICE_TYPE = "UNKNOWN_CHOICE_TYPE",
    CHOICE_TEXT = "CHOICE_TEXT",
    ONE_COLOR = "ONE_COLOR",
    MULTIPLE_COLORS = "MULTIPLE_COLORS",
    IMAGE = "IMAGE"
}
interface ConnectedModifier$1 extends ConnectedModifierModifierSettingsOneOf$1 {
    /** Free text modifier settings. */
    freeTextSettings?: FreeTextSettings$1;
    /** Choice settings. */
    choicesSettings?: ModifierChoicesSettings$1;
    /** ID of a customization with `customizationType: MODIFIER`. */
    id?: string | null;
    /** Modifier title. */
    name?: string | null;
    /** Modifier render type. */
    modifierRenderType?: ModifierRenderType$1;
    /** Whether customer input is required for this modifier. */
    mandatory?: boolean;
}
/** @oneof */
interface ConnectedModifierModifierSettingsOneOf$1 {
    /** Free text modifier settings. */
    freeTextSettings?: FreeTextSettings$1;
    /** Choice settings. */
    choicesSettings?: ModifierChoicesSettings$1;
}
declare enum ModifierRenderType$1 {
    UNKNOWN_MODIFIER_RENDER_TYPE = "UNKNOWN_MODIFIER_RENDER_TYPE",
    FREE_TEXT = "FREE_TEXT",
    TEXT_CHOICES = "TEXT_CHOICES",
    SWATCH_CHOICES = "SWATCH_CHOICES"
}
interface FreeTextSettings$1 {
    /** Minimum number of characters. */
    minCharCount?: number;
    /** Maximum number of characters. */
    maxCharCount?: number;
    /** Default amount to be added to the product's price. */
    defaultAddedPrice?: string | null;
    /** Title of the text to be input by the customer. */
    title?: string;
}
interface ModifierChoicesSettings$1 {
    /** List of modifier choices. */
    choices?: ConnectedModifierChoice$1[];
}
interface ConnectedModifierChoice$1 extends ConnectedModifierChoiceValueOneOf$1 {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
    /** Choice ID. */
    choiceId?: string | null;
    /** Product media. */
    linkedMedia?: ProductMedia$1[];
    /** Choice type. */
    choiceType?: ChoiceType$1;
    /**
     * Modifier key. Used for eCommerce integration.
     * @readonly
     */
    key?: string;
    /** Choice name. */
    name?: string | null;
    /** Added price. */
    addedPrice?: string | null;
}
/** @oneof */
interface ConnectedModifierChoiceValueOneOf$1 {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
}
interface Brand$1 {
    /** Brand ID. */
    id?: string | null;
    /** Brand name. */
    name?: string | null;
}
interface InfoSection$1 {
    /** Info section ID. */
    id?: string | null;
    /**
     * Info section unique name.
     * > **Note:** Returned only when you pass `"INFO_SECTION"` to the `fields` array in Products API requests.
     */
    uniqueName?: string | null;
    /**
     * Info section title.
     * > **Note:** Returned only when you pass `"INFO_SECTION"` to the `fields` array in Products API requests.
     * @readonly
     */
    title?: string | null;
    /**
     * Info section description using rich content.
     * > **Note:** Returned only when you pass `"INFO_SECTION_DESCRIPTION"` to the `fields` array in Products API requests.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     * @readonly
     */
    description?: RichContent$1;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     * > **Note:** Returned only when you pass `"INFO_SECTION_PLAIN_DESCRIPTION"` to the `fields` array in Products API requests.
     */
    plainDescription?: string | null;
}
interface Ribbon$3 {
    /** Ribbon ID. */
    id?: string | null;
    /** Ribbon name. */
    name?: string | null;
}
interface ProductCategoriesInfo$1 {
    /**
     * A list of categories related to product.
     * @readonly
     */
    categories?: ProductCategory$1[];
}
interface ProductCategory$1 {
    /** Category ID. */
    id?: string;
    /** Index location of the product within the category, which can be utilized for sorting products in a specific category. For detailed instructions on how to set this up, refer to the [Add and arrange products in category](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/products-v3/sample-use-cases-and-flows#add-and-arrange-products-in-category) sample flow. */
    index?: number | null;
}
interface PriceRange$1 {
    /** Minimum value. */
    minValue?: FixedMonetaryAmount$1;
    /** Maximum value. */
    maxValue?: FixedMonetaryAmount$1;
}
interface FixedMonetaryAmount$1 {
    /** Monetary amount. For example, `"3.99"`, or `"-4.99"` for a negative amount. */
    amount?: string;
    /**
     * Formatted monetary amount. For example, `"$3.99"`.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    formattedAmount?: string | null;
}
interface Inventory$1 {
    /**
     * Current availability status.
     *
     * + `IN_STOCK`: All variants are in stock and available for purchase
     * + `OUT_OF_STOCK`: All variants are out of stock
     * + `PARTIALLY_OUT_OF_STOCK`: Some variants are out of stock and some are in stock and available for purchase
     * @readonly
     */
    availabilityStatus?: InventoryAvailabilityStatus$1;
    /**
     * Current preorder status/
     *
     * + `ENABLED`: All variants are enabled for preorder
     * + `DISABLED`: All variants are disabled for preorder
     * + `PARTIALLY_ENABLED`: Some variants are disabled and some are enabled for preorder
     * @readonly
     */
    preorderStatus?: PreorderStatus$1;
    /**
     * Supported values:
     * + `ALL_VARIANTS`: All the product variants are available for preorder.
     * + `NO_VARIANTS`: None of the product variants are available for preorder.
     * + `SOME_VARIANTS`: Some of the product variants are available for preorder.
     * @readonly
     */
    preorderAvailability?: ProductPreorderAvailability$1;
}
declare enum InventoryAvailabilityStatus$1 {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    IN_STOCK = "IN_STOCK",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    PARTIALLY_OUT_OF_STOCK = "PARTIALLY_OUT_OF_STOCK"
}
declare enum PreorderStatus$1 {
    UNKNOWN_PREORDER_STATUS = "UNKNOWN_PREORDER_STATUS",
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    PARTIALLY_ENABLED = "PARTIALLY_ENABLED"
}
declare enum ProductPreorderAvailability$1 {
    UNKNOWN_PREORDER_AVAILABILITY_STATUS = "UNKNOWN_PREORDER_AVAILABILITY_STATUS",
    ALL_VARIANTS = "ALL_VARIANTS",
    NO_VARIANTS = "NO_VARIANTS",
    SOME_VARIANTS = "SOME_VARIANTS"
}
declare enum ProductType$1 {
    UNKNOWN_PRODUCT_TYPE = "UNKNOWN_PRODUCT_TYPE",
    PHYSICAL = "PHYSICAL",
    DIGITAL = "DIGITAL"
}
interface PhysicalProperties$1 {
    /** Price per unit settings. */
    pricePerUnit?: PricePerUnitSettings$1;
    /** Fulfiller ID. */
    fulfillerId?: string | null;
    /**
     * Product shipping weight range - minimum and maximum weights of all the variants.
     * @readonly
     */
    shippingWeightRange?: WeightRange$1;
    /**
     * Product price per unit range. The minimum and maximum price per unit of all the variants.
     * @readonly
     */
    pricePerUnitRange?: PricePerUnitRange$1;
    /**
     * Weight measurement unit.
     * > **Note:** Returned only when you pass `"WEIGHT_MEASUREMENT_UNIT_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    weightMeasurementUnitInfo?: WeightMeasurementUnitInfo$1;
}
interface PricePerUnitSettings$1 {
    /**
     * Quantity.
     * For example, to define price per per 100 grams, set this field to `100`.
     */
    quantity?: number;
    /**
     * Measurement unit.
     * For example, to define price per 100 grams, set this field to "G".
     */
    measurementUnit?: MeasurementUnit$1;
}
declare enum MeasurementUnit$1 {
    UNSPECIFIED = "UNSPECIFIED",
    ML = "ML",
    CL = "CL",
    L = "L",
    CBM = "CBM",
    MG = "MG",
    G = "G",
    KG = "KG",
    MM = "MM",
    CM = "CM",
    M = "M",
    SQM = "SQM",
    OZ = "OZ",
    LB = "LB",
    FLOZ = "FLOZ",
    PT = "PT",
    QT = "QT",
    GAL = "GAL",
    IN = "IN",
    FT = "FT",
    YD = "YD",
    SQFT = "SQFT"
}
interface WeightRange$1 {
    /** Minimum weight across all variants associated with this product. */
    minValue?: number;
    /** Maximum weight across all variants associated with this product. */
    maxValue?: number;
}
interface PricePerUnitRange$1 {
    /** Minimum price per unit across all variants. */
    minValue?: PricePerUnitRangePricePerUnit$1;
    /** Maximum price per unit across all variants. */
    maxValue?: PricePerUnitRangePricePerUnit$1;
}
interface PricePerUnitRangePricePerUnit$1 {
    /**
     * Calculated value of price per unit. Takes into account pricePerUnit settings of product and variants and sale price of variants.
     * For example if discounted price is 2$, product's price per unit setting is 1 Kg, variant price per unit setting is 0.5 Kg then this value is 4$ (means variant weight is 0.5 Kg and it costs 2$ but we want to show price per 1 Kg so we show 4$).
     * @readonly
     */
    value?: string;
    /**
     * Price per unit info in the format of variant specific data / product setting, for example €4.00 / 1 Kg.
     * > **Note:** This field is returned by the API only when you pass `fields: "CURRENCY"` in a request.
     * @readonly
     */
    description?: string | null;
}
interface WeightMeasurementUnitInfo$1 {
    /**
     * Weight measurement unit.
     * @readonly
     */
    weightMeasurementUnit?: WeightUnit$1;
}
declare enum WeightUnit$1 {
    /** Weight unit can't be classified, due to an error */
    UNSPECIFIED_WEIGHT_UNIT = "UNSPECIFIED_WEIGHT_UNIT",
    /** Kilograms */
    KG = "KG",
    /** Pounds */
    LB = "LB"
}
interface BreadcrumbsInfo$1 {
    /**
     * Breadcrumbs.
     * @readonly
     */
    breadcrumbs?: BreadCrumb$1[];
}
interface BreadCrumb$1 {
    /** Category ID. */
    categoryId?: string;
    /** Category name. */
    categoryName?: string;
    /** Category slug. */
    categorySlug?: string;
}
interface VariantsInfo$1 {
    /** List of related variants. */
    variants?: Variant$1[];
}
interface Variant$1 extends VariantTypedPropertiesOneOf$1 {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties$1;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties$1;
    /** Variant ID. */
    id?: string | null;
    /**
     * Whether the variant is visible to site visitors.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string | null;
    /** Variant barcode. */
    barcode?: string | null;
    /**
     * List of choices.
     * In case this list is empty, this is the default variant of an unmanaged product.
     */
    choices?: OptionChoice$1[];
    /** Variant price. */
    price?: PriceInfo$1;
    /**
     * Variant revenue details.
     *
     * > **Note:** Returned only when the following conditions are met:
     * > + You pass `"MERCHANT_DATA"` to the `fields` array in Products API requests.
     * > + Your app has the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     */
    revenueDetails?: RevenueDetails$1;
    /**
     * Variant media.
     * @readonly
     */
    media?: ProductMedia$1;
    /**
     * Subscription prices calculated by applying subscription discount to the variant `price.salePrice`.
     * > **Note:** Returned only when you pass `"SUBSCRIPTION_PRICES_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    subscriptionPricesInfo?: SubscriptionPricesInfo$1;
    /**
     * Variant inventory status.
     * @readonly
     */
    inventoryStatus?: InventoryStatus$1;
}
/** @oneof */
interface VariantTypedPropertiesOneOf$1 {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties$1;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties$1;
}
interface OptionChoice$1 {
    /** Option and choice IDs. */
    optionChoiceIds?: OptionChoiceIds$1;
    /**
     * Option and choice names.
     * > **Note:** Returned only when you pass `"VARIANT_OPTION_CHOICE_NAMES"` to the `fields` array in Products API requests.
     */
    optionChoiceNames?: OptionChoiceNames$1;
}
interface OptionChoiceIds$1 {
    /** Option ID. */
    optionId?: string;
    /** Choice ID. */
    choiceId?: string;
}
interface OptionChoiceNames$1 {
    /** Option name. */
    optionName?: string;
    /** Choice name. */
    choiceName?: string;
    /** Render type. */
    renderType?: ProductOptionRenderType$1;
}
interface PriceInfo$1 {
    /** Variant price. Must be greater or equal to 0. */
    basePrice?: FixedMonetaryAmount$1;
    /** Variant sale price. If not provided, sale price will be equal to `basePrice`. When provided, value must be greater or equal to 0, and less than or equal to `basePrice`. */
    salePrice?: FixedMonetaryAmount$1;
}
interface RevenueDetails$1 {
    /** Item cost. */
    cost?: FixedMonetaryAmount$1;
    /**
     * Profit. Calculated by reducing `cost` from `discountedPrice`.
     * @readonly
     */
    profit?: FixedMonetaryAmount$1;
    /**
     * Profit Margin. Calculated by dividing `profit` by `discountedPrice`.
     * The result is rounded to 4 decimal places.
     * @readonly
     */
    profitMargin?: number;
}
interface VariantPhysicalProperties$1 {
    /** Variant shipping weight. */
    weight?: number | null;
    /**
     * Price per unit info, in order to show price per unit on the product page.
     * For example if one sells cheese and defines 100g here then we know that buying this variant buyer receives 100g of cheese.
     * But on product page price will be displayed for units defined on product level. See `pricePerUnit.value` to understand how it's calculated.
     */
    pricePerUnit?: PricePerUnit$1;
}
interface PricePerUnit$1 {
    /**
     * Price per unit data for this variant.
     * `measurementUnit` value must correspond to the measurement unit set on the product.
     */
    settings?: PricePerUnitSettings$1;
    /**
     * Calculated value of price per unit. Takes into account `pricePerUnit` settings of parent product, of this variant, and discounted price of variant.
     * For example if discounted price is 2$, product's price per unit setting is 1 Kg, variant price per unit setting is 0.5 Kg then this value is 4$ (means variant weight is 0.5 Kg and it costs 2$ but we want to show price per 1 Kg so we show 4$).
     * @readonly
     */
    value?: string;
    /**
     * Price per unit description.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    description?: string | null;
}
interface VariantDigitalProperties$1 {
    /** Digital file which will be downloaded by customer after successful purchase. */
    digitalFile?: SecuredMedia$1;
}
interface SecuredMedia$1 {
    /** Media ID in media manager. */
    id?: string;
    /**
     * Original file name.
     * @readonly
     */
    fileName?: string;
    /**
     * Original file size.
     * @readonly
     */
    fileSize?: string | null;
    /**
     * File type.
     * @readonly
     */
    fileType?: FileType$1;
}
declare enum FileType$1 {
    UNSPECIFIED = "UNSPECIFIED",
    SECURE_PICTURE = "SECURE_PICTURE",
    SECURE_VIDEO = "SECURE_VIDEO",
    SECURE_DOCUMENT = "SECURE_DOCUMENT",
    SECURE_MUSIC = "SECURE_MUSIC",
    SECURE_ARCHIVE = "SECURE_ARCHIVE"
}
interface SubscriptionPricesInfo$1 {
    /** Subscription prices. */
    subscriptionPrices?: SubscriptionPrice$1[];
}
interface SubscriptionPrice$1 {
    /**
     * Subscription ID.
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Subscription price calculated by applying subscription discount to the variant `price.salePrice`
     * @readonly
     */
    price?: FixedMonetaryAmount$1;
    /**
     * Price per unit info.
     * @readonly
     */
    pricePerUnit?: SubscriptionPricePerUnit$1;
}
interface SubscriptionPricePerUnit$1 {
    /**
     * Calculated value of price per unit. Takes into account `pricePerUnit` settings of parent product, `pricePerUnit` settings of this variant, and the variant subscription price.
     * @readonly
     */
    value?: string;
    /**
     * Price per unit description.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    description?: string | null;
}
interface InventoryStatus$1 {
    /** Whether the variant is in stock. */
    inStock?: boolean;
    /** Whether preorder is enabled for this variant. */
    preorderEnabled?: boolean;
}
interface ExtendedFields$1 {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface SubscriptionDetails$1 {
    /** Subscriptions. */
    subscriptions?: Subscription$1[];
    /**
     * Whether to allow one-time purchases in addition to subscription-based purchases.
     *
     * Default: `false`
     */
    allowOneTimePurchases?: boolean | null;
}
interface Subscription$1 extends SubscriptionCyclesOneOf$1 {
    /** Whether subscription is renewed automatically at the end of each period. Cannot be `false`, instead set `billingCycles`. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. */
    billingCycles?: number;
    /** Subscription ID. */
    id?: string | null;
    /** Subscription title. */
    title?: string;
    /** Subscription description. */
    description?: string | null;
    /**
     * Whether the subscription is visible to site visitors.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /**
     * Frequency of recurring payment.
     * For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months.
     */
    frequency?: SubscriptionFrequency$3;
    /** Interval of recurring payment. Default: `1`. For example, if `frequency: MONTH`, `billingCycles: 3` and `interval: 2`; payment will be made every 2 months for a total of 6 months. */
    interval?: number | null;
    /**
     * Discount info (optional).
     * For example, a $20 discount would be `amount: 20`, `type: AMOUNT`.
     */
    discount?: SubscriptionDiscount$1;
}
/** @oneof */
interface SubscriptionCyclesOneOf$1 {
    /** Whether subscription is renewed automatically at the end of each period. Cannot be `false`, instead set `billingCycles`. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. */
    billingCycles?: number;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency$3 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface SubscriptionDiscount$1 extends SubscriptionDiscountDiscountOneOf$1 {
    /** Amount to discount from the variant discounted_price. */
    amountOff?: string;
    /** Percentage to discount from variant discounted_price. */
    percentOff?: number;
    /** Discount type. */
    type?: DiscountType$3;
}
/** @oneof */
interface SubscriptionDiscountDiscountOneOf$1 {
    /** Amount to discount from the variant discounted_price. */
    amountOff?: string;
    /** Percentage to discount from variant discounted_price. */
    percentOff?: number;
}
declare enum DiscountType$3 {
    UNKNOWN_DISCOUNT = "UNKNOWN_DISCOUNT",
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface VariantSummary$1 {
    /**
     * The total number of variants for the product.
     * @readonly
     */
    variantCount?: number;
}
interface CreateProductRequest$1 {
    /**
     * Product to create.
     *
     * At least 1 variant must be provided and each variant must have relevant item in `choices` field for every item in `options`.
     * If `options` is empty one default variant must be provided with empty `choices` list.
     */
    product: V3Product$1;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
declare enum SingleEntityOpsRequestedFields$1 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    URL = "URL",
    CURRENCY = "CURRENCY",
    INFO_SECTION = "INFO_SECTION",
    /** You can request merchant data only if you have `WIX_STORES.PRODUCT_MERCHANT_DATA_READ` permission. */
    MERCHANT_DATA = "MERCHANT_DATA",
    PLAIN_DESCRIPTION = "PLAIN_DESCRIPTION",
    INFO_SECTION_PLAIN_DESCRIPTION = "INFO_SECTION_PLAIN_DESCRIPTION",
    SUBSCRIPTION_PRICES_INFO = "SUBSCRIPTION_PRICES_INFO",
    VARIANTS_INFO = "VARIANTS_INFO",
    BREADCRUMBS_INFO = "BREADCRUMBS_INFO",
    WEIGHT_MEASUREMENT_UNIT_INFO = "WEIGHT_MEASUREMENT_UNIT_INFO",
    VARIANT_OPTION_CHOICE_NAMES = "VARIANT_OPTION_CHOICE_NAMES",
    MEDIA_ITEMS_INFO = "MEDIA_ITEMS_INFO",
    DESCRIPTION = "DESCRIPTION",
    DIRECT_CATEGORIES_INFO = "DIRECT_CATEGORIES_INFO",
    ALL_CATEGORIES_INFO = "ALL_CATEGORIES_INFO",
    MIN_VARIANT_PRICE_INFO = "MIN_VARIANT_PRICE_INFO",
    INFO_SECTION_DESCRIPTION = "INFO_SECTION_DESCRIPTION",
    THUMBNAIL = "THUMBNAIL",
    DIRECT_CATEGORY_IDS = "DIRECT_CATEGORY_IDS"
}
interface CreateProductResponse$1 {
    /** Created product. */
    product?: V3Product$1;
}
interface CreateProductWithInventoryRequest$1 {
    /**
     * Product to create with inventory.
     *
     * At least one variant must be provided and each variant must have relevant item in `choices` field for every item in `options`.
     * If `options` is empty one default variant must be provided with empty `choices` list.
     */
    product: ProductWithInventory$1;
    /**
     * Whether to return inventory entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
interface ProductWithInventory$1 extends ProductWithInventoryTypedPropertiesOneOf$1 {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties$1;
    /**
     * Product ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the product is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the product.
     *
     * Ignored when creating a product with inventory.
     * @readonly
     */
    revision?: string | null;
    /** Product name. */
    name?: string | null;
    /**
     * Product slug.
     *
     * If not provided, the slug is autogenerated based on the product name.
     */
    slug?: string | null;
    /**
     * Product description in HTML.
     *
     * + When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * + `plainDescription` is ignored when value is also passed to the `description` field.
     * > **Note:** Returned only when you pass `"PLAIN_DESCRIPTION"` to the `fields` array in Products API requests.
     */
    plainDescription?: string | null;
    /**
     * Whether the product is visible to site visitors on the site.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /**
     * Whether the product is visible in POS (point of sale).
     *
     * Default: `true`
     * > **Note:** Always `false` for `productType: DIGITAL`.
     */
    visibleInPos?: boolean | null;
    /** Product media items. */
    media?: Media$1;
    /** Product SEO data. */
    seoData?: SeoSchema$1;
    /** Tax group ID. */
    taxGroupId?: string | null;
    /**
     * Product options. Allows buyer to customize product, e.g. select Color, Size and so on.
     * Always generates variants: every variant must have exactly one choice related to each option.
     * Since options and variants tightly coupled and rely on each other they usually should be provided together in all operations.
     * For existing options and choices provide ids only, all other data (e.g. names, title, types and so on) will be resolved for you by ids.
     * If you don't have ids it's ok to omit them but provide all other data instead. For existing options ids will be resolved, not existing options will be created.
     * *None*: you cannot change name of existing option via this endpoint but you can do it by calling CustomizationService
     */
    options?: ConnectedOption$1[];
    /**
     * Product Modifiers. Allows buyer to customize product, e.g. select Color, Size and so on similarly to `options` but with one main difference - `modifiers` never generate any variants.
     * For existing modifiers and choices provide ids only, all other data (e.g. names, title, types and so on) will be resolved for you by ids.
     * If you don't have ids it's ok to omit them but provide all other data instead. For existing modifiers ids will be resolved, not existing modifiers will be created.
     * *None*: you cannot change name of existing modifier via this endpoint by passing id and changed name, if you pass id name will be ignored. If you want to update existing modifier name do it by calling CustomizationService
     */
    modifiers?: ConnectedModifier$1[];
    /**
     * Product brand.
     *
     * + Pass `brand.name` to add a new brand while creating a product.
     * + Pass an existing brand's `id` to assign that brand to the product.
     */
    brand?: Brand$1;
    /**
     * Product info section.
     *
     * + Pass `infoSection.uniqueName`, `infoSection.title`, and `infoSection.description` to add a new info section while creating a product.
     * + Pass an existing info section's `id` or `uniqueName` to assign that info section to the product.
     */
    infoSections?: InfoSection$1[];
    /**
     * Product ribbon.
     *
     * + Pass `ribbon.name` to add a new ribbon while creating a product.
     * + Pass an existing ribbon's `id` or `name` to assign that ribbon to the product.
     */
    ribbon?: Ribbon$3;
    /** Main category ID. */
    mainCategoryId?: string | null;
    /**
     * Product type.
     *
     * When passing `productType: PHYSICAL`, you must also pass `physicalProperties`.
     */
    productType?: ProductType$1;
    /**
     * A unique human-friendly identifier for the product.
     * Unlike the product ID, the handle can be set by the user to ensure consistency across multiple platforms.
     * In case handle wasn't given, the handle will be automatically generated.
     */
    handle?: string | null;
    /** Product variants. */
    variantsInfo?: V3VariantsInfo$1;
    /** Subscription details. */
    subscriptionDetails?: SubscriptionDetails$1;
    /**
     * Custom extended fields for the product object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the Wix Dev Center before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields$1;
}
/** @oneof */
interface ProductWithInventoryTypedPropertiesOneOf$1 {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties$1;
}
interface V3VariantsInfo$1 {
    /**
     * List of related variants.
     * Partial update of variants is not supported so on update you must pass all data for all of them.
     * If you want to update existing variant you must provide `id`, otherwise new variant with different id will be created which might break some integrations that rely on variant ids.
     */
    variants?: VariantWithInventory$1[];
}
interface VariantWithInventory$1 extends VariantWithInventoryTypedPropertiesOneOf$1 {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties$1;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties$1;
    /** Variant ID. */
    id?: string | null;
    /**
     * Whether the variant is visible to site visitors.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string | null;
    /** Variant barcode. */
    barcode?: string | null;
    /** Variant price. */
    price?: PriceInfo$1;
    /**
     * Variant revenue details.
     *
     * > **Note:** Returned only when the following conditions are met:
     * > + You pass `"MERCHANT_DATA"` to the `fields` array in Products API requests.
     * > + Your app has the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     */
    revenueDetails?: RevenueDetails$1;
    /** Inventory item of the variant on the default location. */
    inventoryItem?: InventoryItemComposite$1;
    /** List of choices. */
    choices?: OptionChoiceReferences$1[];
}
/** @oneof */
interface VariantWithInventoryTypedPropertiesOneOf$1 {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties$1;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties$1;
}
interface InventoryItemComposite$1 extends InventoryItemCompositeTrackingMethodOneOf$1 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Inventory item revision.
     * @readonly
     */
    revision?: string | null;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo$3;
}
/** @oneof */
interface InventoryItemCompositeTrackingMethodOneOf$1 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
interface PreorderInfo$3 {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /** A message the customer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
interface OptionChoiceReferences$1 {
    /** Option and choice IDs. */
    optionChoiceIds?: V3OptionChoiceIds$1;
    /** Option and choice names. */
    optionChoiceNames?: V3OptionChoiceNames$1;
}
interface V3OptionChoiceIds$1 {
    /** Option ID. */
    optionId?: string;
    /** Choice ID. */
    choiceId?: string;
}
interface V3OptionChoiceNames$1 {
    /** Option name. */
    optionName?: string;
    /** Choice name. */
    choiceName?: string;
    /** Render type. */
    renderType?: ProductOptionRenderType$1;
}
interface CreateProductWithInventoryResponse$1 {
    /** Created product. */
    product?: V3Product$1;
    /** Inventories created by bulk action. */
    inventoryResults?: BulkInventoryItemResults$1;
}
interface BulkInventoryItemResults$1 {
    /** Inventories modified by bulk action. */
    results?: BulkInventoryItemResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
    /** Error details in case of failed action. */
    error?: ApplicationError$3;
}
interface BulkInventoryItemResult$1 {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: CommonItemMetadata$1;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem$1;
}
interface CommonItemMetadata$1 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$3;
}
interface ApplicationError$3 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/** Inventory Item. */
interface InventoryItem$1 extends InventoryItemTrackingMethodOneOf$1 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus$1;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo$3;
    /**
     * Product.
     * @readonly
     */
    product?: Product$1;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields$1;
}
/** @oneof */
interface InventoryItemTrackingMethodOneOf$1 {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
declare enum AvailabilityStatus$1 {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    IN_STOCK = "IN_STOCK",
    /**
     * Whether the variant is available for preorder. InventoryItem will be available only when all below conditions are met:
     * 1. the variant is out of stock
     * 2. preorder is enabled on inventory item level (preorder_setting.enabled is true)
     * 3. preorder limit wasn't reached (preorder_setting.limit)
     */
    PREORDER = "PREORDER"
}
interface Product$1 {
    /** Product name. */
    name?: string | null;
    /** List of category IDs that this product is included in directly. */
    directCategoryIds?: string[];
    /** Variant name. */
    variantName?: string | null;
    /** Variant SKU (stock keeping unit). */
    variantSku?: string | null;
}
interface CommonBulkActionMetadata$1 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateProductRequest$1 {
    /** Product to update. */
    product: V3Product$1;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
interface UpdateProductResponse$1 {
    /** Updated product. */
    product?: V3Product$1;
}
interface UpdateProductWithInventoryRequest$1 {
    /** Product to update. */
    product: ProductWithInventory$1;
    /**
     * Whether to return the full inventory entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
interface UpdateProductWithInventoryResponse$1 {
    /** Updated product. */
    product?: V3Product$1;
    /** Inventories updated by bulk action. */
    inventoryResults?: BulkInventoryItemResults$1;
}
interface BulkCreateProductsRequest$1 {
    /** List of products to create. */
    products: V3Product$1[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
declare enum RequestedFields$3 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    URL = "URL",
    CURRENCY = "CURRENCY",
    INFO_SECTION = "INFO_SECTION",
    /** You can request merchant data only if you have `WIX_STORES.PRODUCT_MERCHANT_DATA_READ` permission. */
    MERCHANT_DATA = "MERCHANT_DATA",
    PLAIN_DESCRIPTION = "PLAIN_DESCRIPTION",
    INFO_SECTION_PLAIN_DESCRIPTION = "INFO_SECTION_PLAIN_DESCRIPTION",
    SUBSCRIPTION_PRICES_INFO = "SUBSCRIPTION_PRICES_INFO",
    VARIANTS_INFO = "VARIANTS_INFO",
    BREADCRUMBS_INFO = "BREADCRUMBS_INFO",
    WEIGHT_MEASUREMENT_UNIT_INFO = "WEIGHT_MEASUREMENT_UNIT_INFO",
    VARIANT_OPTION_CHOICE_NAMES = "VARIANT_OPTION_CHOICE_NAMES",
    MEDIA_ITEMS_INFO = "MEDIA_ITEMS_INFO",
    DESCRIPTION = "DESCRIPTION",
    DIRECT_CATEGORIES_INFO = "DIRECT_CATEGORIES_INFO",
    ALL_CATEGORIES_INFO = "ALL_CATEGORIES_INFO",
    MIN_VARIANT_PRICE_INFO = "MIN_VARIANT_PRICE_INFO",
    INFO_SECTION_DESCRIPTION = "INFO_SECTION_DESCRIPTION",
    THUMBNAIL = "THUMBNAIL",
    DIRECT_CATEGORY_IDS = "DIRECT_CATEGORY_IDS"
}
interface BulkCreateProductsResponse$1 {
    /** Products created by bulk action. */
    results?: CatalogV3BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
}
interface CatalogV3BulkProductResult$1 {
    /** Information about successful action or error for failure. */
    itemMetadata?: WixCommonItemMetadata$1;
    /**
     * Full product entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: V3Product$1;
}
interface WixCommonItemMetadata$1 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$3;
}
interface BulkCreateProductsWithInventoryRequest$1 {
    /** List of products to create with inventory. */
    products: ProductWithInventory$1[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface BulkCreateProductsWithInventoryResponse$1 {
    /** Products created by bulk action. */
    productResults?: BulkProductResults$1;
    /** Inventories created by bulk action. */
    inventoryResults?: BulkInventoryItemResults$1;
}
interface BulkProductResults$1 {
    /** Products modified by bulk action. */
    results?: CatalogV3BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
}
interface BulkUpdateProductsRequest$1 {
    /** List of products to update. */
    products: V3MaskedProduct$1[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface V3MaskedProduct$1 {
    /** Product to update. */
    product?: V3Product$1;
}
interface BulkUpdateProductsResponse$1 {
    /** Products updated by bulk action. */
    results?: CatalogV3BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
}
interface BulkUpdateProductsWithInventoryRequest$1 {
    /** List of products to update. */
    products: MaskedProductWithInventory$1[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface MaskedProductWithInventory$1 {
    /** Product to update. */
    product?: ProductWithInventory$1;
}
interface BulkUpdateProductsWithInventoryResponse$1 {
    /** Products updated by bulk action. */
    productResults?: BulkProductResults$1;
    /** Inventories updated by bulk action. */
    inventoryResults?: BulkInventoryItemResults$1;
}
interface V3BulkUpdateProductsByFilterRequest$1 {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Product to update. */
    product: V3Product$1;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface WixCommonSearchDetails$1 {
    /** Defines how separate search terms in `expression` are combined */
    mode?: CommonSearchDetailsMode$1;
    /** Search term or expression */
    expression?: string | null;
    /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path */
    fields?: string[];
    /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
    fuzzy?: boolean;
}
declare enum CommonSearchDetailsMode$1 {
    /** Any of the search terms must be present */
    OR = "OR",
    /** All search terms must be present */
    AND = "AND"
}
interface V3BulkUpdateProductsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3UpdateExtendedFieldsRequest$1 {
    /** Product ID. */
    productId: string;
    /** App namespace. */
    namespace: string;
    /** Data to update. */
    namespaceData: Record<string, any> | null;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
interface V3UpdateExtendedFieldsResponse$1 {
    /** Updated product. */
    product?: V3Product$1;
}
interface V3DeleteProductRequest$1 {
    /** Product ID. */
    productId: string;
}
interface V3DeleteProductResponse$1 {
}
interface V3BulkDeleteProductsRequest$1 {
    /** IDs of products to delete. */
    productIds: string[];
}
interface V3BulkDeleteProductsResponse$1 {
    /** Products deleted by bulk action. */
    results?: BulkDeleteProductsResponseBulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
}
interface BulkDeleteProductsResponseBulkProductResult$1 {
    /** Bulk action metadata for products. */
    itemMetadata?: WixCommonItemMetadata$1;
}
interface V3BulkDeleteProductsByFilterRequest$1 {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface V3BulkDeleteProductsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3GetProductRequest$1 {
    /** Product ID. */
    productId: string;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
interface V3GetProductResponse$1 {
    /** Product. */
    product?: V3Product$1;
}
interface V3GetProductBySlugRequest$1 {
    /** Product slug. */
    slug: string;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields$1[];
}
interface V3GetProductBySlugResponse$1 {
    /** Product. */
    product?: V3Product$1;
}
interface V3SearchProductsRequest$1 {
    /** Search options. */
    search?: CommonCursorSearch$1;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface CommonCursorSearch$1 extends CommonCursorSearchPagingMethodOneOf$1 {
    /**
     * Cursor pointing to page of results.
     * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
     */
    cursorPaging?: CommonCursorPaging$1;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: WixCommonSorting$1[];
    /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: WixCommonAggregation$1[];
    /** Free text to match in searchable fields */
    search?: WixCommonSearchDetails$1;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
     */
    timeZone?: string | null;
}
/** @oneof */
interface CommonCursorSearchPagingMethodOneOf$1 {
    /**
     * Cursor pointing to page of results.
     * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
     */
    cursorPaging?: CommonCursorPaging$1;
}
interface WixCommonSorting$1 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: WixCommonSortOrder$1;
    /**
     * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
     * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
     *
     * If multiple filters are provided, they are combined with AND operator.
     *
     * Example:
     * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
     * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
     * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
     */
    selectItemsBy?: Record<string, any>[] | null;
}
declare enum WixCommonSortOrder$1 {
    ASC = "ASC",
    DESC = "DESC"
}
interface WixCommonAggregation$1 extends WixCommonAggregationKindOneOf$1 {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation$1;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation$1;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation$1;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation$1;
    /** Nested aggregation */
    nested?: CommonAggregationNestedAggregation$1;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: WixCommonAggregationType$1;
    /** Field to aggregate by, use dot notation to specify json path */
    fieldPath?: string;
}
/** @oneof */
interface WixCommonAggregationKindOneOf$1 {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation$1;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation$1;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation$1;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation$1;
    /** Nested aggregation */
    nested?: CommonAggregationNestedAggregation$1;
}
interface AggregationRangeAggregationRangeBucket$1 {
    /** Inclusive lower bound of the range. Required if to is not given */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if from is not given */
    to?: number | null;
}
declare enum AggregationValueAggregationSortType$1 {
    /** Should sort by number of matches */
    COUNT = "COUNT",
    /** Should sort by value of the field alphabetically */
    VALUE = "VALUE"
}
declare enum AggregationValueAggregationSortDirection$1 {
    /** Should sort in descending order */
    DESC = "DESC",
    /** Should sort in ascending order */
    ASC = "ASC"
}
declare enum AggregationValueAggregationMissingValues$1 {
    /** Should missing values be excluded from the aggregation results */
    EXCLUDE = "EXCLUDE",
    /** Should missing values be included in the aggregation results */
    INCLUDE = "INCLUDE"
}
interface AggregationValueAggregationIncludeMissingValuesOptions$1 {
    /** Can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
    addToBucket?: string;
}
declare enum WixCommonScalarType$1 {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value */
    MIN = "MIN",
    /** Maximum value */
    MAX = "MAX",
    /** Sum of values */
    SUM = "SUM",
    /** Average of values */
    AVG = "AVG"
}
interface CommonAggregationValueAggregation$1 extends CommonAggregationValueAggregationOptionsOneOf$1 {
    /** Options for including missing values */
    includeOptions?: AggregationValueAggregationIncludeMissingValuesOptions$1;
    /** Should sort by number of matches or value of the field */
    sortType?: AggregationValueAggregationSortType$1;
    /** Should sort in ascending or descending order */
    sortDirection?: AggregationValueAggregationSortDirection$1;
    /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
    missingValues?: AggregationValueAggregationMissingValues$1;
}
/** @oneof */
interface CommonAggregationValueAggregationOptionsOneOf$1 {
    /** Options for including missing values */
    includeOptions?: AggregationValueAggregationIncludeMissingValuesOptions$1;
}
declare enum AggregationNestedAggregationNestedAggregationType$1 {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
interface CommonAggregationRangeAggregation$1 {
    /** List of range buckets, where during aggregation each entity will be placed in the first bucket where its value falls into based on provided range bounds */
    buckets?: AggregationRangeAggregationRangeBucket$1[];
}
interface CommonAggregationScalarAggregation$1 {
    /** Define the operator for the scalar aggregation */
    type?: WixCommonScalarType$1;
}
interface CommonAggregationDateHistogramAggregation$1 {
    /** Interval for date histogram aggregation */
    interval?: AggregationDateHistogramAggregationInterval$1;
}
declare enum AggregationDateHistogramAggregationInterval$1 {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
interface AggregationNestedAggregationNestedAggregationItem$1 extends AggregationNestedAggregationNestedAggregationItemKindOneOf$1 {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation$1;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation$1;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation$1;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation$1;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: AggregationNestedAggregationNestedAggregationType$1;
    /** Field to aggregate by, use dont notation to specify json path */
    fieldPath?: string;
}
/** @oneof */
interface AggregationNestedAggregationNestedAggregationItemKindOneOf$1 {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation$1;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation$1;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation$1;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation$1;
}
declare enum WixCommonAggregationType$1 {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one */
    NESTED = "NESTED"
}
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
interface CommonAggregationNestedAggregation$1 {
    /** Flattened list of aggregations, where each next aggregation is nested within previous one */
    nestedAggregations?: AggregationNestedAggregationNestedAggregationItem$1[];
}
interface CommonCursorPaging$1 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface V3SearchProductsResponse$1 {
    /** List of products. */
    products?: V3Product$1[];
    /** Paging metadata. */
    pagingMetadata?: CommonCursorPagingMetadata$1;
    /** Aggregation data. */
    aggregationData?: CommonAggregationData$1;
}
interface CommonCursorPagingMetadata$1 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: CommonCursors$1;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface CommonCursors$1 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface CommonAggregationData$1 {
    /** key = aggregation name (as derived from search request) */
    results?: AggregationDataAggregationResults$1[];
}
interface ValueResultsValueAggregationResult$1 {
    /** Value of the field */
    value?: string;
    /** Count of entities with this value */
    count?: number;
}
interface RangeResultsRangeAggregationResult$1 {
    /** Inclusive lower bound of the range */
    from?: number | null;
    /** Exclusive upper bound of the range */
    to?: number | null;
    /** Count of entities in this range */
    count?: number;
}
interface AggregationResultsNestedAggregationResults$1 extends AggregationResultsNestedAggregationResultsResultOneOf$1 {
    /** Value aggregation results */
    values?: AggregationResultsValueResults$1;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults$1;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult$1;
    /** User-defined name of aggregation, matches the one provided in request */
    name?: string;
    /** Type of aggregation that matches result */
    type?: WixCommonAggregationType$1;
    /** Field to aggregate by, matches the one provided in request */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsNestedAggregationResultsResultOneOf$1 {
    /** Value aggregation results */
    values?: AggregationResultsValueResults$1;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults$1;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult$1;
}
interface AggregationResultsValueResults$1 {
    /** List of value aggregations */
    results?: ValueResultsValueAggregationResult$1[];
}
interface AggregationResultsRangeResults$1 {
    /** List of ranges returned in same order as requested */
    results?: RangeResultsRangeAggregationResult$1[];
}
interface AggregationDataAggregationResultsScalarResult$1 {
    /** Type of scalar aggregation */
    type?: WixCommonScalarType$1;
    /** Value of the scalar aggregation */
    value?: number;
}
interface GroupByValueResultsNestedValueAggregationResult$1 {
    /** Value of the field */
    value?: string;
    /** Nested aggregations */
    nestedResults?: AggregationResultsNestedAggregationResults$1;
}
interface NestedResultsValueResult$1 {
    /** Value of the field */
    value?: string;
    /** Count of entities with this value */
    count?: number | null;
}
interface NestedResultsRangeResult$1 {
    /** Inclusive lower bound of the range */
    from?: number | null;
    /** Exclusive upper bound of the range */
    to?: number | null;
    /** Count of entities in this range */
    count?: number | null;
}
interface NestedResultsScalarResult$1 {
    /** Value of the scalar aggregation */
    value?: number;
}
interface NestedResultsNestedResultValue$1 extends NestedResultsNestedResultValueResultOneOf$1 {
    /** Value aggregation result */
    value?: NestedResultsValueResult$1;
    /** Range aggregation result */
    range?: NestedResultsRangeResult$1;
    /** Scalar aggregation result */
    scalar?: NestedResultsScalarResult$1;
    /** Date histogram aggregation result */
    dateHistogram?: NestedResultsValueResult$1;
}
/** @oneof */
interface NestedResultsNestedResultValueResultOneOf$1 {
    /** Value aggregation result */
    value?: NestedResultsValueResult$1;
    /** Range aggregation result */
    range?: NestedResultsRangeResult$1;
    /** Scalar aggregation result */
    scalar?: NestedResultsScalarResult$1;
    /** Date histogram aggregation result */
    dateHistogram?: NestedResultsValueResult$1;
}
interface NestedResultsResults$1 {
    /** List of nested aggregations */
    results?: Record<string, NestedResultsNestedResultValue$1>;
}
interface DateHistogramResultsDateHistogramResult$1 {
    /** Date in ISO 8601 format */
    value?: string;
    /** Count of documents in the bucket */
    count?: number;
}
interface AggregationResultsGroupByValueResults$1 {
    /** List of value aggregations */
    results?: GroupByValueResultsNestedValueAggregationResult$1[];
}
interface AggregationResultsDateHistogramResults$1 {
    /** List of date histogram aggregations */
    results?: DateHistogramResultsDateHistogramResult$1[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form
 * aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface AggregationResultsNestedResults$1 {
    /** List of nested aggregations */
    results?: NestedResultsResults$1[];
}
interface AggregationDataAggregationResults$1 extends AggregationDataAggregationResultsResultOneOf$1 {
    /** Value aggregation results */
    values?: AggregationResultsValueResults$1;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults$1;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult$1;
    /** Group by value aggregation results */
    groupedByValue?: AggregationResultsGroupByValueResults$1;
    /** Date histogram aggregation results */
    dateHistogram?: AggregationResultsDateHistogramResults$1;
    /** Nested aggregation results */
    nested?: AggregationResultsNestedResults$1;
    /** User-defined name of aggregation as derived from search request */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request */
    type?: WixCommonAggregationType$1;
    /** Field to aggregate by as derived from search request */
    fieldPath?: string;
}
/** @oneof */
interface AggregationDataAggregationResultsResultOneOf$1 {
    /** Value aggregation results */
    values?: AggregationResultsValueResults$1;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults$1;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult$1;
    /** Group by value aggregation results */
    groupedByValue?: AggregationResultsGroupByValueResults$1;
    /** Date histogram aggregation results */
    dateHistogram?: AggregationResultsDateHistogramResults$1;
    /** Nested aggregation results */
    nested?: AggregationResultsNestedResults$1;
}
interface V3QueryProductsRequest$1 {
    /** Query options. */
    query?: CommonCursorQuery$1;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface CommonCursorQuery$1 extends CommonCursorQueryPagingMethodOneOf$1 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CommonCursorPaging$1;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: WixCommonSorting$1[];
}
/** @oneof */
interface CommonCursorQueryPagingMethodOneOf$1 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CommonCursorPaging$1;
}
interface V3QueryProductsResponse$1 {
    /** List of products. */
    products?: V3Product$1[];
    /** Paging metadata. */
    pagingMetadata?: CommonCursorPagingMetadata$1;
}
interface V3CountProductsRequest$1 {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
    /**
     * Whether to return non-visible products (`visible:false`). Your app must have the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     *
     * Default: `false`
     */
    returnNonVisibleProducts?: boolean;
}
interface V3CountProductsResponse$1 {
    /** Total number of products. */
    count?: number;
}
interface BulkUpdateProductVariantsByFilterRequest$1 {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Variant to update. */
    variant: Variant$1;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface BulkUpdateProductVariantsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface BulkAdjustProductVariantsByFilterRequest$1 {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Base price adjustment. */
    basePrice?: V3AdjustValue$1;
    /** Sale price adjustment. */
    salePrice?: V3AdjustValue$1;
    /** Cost adjustment. */
    cost?: V3AdjustValue$1;
    /**
     * Set variant sale price from base price by applying provided discount to it.
     * For example variant base price 100$, variant sale price 95$, requested `salePriceFromBasePrice.percentage` is 10, then old sale price ignored and new sale price set to 90 (100$ - 10%).
     */
    salePriceFromBasePrice?: V3UnsignedAdjustValue$1;
    /**
     * Rounding strategy of new calculated prices.
     *
     * + `NO_ROUNDING`: Calculated prices will be saved without rounding to keep max possible precision.
     * + `CURRENCY_PRECISION`: Calculated prices will be rounded according to the currency's precision requirements. For example. `$3.5555` will be saved as `$3.56`; `¥3.5555` will be saved as `¥4`.
     * + `NEAREST_WHOLE_NUMBER`: Calculated prices will be rounded to the nearest whole number.
     */
    rounding?: BulkAdjustProductVariantsByFilterRequestRoundingStrategy$1;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface V3AdjustValue$1 extends V3AdjustValueAdjustValueOneOf$1 {
    /** A decimal value to increase or reduce from the original value, can be negative. */
    amount?: string;
    /** The percentage value to increase or reduce from the current value, can be negative. */
    percentage?: number;
}
/** @oneof */
interface V3AdjustValueAdjustValueOneOf$1 {
    /** A decimal value to increase or reduce from the original value, can be negative. */
    amount?: string;
    /** The percentage value to increase or reduce from the current value, can be negative. */
    percentage?: number;
}
interface V3UnsignedAdjustValue$1 extends V3UnsignedAdjustValueAdjustValueOneOf$1 {
    /** A decimal value to reduce from the original value. */
    amount?: string;
    /** The percentage value to reduce from the original value. */
    percentage?: number;
}
/** @oneof */
interface V3UnsignedAdjustValueAdjustValueOneOf$1 {
    /** A decimal value to reduce from the original value. */
    amount?: string;
    /** The percentage value to reduce from the original value. */
    percentage?: number;
}
declare enum BulkAdjustProductVariantsByFilterRequestRoundingStrategy$1 {
    UNKNOWN_ROUNDING_STRATEGY = "UNKNOWN_ROUNDING_STRATEGY",
    /**
     * Calculated prices will be saved without rounding to keep max possible precision. It's still good idea to round numbers before displaying them.
     * Example: input $3.5555 -> saved value $3.5555
     */
    NO_ROUNDING = "NO_ROUNDING",
    /**
     * Calculated prices will be rounded according to currency precision.
     * Example: input $3.5555 -> saved value $3.56, input ¥3.5555 -> saved value ¥4
     */
    CURRENCY_PRECISION = "CURRENCY_PRECISION",
    /**
     * Calculated prices will be rounded to nearest whole number.
     * Example: input $3.5555 -> saved value $4
     */
    NEAREST_WHOLE_NUMBER = "NEAREST_WHOLE_NUMBER"
}
interface BulkAdjustProductVariantsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3BulkAddInfoSectionsToProductsByFilterRequest$1 {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** IDs of the info sections to add. */
    infoSectionIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface V3BulkAddInfoSectionsToProductsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3BulkAddInfoSectionsToProductsRequest$1 {
    /** List of product IDs and revisions. */
    products: V3ProductIdWithRevision$1[];
    /** List of IDs of info sections to add. */
    infoSectionIds: string[];
    /**
     * Whether to return the full updated product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface V3ProductIdWithRevision$1 {
    /** Product ID. */
    productId?: string;
    /**
     * Revision number, which increments by 1 each time the product is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the product.
     */
    revision?: string;
}
interface V3BulkAddInfoSectionsToProductsResponse$1 {
    /** Products updated by bulk action. */
    results?: CatalogV3BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
}
interface V3BulkRemoveInfoSectionsFromProductsByFilterRequest$1 {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** IDs of info sections to remove. */
    infoSectionIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface V3BulkRemoveInfoSectionsFromProductsByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3BulkRemoveInfoSectionsFromProductsRequest$1 {
    /** List of product IDs and revisions. */
    products: V3ProductIdWithRevision$1[];
    /** List of IDs of info sections to remove. */
    infoSectionIds: string[];
    /**
     * Whether to return the full updated product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$3[];
}
interface V3BulkRemoveInfoSectionsFromProductsResponse$1 {
    /** Products updated by bulk action. */
    results?: CatalogV3BulkProductResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata$1;
}
interface BulkAddProductsToCategoriesByFilterRequest$1 {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** IDs of the categories to which products will be added. */
    categoryIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface BulkAddProductsToCategoriesByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface BulkRemoveProductsFromCategoriesByFilterRequest$1 {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** IDs of the categories from which products will be removed. */
    categoryIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails$1;
}
interface BulkRemoveProductsFromCategoriesByFilterResponse$1 {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface PricePerUnitSettingsNonNullableFields$1 {
    quantity: number;
    measurementUnit: MeasurementUnit$1;
}
interface WeightRangeNonNullableFields$1 {
    minValue: number;
    maxValue: number;
}
interface PricePerUnitRangePricePerUnitNonNullableFields$1 {
    value: string;
}
interface PricePerUnitRangeNonNullableFields$1 {
    minValue?: PricePerUnitRangePricePerUnitNonNullableFields$1;
    maxValue?: PricePerUnitRangePricePerUnitNonNullableFields$1;
}
interface WeightMeasurementUnitInfoNonNullableFields$1 {
    weightMeasurementUnit: WeightUnit$1;
}
interface PhysicalPropertiesNonNullableFields$1 {
    pricePerUnit?: PricePerUnitSettingsNonNullableFields$1;
    shippingWeightRange?: WeightRangeNonNullableFields$1;
    pricePerUnitRange?: PricePerUnitRangeNonNullableFields$1;
    weightMeasurementUnitInfo?: WeightMeasurementUnitInfoNonNullableFields$1;
}
interface PageUrlV2NonNullableFields {
    relativePath: string;
}
interface PluginContainerDataWidthNonNullableFields$1 {
    size: WidthType$1;
}
interface PluginContainerDataNonNullableFields$1 {
    width?: PluginContainerDataWidthNonNullableFields$1;
    alignment: PluginContainerDataAlignment$1;
}
interface LinkNonNullableFields$1 {
    url: string;
    anchor: string;
    target: Target$1;
}
interface ButtonDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    type: Type$1;
    link?: LinkNonNullableFields$1;
}
interface TextStyleNonNullableFields$1 {
    textAlignment: TextAlignment$1;
}
interface CodeBlockDataNonNullableFields$1 {
    textStyle?: TextStyleNonNullableFields$1;
}
interface DividerDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    lineStyle: LineStyle$1;
    width: Width$1;
    alignment: Alignment$1;
}
interface PDFSettingsNonNullableFields$1 {
    viewMode: ViewMode$1;
}
interface FileDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    pdfSettings?: PDFSettingsNonNullableFields$1;
}
interface ItemImageNonNullableFields {
    link?: LinkNonNullableFields$1;
}
interface ItemNonNullableFields$1 {
    image?: ItemImageNonNullableFields;
}
interface LayoutNonNullableFields$1 {
    type: LayoutType$1;
    orientation: Orientation$1;
}
interface ItemStyleNonNullableFields$1 {
    crop: Crop$1;
}
interface ThumbnailsNonNullableFields$1 {
    placement: ThumbnailsAlignment$1;
}
interface GalleryOptionsNonNullableFields$1 {
    layout?: LayoutNonNullableFields$1;
    item?: ItemStyleNonNullableFields$1;
    thumbnails?: ThumbnailsNonNullableFields$1;
}
interface GalleryDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    items: ItemNonNullableFields$1[];
    options?: GalleryOptionsNonNullableFields$1;
}
interface GIFDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    height: number;
    width: number;
}
interface HeadingDataNonNullableFields$1 {
    level: number;
    textStyle?: TextStyleNonNullableFields$1;
}
interface HTMLDataNonNullableFields$1 {
    url: string;
    html: string;
    containerData?: PluginContainerDataNonNullableFields$1;
    source: Source$1;
}
interface ImageDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    link?: LinkNonNullableFields$1;
}
interface LinkPreviewDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    link?: LinkNonNullableFields$1;
}
interface MapSettingsNonNullableFields$1 {
    mapType: MapType$1;
}
interface MapDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    mapSettings?: MapSettingsNonNullableFields$1;
}
interface ParagraphDataNonNullableFields$1 {
    textStyle?: TextStyleNonNullableFields$1;
}
interface PermissionsNonNullableFields$1 {
    view: ViewRole$1;
    vote: VoteRole$1;
}
interface PollSettingsNonNullableFields$1 {
    permissions?: PermissionsNonNullableFields$1;
}
interface PollNonNullableFields$1 {
    settings?: PollSettingsNonNullableFields$1;
}
interface PollLayoutNonNullableFields$1 {
    type: PollLayoutType$1;
    direction: PollLayoutDirection$1;
}
interface PollDataLayoutNonNullableFields$1 {
    poll?: PollLayoutNonNullableFields$1;
}
interface BackgroundNonNullableFields$1 {
    type: BackgroundType$1;
}
interface PollDesignNonNullableFields$1 {
    background?: BackgroundNonNullableFields$1;
}
interface DesignNonNullableFields$1 {
    poll?: PollDesignNonNullableFields$1;
}
interface PollDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    poll?: PollNonNullableFields$1;
    layout?: PollDataLayoutNonNullableFields$1;
    design?: DesignNonNullableFields$1;
}
interface AnchorDataNonNullableFields$1 {
    anchor: string;
}
interface LinkDataNonNullableFields$1 {
    link?: LinkNonNullableFields$1;
}
interface MentionDataNonNullableFields$1 {
    name: string;
    slug: string;
}
interface FontSizeDataNonNullableFields$1 {
    unit: FontType$1;
}
interface DecorationNonNullableFields$1 {
    anchorData?: AnchorDataNonNullableFields$1;
    linkData?: LinkDataNonNullableFields$1;
    mentionData?: MentionDataNonNullableFields$1;
    fontSizeData?: FontSizeDataNonNullableFields$1;
    type: DecorationType$1;
}
interface TextDataNonNullableFields$1 {
    text: string;
    decorations: DecorationNonNullableFields$1[];
}
interface AppEmbedDataNonNullableFields$1 {
    type: AppType$1;
}
interface VideoDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
}
interface EmbedDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
}
interface CollapsibleListDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    initialExpandedItems: InitialExpandedItems$1;
    direction: Direction$1;
}
interface DimensionsNonNullableFields$1 {
    colsWidthRatio: number[];
    rowsHeight: number[];
    colsMinWidth: number[];
}
interface TableDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
    dimensions?: DimensionsNonNullableFields$1;
}
interface CellStyleNonNullableFields$1 {
    verticalAlignment: VerticalAlignment$1;
}
interface TableCellDataNonNullableFields$1 {
    cellStyle?: CellStyleNonNullableFields$1;
}
interface AudioDataNonNullableFields$1 {
    containerData?: PluginContainerDataNonNullableFields$1;
}
interface OrderedListDataNonNullableFields$1 {
    indentation: number;
}
interface BulletedListDataNonNullableFields$1 {
    indentation: number;
}
interface BlockquoteDataNonNullableFields$1 {
    indentation: number;
}
interface CaptionDataNonNullableFields$1 {
    textStyle?: TextStyleNonNullableFields$1;
}
interface NodeNonNullableFields$1 {
    buttonData?: ButtonDataNonNullableFields$1;
    codeBlockData?: CodeBlockDataNonNullableFields$1;
    dividerData?: DividerDataNonNullableFields$1;
    fileData?: FileDataNonNullableFields$1;
    galleryData?: GalleryDataNonNullableFields$1;
    gifData?: GIFDataNonNullableFields$1;
    headingData?: HeadingDataNonNullableFields$1;
    htmlData?: HTMLDataNonNullableFields$1;
    imageData?: ImageDataNonNullableFields$1;
    linkPreviewData?: LinkPreviewDataNonNullableFields$1;
    mapData?: MapDataNonNullableFields$1;
    paragraphData?: ParagraphDataNonNullableFields$1;
    pollData?: PollDataNonNullableFields$1;
    textData?: TextDataNonNullableFields$1;
    appEmbedData?: AppEmbedDataNonNullableFields$1;
    videoData?: VideoDataNonNullableFields$1;
    embedData?: EmbedDataNonNullableFields$1;
    collapsibleListData?: CollapsibleListDataNonNullableFields$1;
    tableData?: TableDataNonNullableFields$1;
    tableCellData?: TableCellDataNonNullableFields$1;
    audioData?: AudioDataNonNullableFields$1;
    orderedListData?: OrderedListDataNonNullableFields$1;
    bulletedListData?: BulletedListDataNonNullableFields$1;
    blockquoteData?: BlockquoteDataNonNullableFields$1;
    captionData?: CaptionDataNonNullableFields$1;
    type: NodeType$1;
    id: string;
    nodes: NodeNonNullableFields$1[];
}
interface MetadataNonNullableFields$1 {
    version: number;
}
interface TextNodeStyleNonNullableFields$1 {
    decorations: DecorationNonNullableFields$1[];
}
interface DocumentStyleNonNullableFields$1 {
    headerOne?: TextNodeStyleNonNullableFields$1;
    headerTwo?: TextNodeStyleNonNullableFields$1;
    headerThree?: TextNodeStyleNonNullableFields$1;
    headerFour?: TextNodeStyleNonNullableFields$1;
    headerFive?: TextNodeStyleNonNullableFields$1;
    headerSix?: TextNodeStyleNonNullableFields$1;
    paragraph?: TextNodeStyleNonNullableFields$1;
    blockquote?: TextNodeStyleNonNullableFields$1;
    codeBlock?: TextNodeStyleNonNullableFields$1;
}
interface RichContentNonNullableFields$1 {
    nodes: NodeNonNullableFields$1[];
    metadata?: MetadataNonNullableFields$1;
    documentStyle?: DocumentStyleNonNullableFields$1;
}
interface ImageNonNullableFields$1 {
    id: string;
    url: string;
    height: number;
    width: number;
}
interface VideoResolutionNonNullableFields {
    url: string;
    height: number;
    width: number;
    poster?: ImageNonNullableFields$1;
    format: string;
}
interface VideoV2NonNullableFields {
    id: string;
    url: string;
    resolutions: VideoResolutionNonNullableFields[];
    posters: ImageNonNullableFields$1[];
}
interface ThumbnailNonNullableFields$1 {
    url: string;
    height: number;
    width: number;
}
interface ProductMediaNonNullableFields$1 {
    id: string;
    url: string;
    image?: ImageNonNullableFields$1;
    video?: VideoV2NonNullableFields;
    mediaType: MediaType$1;
    thumbnail?: ThumbnailNonNullableFields$1;
    uploadId: string;
}
interface MediaItemsInfoNonNullableFields$1 {
    items: ProductMediaNonNullableFields$1[];
}
interface MediaNonNullableFields$1 {
    main?: ProductMediaNonNullableFields$1;
    itemsInfo?: MediaItemsInfoNonNullableFields$1;
}
interface TagNonNullableFields$1 {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields$1 {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields$1 {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields$1[];
}
interface SeoSchemaNonNullableFields$1 {
    tags: TagNonNullableFields$1[];
    settings?: SettingsNonNullableFields$1;
}
interface MultipleColorsNonNullableFields$1 {
    colorCodes: string[];
}
interface ConnectedOptionChoiceNonNullableFields$1 {
    colorCode: string;
    colorCodes?: MultipleColorsNonNullableFields$1;
    image?: ImageNonNullableFields$1;
    linkedMedia: ProductMediaNonNullableFields$1[];
    choiceType: ChoiceType$1;
    key: string;
    inStock: boolean;
    visible: boolean;
}
interface ChoicesSettingsNonNullableFields$1 {
    choices: ConnectedOptionChoiceNonNullableFields$1[];
}
interface ConnectedOptionNonNullableFields$1 {
    choicesSettings?: ChoicesSettingsNonNullableFields$1;
    optionRenderType: ProductOptionRenderType$1;
    key: string;
}
interface FreeTextSettingsNonNullableFields$1 {
    minCharCount: number;
    maxCharCount: number;
    title: string;
    key: string;
}
interface ConnectedModifierChoiceNonNullableFields$1 {
    colorCode: string;
    colorCodes?: MultipleColorsNonNullableFields$1;
    image?: ImageNonNullableFields$1;
    linkedMedia: ProductMediaNonNullableFields$1[];
    choiceType: ChoiceType$1;
    key: string;
}
interface ModifierChoicesSettingsNonNullableFields$1 {
    choices: ConnectedModifierChoiceNonNullableFields$1[];
}
interface ConnectedModifierNonNullableFields$1 {
    freeTextSettings?: FreeTextSettingsNonNullableFields$1;
    choicesSettings?: ModifierChoicesSettingsNonNullableFields$1;
    modifierRenderType: ModifierRenderType$1;
    mandatory: boolean;
    key: string;
}
interface InfoSectionNonNullableFields$1 {
    description?: RichContentNonNullableFields$1;
}
interface ProductCategoryNonNullableFields$1 {
    id: string;
}
interface ProductCategoriesInfoNonNullableFields$1 {
    categories: ProductCategoryNonNullableFields$1[];
}
interface ProductCategoryIdsInfoNonNullableFields$1 {
    categoryIds: string[];
}
interface FixedMonetaryAmountNonNullableFields$1 {
    amount: string;
}
interface PriceRangeNonNullableFields$1 {
    minValue?: FixedMonetaryAmountNonNullableFields$1;
    maxValue?: FixedMonetaryAmountNonNullableFields$1;
}
interface InventoryNonNullableFields$1 {
    availabilityStatus: InventoryAvailabilityStatus$1;
    preorderStatus: PreorderStatus$1;
    preorderAvailability: ProductPreorderAvailability$1;
}
interface BreadCrumbNonNullableFields$1 {
    categoryId: string;
    categoryName: string;
    categorySlug: string;
}
interface BreadcrumbsInfoNonNullableFields$1 {
    breadcrumbs: BreadCrumbNonNullableFields$1[];
}
interface PricePerUnitNonNullableFields$1 {
    settings?: PricePerUnitSettingsNonNullableFields$1;
    value: string;
}
interface VariantPhysicalPropertiesNonNullableFields$1 {
    pricePerUnit?: PricePerUnitNonNullableFields$1;
}
interface SecuredMediaNonNullableFields$1 {
    id: string;
    fileName: string;
    fileType: FileType$1;
}
interface VariantDigitalPropertiesNonNullableFields$1 {
    digitalFile?: SecuredMediaNonNullableFields$1;
}
interface OptionChoiceIdsNonNullableFields$1 {
    optionId: string;
    choiceId: string;
}
interface OptionChoiceNamesNonNullableFields$1 {
    optionName: string;
    choiceName: string;
    renderType: ProductOptionRenderType$1;
}
interface OptionChoiceNonNullableFields$1 {
    optionChoiceIds?: OptionChoiceIdsNonNullableFields$1;
    optionChoiceNames?: OptionChoiceNamesNonNullableFields$1;
}
interface PriceInfoNonNullableFields$1 {
    basePrice?: FixedMonetaryAmountNonNullableFields$1;
    salePrice?: FixedMonetaryAmountNonNullableFields$1;
}
interface RevenueDetailsNonNullableFields$1 {
    cost?: FixedMonetaryAmountNonNullableFields$1;
    profit?: FixedMonetaryAmountNonNullableFields$1;
    profitMargin: number;
}
interface SubscriptionPricePerUnitNonNullableFields$1 {
    value: string;
}
interface SubscriptionPriceNonNullableFields$1 {
    subscriptionId: string;
    price?: FixedMonetaryAmountNonNullableFields$1;
    pricePerUnit?: SubscriptionPricePerUnitNonNullableFields$1;
}
interface SubscriptionPricesInfoNonNullableFields$1 {
    subscriptionPrices: SubscriptionPriceNonNullableFields$1[];
}
interface InventoryStatusNonNullableFields$1 {
    inStock: boolean;
    preorderEnabled: boolean;
}
interface VariantNonNullableFields$1 {
    physicalProperties?: VariantPhysicalPropertiesNonNullableFields$1;
    digitalProperties?: VariantDigitalPropertiesNonNullableFields$1;
    choices: OptionChoiceNonNullableFields$1[];
    price?: PriceInfoNonNullableFields$1;
    revenueDetails?: RevenueDetailsNonNullableFields$1;
    media?: ProductMediaNonNullableFields$1;
    subscriptionPricesInfo?: SubscriptionPricesInfoNonNullableFields$1;
    inventoryStatus?: InventoryStatusNonNullableFields$1;
}
interface VariantsInfoNonNullableFields$1 {
    variants: VariantNonNullableFields$1[];
}
interface SubscriptionDiscountNonNullableFields$1 {
    amountOff: string;
    percentOff: number;
    type: DiscountType$3;
}
interface SubscriptionNonNullableFields$1 {
    autoRenewal: boolean;
    billingCycles: number;
    title: string;
    frequency: SubscriptionFrequency$3;
    discount?: SubscriptionDiscountNonNullableFields$1;
}
interface SubscriptionDetailsNonNullableFields$1 {
    subscriptions: SubscriptionNonNullableFields$1[];
}
interface VariantSummaryNonNullableFields$1 {
    variantCount: number;
}
interface MinVariantPriceInfoNonNullableFields$1 {
    basePrice?: FixedMonetaryAmountNonNullableFields$1;
    salePrice?: FixedMonetaryAmountNonNullableFields$1;
    minSubscriptionPrice?: FixedMonetaryAmountNonNullableFields$1;
    pricePerUnitData?: PricePerUnitNonNullableFields$1;
    revenueDetails?: RevenueDetailsNonNullableFields$1;
}
interface V3ProductNonNullableFields$1 {
    physicalProperties?: PhysicalPropertiesNonNullableFields$1;
    numericId: string;
    url?: PageUrlV2NonNullableFields;
    description?: RichContentNonNullableFields$1;
    media?: MediaNonNullableFields$1;
    seoData?: SeoSchemaNonNullableFields$1;
    options: ConnectedOptionNonNullableFields$1[];
    modifiers: ConnectedModifierNonNullableFields$1[];
    infoSections: InfoSectionNonNullableFields$1[];
    directCategoriesInfo?: ProductCategoriesInfoNonNullableFields$1;
    allCategoriesInfo?: ProductCategoriesInfoNonNullableFields$1;
    directCategoryIdsInfo?: ProductCategoryIdsInfoNonNullableFields$1;
    basePriceRange?: PriceRangeNonNullableFields$1;
    salePriceRange?: PriceRangeNonNullableFields$1;
    costRange?: PriceRangeNonNullableFields$1;
    inventory?: InventoryNonNullableFields$1;
    productType: ProductType$1;
    breadcrumbsInfo?: BreadcrumbsInfoNonNullableFields$1;
    variantsInfo?: VariantsInfoNonNullableFields$1;
    subscriptionDetails?: SubscriptionDetailsNonNullableFields$1;
    flattenOptions: string[];
    flattenModifiers: string[];
    variantSummary?: VariantSummaryNonNullableFields$1;
    minVariantPriceInfo?: MinVariantPriceInfoNonNullableFields$1;
}
interface CreateProductResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
}
interface ApplicationErrorNonNullableFields$3 {
    code: string;
    description: string;
}
interface CommonItemMetadataNonNullableFields$1 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$3;
}
interface ProductNonNullableFields$1 {
    directCategoryIds: string[];
}
interface InventoryItemNonNullableFields$1 {
    inStock: boolean;
    quantity: number;
    variantId: string;
    productId: string;
    trackQuantity: boolean;
    availabilityStatus: AvailabilityStatus$1;
    product?: ProductNonNullableFields$1;
}
interface BulkInventoryItemResultNonNullableFields$1 {
    itemMetadata?: CommonItemMetadataNonNullableFields$1;
    item?: InventoryItemNonNullableFields$1;
}
interface CommonBulkActionMetadataNonNullableFields$1 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkInventoryItemResultsNonNullableFields$1 {
    results: BulkInventoryItemResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
    error?: ApplicationErrorNonNullableFields$3;
}
interface CreateProductWithInventoryResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields$1;
}
interface UpdateProductResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
}
interface UpdateProductWithInventoryResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields$1;
}
interface WixCommonItemMetadataNonNullableFields$1 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$3;
}
interface CatalogV3BulkProductResultNonNullableFields$1 {
    itemMetadata?: WixCommonItemMetadataNonNullableFields$1;
    item?: V3ProductNonNullableFields$1;
}
interface BulkCreateProductsResponseNonNullableFields$1 {
    results: CatalogV3BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
}
interface BulkProductResultsNonNullableFields$1 {
    results: CatalogV3BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
}
interface BulkCreateProductsWithInventoryResponseNonNullableFields$1 {
    productResults?: BulkProductResultsNonNullableFields$1;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields$1;
}
interface BulkUpdateProductsResponseNonNullableFields$1 {
    results: CatalogV3BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
}
interface BulkUpdateProductsWithInventoryResponseNonNullableFields$1 {
    productResults?: BulkProductResultsNonNullableFields$1;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields$1;
}
interface V3BulkUpdateProductsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface V3UpdateExtendedFieldsResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
}
interface BulkDeleteProductsResponseBulkProductResultNonNullableFields$1 {
    itemMetadata?: WixCommonItemMetadataNonNullableFields$1;
}
interface V3BulkDeleteProductsResponseNonNullableFields$1 {
    results: BulkDeleteProductsResponseBulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
}
interface V3BulkDeleteProductsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface V3GetProductResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
}
interface V3GetProductBySlugResponseNonNullableFields$1 {
    product?: V3ProductNonNullableFields$1;
}
interface ValueResultsValueAggregationResultNonNullableFields$1 {
    value: string;
    count: number;
}
interface AggregationResultsValueResultsNonNullableFields$1 {
    results: ValueResultsValueAggregationResultNonNullableFields$1[];
}
interface RangeResultsRangeAggregationResultNonNullableFields$1 {
    count: number;
}
interface AggregationResultsRangeResultsNonNullableFields$1 {
    results: RangeResultsRangeAggregationResultNonNullableFields$1[];
}
interface AggregationDataAggregationResultsScalarResultNonNullableFields$1 {
    type: WixCommonScalarType$1;
    value: number;
}
interface AggregationResultsNestedAggregationResultsNonNullableFields$1 {
    values?: AggregationResultsValueResultsNonNullableFields$1;
    ranges?: AggregationResultsRangeResultsNonNullableFields$1;
    scalar?: AggregationDataAggregationResultsScalarResultNonNullableFields$1;
    name: string;
    type: WixCommonAggregationType$1;
    fieldPath: string;
}
interface GroupByValueResultsNestedValueAggregationResultNonNullableFields$1 {
    value: string;
    nestedResults?: AggregationResultsNestedAggregationResultsNonNullableFields$1;
}
interface AggregationResultsGroupByValueResultsNonNullableFields$1 {
    results: GroupByValueResultsNestedValueAggregationResultNonNullableFields$1[];
}
interface DateHistogramResultsDateHistogramResultNonNullableFields$1 {
    value: string;
    count: number;
}
interface AggregationResultsDateHistogramResultsNonNullableFields$1 {
    results: DateHistogramResultsDateHistogramResultNonNullableFields$1[];
}
interface AggregationDataAggregationResultsNonNullableFields$1 {
    values?: AggregationResultsValueResultsNonNullableFields$1;
    ranges?: AggregationResultsRangeResultsNonNullableFields$1;
    scalar?: AggregationDataAggregationResultsScalarResultNonNullableFields$1;
    groupedByValue?: AggregationResultsGroupByValueResultsNonNullableFields$1;
    dateHistogram?: AggregationResultsDateHistogramResultsNonNullableFields$1;
    name: string;
    type: WixCommonAggregationType$1;
    fieldPath: string;
}
interface CommonAggregationDataNonNullableFields$1 {
    results: AggregationDataAggregationResultsNonNullableFields$1[];
}
interface V3SearchProductsResponseNonNullableFields$1 {
    products: V3ProductNonNullableFields$1[];
    aggregationData?: CommonAggregationDataNonNullableFields$1;
}
interface V3QueryProductsResponseNonNullableFields$1 {
    products: V3ProductNonNullableFields$1[];
}
interface V3CountProductsResponseNonNullableFields$1 {
    count: number;
}
interface BulkUpdateProductVariantsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface BulkAdjustProductVariantsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface V3BulkAddInfoSectionsToProductsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface V3BulkAddInfoSectionsToProductsResponseNonNullableFields$1 {
    results: CatalogV3BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
}
interface V3BulkRemoveInfoSectionsFromProductsByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface V3BulkRemoveInfoSectionsFromProductsResponseNonNullableFields$1 {
    results: CatalogV3BulkProductResultNonNullableFields$1[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields$1;
}
interface BulkAddProductsToCategoriesByFilterResponseNonNullableFields$1 {
    jobId: string;
}
interface BulkRemoveProductsFromCategoriesByFilterResponseNonNullableFields$1 {
    jobId: string;
}

interface V3Product extends V3ProductTypedPropertiesOneOf {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties;
    /**
     * Product ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the product is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the product.
     *
     * Ignored when creating a product.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the product was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the product was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Product name. Translatable. */
    name?: string | null;
    /**
     * Product slug.
     *
     * If not provided, the slug is autogenerated based on the product name.
     */
    slug?: string | null;
    /**
     * URL to the site's product page.
     *
     * > **Note:** Returned only when you pass `"URL"` to the `fields` array in Products API requests.
     * @readonly
     */
    url?: string;
    /**
     * Product description using rich content.
     * > **Note:** Returned only when you pass `"DESCRIPTION"` to the `fields` array in Products API requests.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     */
    description?: RichContent;
    /**
     * Product description in HTML.
     *
     * + When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * + `plainDescription` is ignored when value is also passed to the `description` field.
     * > **Note:** Returned only when you pass `"PLAIN_DESCRIPTION"` to the `fields` array in Products API requests.
     */
    plainDescription?: string | null;
    /**
     * Whether the product is visible to site visitors on the site.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /**
     * Whether the product is visible in POS (point of sale).
     *
     * Default: `true`
     * > **Note:** Always `false` for `productType: DIGITAL`.
     */
    visibleInPos?: boolean | null;
    /** Product media items. */
    media?: Media;
    /** Product SEO data. */
    seoData?: SeoSchema;
    /** Tax group ID. */
    taxGroupId?: string | null;
    /**
     * Product options. Allows the customer to customize the product. For example, selecting color, size, and more.
     *
     * Always generates variants: every variant must have exactly one choice related to each option.
     * Since options and variants tightly coupled and rely on each other they usually should be provided together in all operations.
     */
    options?: ConnectedOption[];
    /**
     * Product modifiers.
     *
     * Allows the customer to customize product, e.g. select Color, Size and so on similarly to `options` but with one main difference - `modifiers` never generate any variants.
     */
    modifiers?: ConnectedModifier[];
    /**
     * Product brand.
     *
     * + Pass `brand.name` to add a new brand while creating a product.
     * + Pass an existing brand's `id` to assign that brand to the product.
     */
    brand?: Brand;
    /**
     * Product info section.
     *
     * + Pass `infoSection.uniqueName`, `infoSection.title`, and `infoSection.description` to add a new info section while creating a product.
     * + Pass an existing info section's `id` or `uniqueName` to assign that info section to the product.
     */
    infoSections?: InfoSection[];
    /**
     * Product ribbon.
     *
     * + Pass `ribbon.name` to add a new ribbon while creating a product.
     * + Pass an existing ribbon's `id` or `name` to assign that ribbon to the product.
     */
    ribbon?: Ribbon$2;
    /**
     * List of categories that directly contain this product.
     *
     * Updated automatically when a product is added/removed from a category, when an item is moved within a category, or when a category is deleted.
     * > **Note:** Returned only when you pass `"DIRECT_CATEGORIES_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    directCategoriesInfo?: ProductCategoriesInfo;
    /**
     * List of categories that directly contain this product, as well as their parent categories.
     * > **Note:** Returned only when you pass `"ALL_CATEGORIES_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    allCategoriesInfo?: ProductCategoriesInfo;
    /** Main category ID. */
    mainCategoryId?: string | null;
    /**
     * Product base price range - minimum and maximum prices of all product variants.
     * @readonly
     */
    basePriceRange?: PriceRange;
    /**
     * Product sale price range - minimum and maximum sale prices of all product variants.
     * @readonly
     */
    salePriceRange?: PriceRange;
    /**
     * Product cost range - minimum and maximum costs of all product variants.
     *
     * > **Note:** Returned only when the following conditions are met:
     * > + You pass `"MERCHANT_DATA"` to the `fields` array in Products API requests.
     * > + Your app has the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     * @readonly
     */
    costRange?: PriceRange;
    /**
     * Product inventory info.
     * @readonly
     */
    inventory?: Inventory;
    /**
     * Product type.
     *
     * When passing `productType: PHYSICAL`, you must also pass `physicalProperties`.
     */
    productType?: ProductType;
    /**
     * A unique human-friendly identifier for the product.
     * Unlike the product ID, the handle can be set by the user to ensure consistency across multiple platforms.
     * In case handle wasn't given, the handle will be automatically generated.
     */
    handle?: string | null;
    /**
     * Currency used for the pricing of this product, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     *
     * Defaults to the currency defined in the site settings, unless specified in `x-wix-currency` header.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    currency?: string | null;
    /**
     * Breadcrumbs of the `mainCategoryId`. Used to navigate to parent categories.
     * > **Note:** Returned only when you pass `"BREADCRUMBS_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    breadcrumbsInfo?: BreadcrumbsInfo;
    /** Product variants. */
    variantsInfo?: VariantsInfo;
    /**
     * Custom extended fields for the product object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
    /** Product subscriptions. */
    subscriptionDetails?: SubscriptionDetails;
    /**
     * The total number of variants for the product.
     * @readonly
     */
    variantSummary?: VariantSummary;
}
/** @oneof */
interface V3ProductTypedPropertiesOneOf {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties;
}
interface RichContent {
    /** Node objects representing a rich content document. */
    nodes?: Node[];
    /** Object metadata. */
    metadata?: Metadata;
    /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
    documentStyle?: DocumentStyle;
}
interface Node extends NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** Data for a map node. */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
    /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
    type?: NodeType;
    /** Node ID. */
    _id?: string;
    /** A list of child nodes. */
    nodes?: Node[];
    /** Padding and background color styling for the node. */
    style?: NodeStyle;
}
/** @oneof */
interface NodeDataOneOf {
    /** Data for a button node. */
    buttonData?: ButtonData;
    /** Data for a code block node. */
    codeBlockData?: CodeBlockData;
    /** Data for a divider node. */
    dividerData?: DividerData;
    /** Data for a file node. */
    fileData?: FileData;
    /** Data for a gallery node. */
    galleryData?: GalleryData;
    /** Data for a GIF node. */
    gifData?: GIFData;
    /** Data for a heading node. */
    headingData?: HeadingData;
    /** Data for an embedded HTML node. */
    htmlData?: HTMLData;
    /** Data for an image node. */
    imageData?: ImageData;
    /** Data for a link preview node. */
    linkPreviewData?: LinkPreviewData;
    /** Data for a map node. */
    mapData?: MapData;
    /** Data for a paragraph node. */
    paragraphData?: ParagraphData;
    /** Data for a poll node. */
    pollData?: PollData;
    /** Data for a text node. Used to apply decorations to text. */
    textData?: TextData;
    /** Data for an app embed node. */
    appEmbedData?: AppEmbedData;
    /** Data for a video node. */
    videoData?: VideoData;
    /** Data for an oEmbed node. */
    embedData?: EmbedData;
    /** Data for a collapsible list node. */
    collapsibleListData?: CollapsibleListData;
    /** Data for a table node. */
    tableData?: TableData;
    /** Data for a table cell node. */
    tableCellData?: TableCellData;
    /** Data for a custom external node. */
    externalData?: Record<string, any> | null;
    /** Data for an audio node. */
    audioData?: AudioData;
    /** Data for an ordered list node. */
    orderedListData?: OrderedListData;
    /** Data for a bulleted list node. */
    bulletedListData?: BulletedListData;
    /** Data for a block quote node. */
    blockquoteData?: BlockquoteData;
    /** Data for a caption node. */
    captionData?: CaptionData;
}
declare enum NodeType {
    PARAGRAPH = "PARAGRAPH",
    TEXT = "TEXT",
    HEADING = "HEADING",
    BULLETED_LIST = "BULLETED_LIST",
    ORDERED_LIST = "ORDERED_LIST",
    LIST_ITEM = "LIST_ITEM",
    BLOCKQUOTE = "BLOCKQUOTE",
    CODE_BLOCK = "CODE_BLOCK",
    VIDEO = "VIDEO",
    DIVIDER = "DIVIDER",
    FILE = "FILE",
    GALLERY = "GALLERY",
    GIF = "GIF",
    HTML = "HTML",
    IMAGE = "IMAGE",
    LINK_PREVIEW = "LINK_PREVIEW",
    MAP = "MAP",
    POLL = "POLL",
    APP_EMBED = "APP_EMBED",
    BUTTON = "BUTTON",
    COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
    TABLE = "TABLE",
    EMBED = "EMBED",
    COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
    COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
    COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
    TABLE_CELL = "TABLE_CELL",
    TABLE_ROW = "TABLE_ROW",
    EXTERNAL = "EXTERNAL",
    AUDIO = "AUDIO",
    CAPTION = "CAPTION"
}
interface NodeStyle {
    /** The top padding value in pixels. */
    paddingTop?: string | null;
    /** The bottom padding value in pixels. */
    paddingBottom?: string | null;
    /** The background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface ButtonData {
    /** Styling for the button's container. */
    containerData?: PluginContainerData;
    /** The button type. */
    type?: Type;
    /** Styling for the button. */
    styles?: Styles;
    /** The text to display on the button. */
    text?: string | null;
    /** Button link details. */
    link?: Link;
}
interface Border {
    /** Border width in pixels. */
    width?: number | null;
    /** Border radius in pixels. */
    radius?: number | null;
}
interface Colors {
    /** The text color as a hexadecimal value. */
    text?: string | null;
    /** The border color as a hexadecimal value. */
    border?: string | null;
    /** The background color as a hexadecimal value. */
    background?: string | null;
}
interface PluginContainerData {
    /** The width of the node when it's displayed. */
    width?: PluginContainerDataWidth;
    /** The node's alignment within its container. */
    alignment?: PluginContainerDataAlignment;
    /** Spoiler cover settings for the node. */
    spoiler?: Spoiler;
    /** The height of the node when it's displayed. */
    height?: Height;
    /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
    textWrap?: boolean | null;
}
declare enum WidthType {
    /** Width matches the content width */
    CONTENT = "CONTENT",
    /** Small Width */
    SMALL = "SMALL",
    /** Width will match the original asset width */
    ORIGINAL = "ORIGINAL",
    /** coast-to-coast display */
    FULL_WIDTH = "FULL_WIDTH"
}
interface PluginContainerDataWidth extends PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType;
    /** A custom width value in pixels. */
    custom?: string | null;
}
/** @oneof */
interface PluginContainerDataWidthDataOneOf {
    /**
     * One of the following predefined width options:
     * `CONTENT`: The width of the container matches the content width.
     * `SMALL`: A small width.
     * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
     * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
     */
    size?: WidthType;
    /** A custom width value in pixels. */
    custom?: string | null;
}
declare enum PluginContainerDataAlignment {
    /** Center Alignment */
    CENTER = "CENTER",
    /** Left Alignment */
    LEFT = "LEFT",
    /** Right Alignment */
    RIGHT = "RIGHT"
}
interface Spoiler {
    /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
    enabled?: boolean | null;
    /** The description displayed on top of the spoiler cover. */
    description?: string | null;
    /** The text for the button used to remove the spoiler cover. */
    buttonText?: string | null;
}
interface Height {
    /** A custom height value in pixels. */
    custom?: string | null;
}
declare enum Type {
    /** Regular link button */
    LINK = "LINK",
    /** Triggers custom action that is defined in plugin configuration by the consumer */
    ACTION = "ACTION"
}
interface Styles {
    /** Border attributes. */
    border?: Border;
    /** Color attributes. */
    colors?: Colors;
}
interface Link extends LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
    /**
     * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
     * `SELF` - Default. Opens the linked document in the same frame as the link.
     * `BLANK` - Opens the linked document in a new browser tab or window.
     * `PARENT` - Opens the linked document in the link's parent frame.
     * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
     */
    target?: Target;
    /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
    rel?: Rel;
    /** A serialized object used for a custom or external link panel. */
    customData?: string | null;
}
/** @oneof */
interface LinkDataOneOf {
    /** The absolute URL for the linked document. */
    url?: string;
    /** The target node's ID. Used for linking to another node in this object. */
    anchor?: string;
}
declare enum Target {
    /** Opens the linked document in the same frame as it was clicked (this is default) */
    SELF = "SELF",
    /** Opens the linked document in a new window or tab */
    BLANK = "BLANK",
    /** Opens the linked document in the parent frame */
    PARENT = "PARENT",
    /** Opens the linked document in the full body of the window */
    TOP = "TOP"
}
interface Rel {
    /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
    nofollow?: boolean | null;
    /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
    sponsored?: boolean | null;
    /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
    ugc?: boolean | null;
    /** Indicates that this link protect referral information from being passed to the target website. */
    noreferrer?: boolean | null;
}
interface CodeBlockData {
    /** Styling for the code block's text. */
    textStyle?: TextStyle;
}
interface TextStyle {
    /** Text alignment. Defaults to `AUTO`. */
    textAlignment?: TextAlignment;
    /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
    lineHeight?: string | null;
}
declare enum TextAlignment {
    /** browser default, eqivalent to `initial` */
    AUTO = "AUTO",
    /** Left align */
    LEFT = "LEFT",
    /** Right align */
    RIGHT = "RIGHT",
    /** Center align */
    CENTER = "CENTER",
    /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
    JUSTIFY = "JUSTIFY"
}
interface DividerData {
    /** Styling for the divider's container. */
    containerData?: PluginContainerData;
    /** Divider line style. */
    lineStyle?: LineStyle;
    /** Divider width. */
    width?: Width;
    /** Divider alignment. */
    alignment?: Alignment;
}
declare enum LineStyle {
    /** Single Line */
    SINGLE = "SINGLE",
    /** Double Line */
    DOUBLE = "DOUBLE",
    /** Dashed Line */
    DASHED = "DASHED",
    /** Dotted Line */
    DOTTED = "DOTTED"
}
declare enum Width {
    /** Large line */
    LARGE = "LARGE",
    /** Medium line */
    MEDIUM = "MEDIUM",
    /** Small line */
    SMALL = "SMALL"
}
declare enum Alignment {
    /** Center alignment */
    CENTER = "CENTER",
    /** Left alignment */
    LEFT = "LEFT",
    /** Right alignment */
    RIGHT = "RIGHT"
}
interface FileData {
    /** Styling for the file's container. */
    containerData?: PluginContainerData;
    /** The source for the file's data. */
    src?: FileSource;
    /** File name. */
    name?: string | null;
    /** File type. */
    type?: string | null;
    /**
     * Use `sizeInKb` instead.
     * @deprecated
     */
    size?: number | null;
    /** Settings for PDF files. */
    pdfSettings?: PDFSettings;
    /** File MIME type. */
    mimeType?: string | null;
    /** File path. */
    path?: string | null;
    /** File size in KB. */
    sizeInKb?: string | null;
}
declare enum ViewMode {
    /** No PDF view */
    NONE = "NONE",
    /** Full PDF view */
    FULL = "FULL",
    /** Mini PDF view */
    MINI = "MINI"
}
interface FileSource extends FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    _id?: string | null;
    /** Indicates whether the file's source is private. Defaults to `false`. */
    private?: boolean | null;
}
/** @oneof */
interface FileSourceDataOneOf {
    /** The absolute URL for the file's source. */
    url?: string | null;
    /**
     * Custom ID. Use `id` instead.
     * @deprecated
     */
    custom?: string | null;
    /** An ID that's resolved to a URL by a resolver function. */
    _id?: string | null;
}
interface PDFSettings {
    /**
     * PDF view mode. One of the following:
     * `NONE` : The PDF isn't displayed.
     * `FULL` : A full page view of the PDF is displayed.
     * `MINI` : A mini view of the PDF is displayed.
     */
    viewMode?: ViewMode;
    /** Sets whether the PDF download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Sets whether the PDF print button is disabled. Defaults to `false`. */
    disablePrint?: boolean | null;
}
interface GalleryData {
    /** Styling for the gallery's container. */
    containerData?: PluginContainerData;
    /** The items in the gallery. */
    items?: Item[];
    /** Options for defining the gallery's appearance. */
    options?: GalleryOptions;
    /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface V1Media {
    /** The source for the media's data. */
    src?: FileSource;
    /** Media width in pixels. */
    width?: number | null;
    /** Media height in pixels. */
    height?: number | null;
    /** Media duration in seconds. Only relevant for audio and video files. */
    duration?: number | null;
}
interface Image {
    /** Image file details. */
    media?: V1Media;
    /** Link details for images that are links. */
    link?: Link;
}
interface Video {
    /** Video file details. */
    media?: V1Media;
    /** Video thumbnail file details. */
    thumbnail?: V1Media;
}
interface Item extends ItemDataOneOf {
    /** An image item. */
    image?: Image;
    /** A video item. */
    video?: Video;
    /** Item title. */
    title?: string | null;
    /** Item's alternative text. */
    altText?: string | null;
}
/** @oneof */
interface ItemDataOneOf {
    /** An image item. */
    image?: Image;
    /** A video item. */
    video?: Video;
}
interface GalleryOptions {
    /** Gallery layout. */
    layout?: Layout;
    /** Styling for gallery items. */
    item?: ItemStyle;
    /** Styling for gallery thumbnail images. */
    thumbnails?: Thumbnails;
}
declare enum LayoutType {
    /** Collage type */
    COLLAGE = "COLLAGE",
    /** Masonry type */
    MASONRY = "MASONRY",
    /** Grid type */
    GRID = "GRID",
    /** Thumbnail type */
    THUMBNAIL = "THUMBNAIL",
    /** Slider type */
    SLIDER = "SLIDER",
    /** Slideshow type */
    SLIDESHOW = "SLIDESHOW",
    /** Panorama type */
    PANORAMA = "PANORAMA",
    /** Column type */
    COLUMN = "COLUMN",
    /** Magic type */
    MAGIC = "MAGIC",
    /** Fullsize images type */
    FULLSIZE = "FULLSIZE"
}
declare enum Orientation {
    /** Rows Orientation */
    ROWS = "ROWS",
    /** Columns Orientation */
    COLUMNS = "COLUMNS"
}
declare enum Crop {
    /** Crop to fill */
    FILL = "FILL",
    /** Crop to fit */
    FIT = "FIT"
}
declare enum ThumbnailsAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Right alignment */
    RIGHT = "RIGHT",
    /** Bottom alignment */
    BOTTOM = "BOTTOM",
    /** Left alignment */
    LEFT = "LEFT",
    /** No thumbnail */
    NONE = "NONE"
}
interface Layout {
    /** Gallery layout type. */
    type?: LayoutType;
    /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
    horizontalScroll?: boolean | null;
    /** Gallery orientation. */
    orientation?: Orientation;
    /** The number of columns to display on full size screens. */
    numberOfColumns?: number | null;
    /** The number of columns to display on mobile screens. */
    mobileNumberOfColumns?: number | null;
}
interface ItemStyle {
    /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
    targetSize?: number | null;
    /** Item ratio */
    ratio?: number | null;
    /** Sets how item images are cropped. */
    crop?: Crop;
    /** The spacing between items in pixels. */
    spacing?: number | null;
}
interface Thumbnails {
    /** Thumbnail alignment. */
    placement?: ThumbnailsAlignment;
    /** Spacing between thumbnails in pixels. */
    spacing?: number | null;
}
interface GIFData {
    /** Styling for the GIF's container. */
    containerData?: PluginContainerData;
    /** The source of the full size GIF. */
    original?: GIF;
    /** The source of the downsized GIF. */
    downsized?: GIF;
    /** Height in pixels. */
    height?: number;
    /** Width in pixels. */
    width?: number;
}
interface GIF {
    /** GIF format URL. */
    gif?: string | null;
    /** MP4 format URL. */
    mp4?: string | null;
    /** Thumbnail URL. */
    still?: string | null;
}
interface HeadingData {
    /** Heading level from 1-6. */
    level?: number;
    /** Styling for the heading text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
}
interface HTMLData extends HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
    /** Styling for the HTML node's container. */
    containerData?: PluginContainerData;
    /** The type of HTML code. */
    source?: Source;
}
/** @oneof */
interface HTMLDataDataOneOf {
    /** The URL for the HTML code for the node. */
    url?: string;
    /** The HTML code for the node. */
    html?: string;
    /**
     * Whether this is an AdSense element. Use `source` instead.
     * @deprecated
     */
    isAdsense?: boolean | null;
}
declare enum Source {
    HTML = "HTML",
    ADSENSE = "ADSENSE"
}
interface ImageData {
    /** Styling for the image's container. */
    containerData?: PluginContainerData;
    /** Image file details. */
    image?: V1Media;
    /** Link details for images that are links. */
    link?: Link;
    /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
    disableExpand?: boolean | null;
    /** Image's alternative text. */
    altText?: string | null;
    /**
     * Deprecated: use Caption node instead.
     * @deprecated
     */
    caption?: string | null;
    /** Sets whether the image's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
}
interface LinkPreviewData {
    /** Styling for the link preview's container. */
    containerData?: PluginContainerData;
    /** Link details. */
    link?: Link;
    /** Preview title. */
    title?: string | null;
    /** Preview thumbnail URL. */
    thumbnailUrl?: string | null;
    /** Preview description. */
    description?: string | null;
    /** The preview content as HTML. */
    html?: string | null;
}
interface MapData {
    /** Styling for the map's container. */
    containerData?: PluginContainerData;
    /** Map settings. */
    mapSettings?: MapSettings;
}
interface MapSettings {
    /** The address to display on the map. */
    address?: string | null;
    /** Sets whether the map is draggable. */
    draggable?: boolean | null;
    /** Sets whether the location marker is visible. */
    marker?: boolean | null;
    /** Sets whether street view control is enabled. */
    streetViewControl?: boolean | null;
    /** Sets whether zoom control is enabled. */
    zoomControl?: boolean | null;
    /** Location latitude. */
    lat?: number | null;
    /** Location longitude. */
    lng?: number | null;
    /** Location name. */
    locationName?: string | null;
    /** Sets whether view mode control is enabled. */
    viewModeControl?: boolean | null;
    /** Initial zoom value. */
    initialZoom?: number | null;
    /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
    mapType?: MapType;
}
declare enum MapType {
    /** Roadmap map type */
    ROADMAP = "ROADMAP",
    /** Satellite map type */
    SATELITE = "SATELITE",
    /** Hybrid map type */
    HYBRID = "HYBRID",
    /** Terrain map type */
    TERRAIN = "TERRAIN"
}
interface ParagraphData {
    /** Styling for the paragraph text. */
    textStyle?: TextStyle;
    /** Indentation level from 1-4. */
    indentation?: number | null;
    /** Paragraph level */
    level?: number | null;
}
interface PollData {
    /** Styling for the poll's container. */
    containerData?: PluginContainerData;
    /** Poll data. */
    poll?: Poll;
    /** Layout settings for the poll and voting options. */
    layout?: PollDataLayout;
    /** Styling for the poll and voting options. */
    design?: Design;
}
declare enum ViewRole {
    /** Only Poll creator can view the results */
    CREATOR = "CREATOR",
    /** Anyone who voted can see the results */
    VOTERS = "VOTERS",
    /** Anyone can see the results, even if one didn't vote */
    EVERYONE = "EVERYONE"
}
declare enum VoteRole {
    /** Logged in member */
    SITE_MEMBERS = "SITE_MEMBERS",
    /** Anyone */
    ALL = "ALL"
}
interface Permissions {
    /** Sets who can view the poll results. */
    view?: ViewRole;
    /** Sets who can vote. */
    vote?: VoteRole;
    /** Sets whether one voter can vote multiple times. Defaults to `false`. */
    allowMultipleVotes?: boolean | null;
}
interface Option {
    /** Option ID. */
    _id?: string | null;
    /** Option title. */
    title?: string | null;
    /** The image displayed with the option. */
    image?: V1Media;
}
interface PollSettings {
    /** Permissions settings for voting. */
    permissions?: Permissions;
    /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
    showVoters?: boolean | null;
    /** Sets whether the vote count is displayed. Defaults to `true`. */
    showVotesCount?: boolean | null;
}
declare enum PollLayoutType {
    /** List */
    LIST = "LIST",
    /** Grid */
    GRID = "GRID"
}
declare enum PollLayoutDirection {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface PollLayout {
    /** The layout for displaying the voting options. */
    type?: PollLayoutType;
    /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
    direction?: PollLayoutDirection;
    /** Sets whether to display the main poll image. Defaults to `false`. */
    enableImage?: boolean | null;
}
interface OptionLayout {
    /** Sets whether to display option images. Defaults to `false`. */
    enableImage?: boolean | null;
}
declare enum BackgroundType {
    /** Color background type */
    COLOR = "COLOR",
    /** Image background type */
    IMAGE = "IMAGE",
    /** Gradiant background type */
    GRADIENT = "GRADIENT"
}
interface Gradient {
    /** The gradient angle in degrees. */
    angle?: number | null;
    /** The start color as a hexademical value. */
    startColor?: string | null;
    /** The end color as a hexademical value. */
    lastColor?: string | null;
}
interface Background extends BackgroundBackgroundOneOf {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: V1Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
    /** Background type. For each option, include the relevant details. */
    type?: BackgroundType;
}
/** @oneof */
interface BackgroundBackgroundOneOf {
    /** The background color as a hexademical value. */
    color?: string | null;
    /** An image to use for the background. */
    image?: V1Media;
    /** Details for a gradient background. */
    gradient?: Gradient;
}
interface PollDesign {
    /** Background styling. */
    background?: Background;
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface OptionDesign {
    /** Border radius in pixels. */
    borderRadius?: number | null;
}
interface Poll {
    /** Poll ID. */
    _id?: string | null;
    /** Poll title. */
    title?: string | null;
    /** Poll creator ID. */
    creatorId?: string | null;
    /** Main poll image. */
    image?: V1Media;
    /** Voting options. */
    options?: Option[];
    /** The poll's permissions and display settings. */
    settings?: PollSettings;
}
interface PollDataLayout {
    /** Poll layout settings. */
    poll?: PollLayout;
    /** Voting otpions layout settings. */
    options?: OptionLayout;
}
interface Design {
    /** Styling for the poll. */
    poll?: PollDesign;
    /** Styling for voting options. */
    options?: OptionDesign;
}
interface TextData {
    /** The text to apply decorations to. */
    text?: string;
    /** The decorations to apply. */
    decorations?: Decoration[];
}
/** Adds appearence changes to text */
interface Decoration extends DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
    /** The type of decoration to apply. */
    type?: DecorationType;
}
/** @oneof */
interface DecorationDataOneOf {
    /** Data for an anchor link decoration. */
    anchorData?: AnchorData;
    /** Data for a color decoration. */
    colorData?: ColorData;
    /** Data for an external link decoration. */
    linkData?: LinkData;
    /** Data for a mention decoration. */
    mentionData?: MentionData;
    /** Data for a font size decoration. */
    fontSizeData?: FontSizeData;
    /** Font weight for a bold decoration. */
    fontWeightValue?: number | null;
    /** Data for an italic decoration. Defaults to `true`. */
    italicData?: boolean | null;
    /** Data for an underline decoration. Defaults to `true`. */
    underlineData?: boolean | null;
    /** Data for a spoiler decoration. */
    spoilerData?: SpoilerData;
}
declare enum DecorationType {
    BOLD = "BOLD",
    ITALIC = "ITALIC",
    UNDERLINE = "UNDERLINE",
    SPOILER = "SPOILER",
    ANCHOR = "ANCHOR",
    MENTION = "MENTION",
    LINK = "LINK",
    COLOR = "COLOR",
    FONT_SIZE = "FONT_SIZE",
    EXTERNAL = "EXTERNAL"
}
interface AnchorData {
    /** The target node's ID. */
    anchor?: string;
}
interface ColorData {
    /** The text's background color as a hexadecimal value. */
    background?: string | null;
    /** The text's foreground color as a hexadecimal value. */
    foreground?: string | null;
}
interface LinkData {
    /** Link details. */
    link?: Link;
}
interface MentionData {
    /** The mentioned user's name. */
    name?: string;
    /** The version of the user's name that appears after the `@` character in the mention. */
    slug?: string;
    /** Mentioned user's ID. */
    _id?: string | null;
}
interface FontSizeData {
    /** The units used for the font size. */
    unit?: FontType;
    /** Font size value. */
    value?: number | null;
}
declare enum FontType {
    PX = "PX",
    EM = "EM"
}
interface SpoilerData {
    /** Spoiler ID. */
    _id?: string | null;
}
interface AppEmbedData extends AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
    /** The type of Wix App content being embedded. */
    type?: AppType;
    /** The ID of the embedded content. */
    itemId?: string | null;
    /** The name of the embedded content. */
    name?: string | null;
    /**
     * Deprecated: Use `image` instead.
     * @deprecated
     */
    imageSrc?: string | null;
    /** The URL for the embedded content. */
    url?: string | null;
    /** An image for the embedded content. */
    image?: V1Media;
}
/** @oneof */
interface AppEmbedDataAppDataOneOf {
    /** Data for embedded Wix Bookings content. */
    bookingData?: BookingData;
    /** Data for embedded Wix Events content. */
    eventData?: EventData;
}
declare enum AppType {
    PRODUCT = "PRODUCT",
    EVENT = "EVENT",
    BOOKING = "BOOKING"
}
interface BookingData {
    /** Booking duration in minutes. */
    durations?: string | null;
}
interface EventData {
    /** Event schedule. */
    scheduling?: string | null;
    /** Event location. */
    location?: string | null;
}
interface VideoData {
    /** Styling for the video's container. */
    containerData?: PluginContainerData;
    /** Video details. */
    video?: V1Media;
    /** Video thumbnail details. */
    thumbnail?: V1Media;
    /** Sets whether the video's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Video title. */
    title?: string | null;
    /** Video options. */
    options?: PlaybackOptions;
}
interface PlaybackOptions {
    /** Sets whether the media will automatically start playing. */
    autoPlay?: boolean | null;
    /** Sets whether media's will be looped. */
    playInLoop?: boolean | null;
    /** Sets whether media's controls will be shown. */
    showControls?: boolean | null;
}
interface EmbedData {
    /** Styling for the oEmbed node's container. */
    containerData?: PluginContainerData;
    /** An [oEmbed](https://www.oembed.com) object. */
    oembed?: Oembed;
    /** Origin asset source. */
    src?: string | null;
}
interface Oembed {
    /** The resource type. */
    type?: string | null;
    /** The width of the resource specified in the `url` property in pixels. */
    width?: number | null;
    /** The height of the resource specified in the `url` property in pixels. */
    height?: number | null;
    /** Resource title. */
    title?: string | null;
    /** The source URL for the resource. */
    url?: string | null;
    /** HTML for embedding a video player. The HTML should have no padding or margins. */
    html?: string | null;
    /** The name of the author or owner of the resource. */
    authorName?: string | null;
    /** The URL for the author or owner of the resource. */
    authorUrl?: string | null;
    /** The name of the resource provider. */
    providerName?: string | null;
    /** The URL for the resource provider. */
    providerUrl?: string | null;
    /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
    thumbnailUrl?: string | null;
    /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
    thumbnailWidth?: string | null;
    /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
    thumbnailHeight?: string | null;
    /** The URL for an embedded viedo. */
    videoUrl?: string | null;
    /** The oEmbed version number.  This value must be `1.0`. */
    version?: string | null;
}
interface CollapsibleListData {
    /** Styling for the collapsible list's container. */
    containerData?: PluginContainerData;
    /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
    expandOnlyOne?: boolean | null;
    /** Sets which items are expanded when the page loads. */
    initialExpandedItems?: InitialExpandedItems;
    /** The direction of the text in the list. Either left-to-right or right-to-left. */
    direction?: Direction;
    /** If `true`, The collapsible item will appear in search results as an FAQ. */
    isQapageData?: boolean | null;
}
declare enum InitialExpandedItems {
    /** First item will be expended initally */
    FIRST = "FIRST",
    /** All items will expended initally */
    ALL = "ALL",
    /** All items collapsed initally */
    NONE = "NONE"
}
declare enum Direction {
    /** Left-to-right */
    LTR = "LTR",
    /** Right-to-left */
    RTL = "RTL"
}
interface TableData {
    /** Styling for the table's container. */
    containerData?: PluginContainerData;
    /** The table's dimensions. */
    dimensions?: Dimensions;
    /**
     * Deprecated: Use `rowHeader` and `columnHeader` instead.
     * @deprecated
     */
    header?: boolean | null;
    /** Sets whether the table's first row is a header. Defaults to `false`. */
    rowHeader?: boolean | null;
    /** Sets whether the table's first column is a header. Defaults to `false`. */
    columnHeader?: boolean | null;
}
interface Dimensions {
    /** An array representing relative width of each column in relation to the other columns. */
    colsWidthRatio?: number[];
    /** An array representing the height of each row in pixels. */
    rowsHeight?: number[];
    /** An array representing the minimum width of each column in pixels. */
    colsMinWidth?: number[];
}
interface TableCellData {
    /** Styling for the cell's background color and text alignment. */
    cellStyle?: CellStyle;
    /** The cell's border colors. */
    borderColors?: BorderColors;
}
declare enum VerticalAlignment {
    /** Top alignment */
    TOP = "TOP",
    /** Middle alignment */
    MIDDLE = "MIDDLE",
    /** Bottom alignment */
    BOTTOM = "BOTTOM"
}
interface CellStyle {
    /** Vertical alignment for the cell's text. */
    verticalAlignment?: VerticalAlignment;
    /** Cell background color as a hexadecimal value. */
    backgroundColor?: string | null;
}
interface BorderColors {
    /** Left border color as a hexadecimal value. */
    left?: string | null;
    /** Right border color as a hexadecimal value. */
    right?: string | null;
    /** Top border color as a hexadecimal value. */
    top?: string | null;
    /** Bottom border color as a hexadecimal value. */
    bottom?: string | null;
}
interface AudioData {
    /** Styling for the audio node's container. */
    containerData?: PluginContainerData;
    /** Audio file details. */
    audio?: V1Media;
    /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
    disableDownload?: boolean | null;
    /** Cover image. */
    coverImage?: V1Media;
    /** Track name. */
    name?: string | null;
    /** Author name. */
    authorName?: string | null;
    /** An HTML version of the audio node. */
    html?: string | null;
}
interface OrderedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
    /** List start number. */
    start?: number | null;
}
interface BulletedListData {
    /** Indentation level from 0-4. */
    indentation?: number;
    /** Offset level from 0-4. */
    offset?: number | null;
}
interface BlockquoteData {
    /** Indentation level from 1-4. */
    indentation?: number;
}
interface CaptionData {
    textStyle?: TextStyle;
}
interface Metadata {
    /** Schema version. */
    version?: number;
    /**
     * When the object was created.
     * @readonly
     * @deprecated
     */
    createdTimestamp?: Date | null;
    /**
     * When the object was most recently updated.
     * @deprecated
     */
    updatedTimestamp?: Date | null;
    /** Object ID. */
    _id?: string | null;
}
interface DocumentStyle {
    /** Styling for H1 nodes. */
    headerOne?: TextNodeStyle;
    /** Styling for H2 nodes. */
    headerTwo?: TextNodeStyle;
    /** Styling for H3 nodes. */
    headerThree?: TextNodeStyle;
    /** Styling for H4 nodes. */
    headerFour?: TextNodeStyle;
    /** Styling for H5 nodes. */
    headerFive?: TextNodeStyle;
    /** Styling for H6 nodes. */
    headerSix?: TextNodeStyle;
    /** Styling for paragraph nodes. */
    paragraph?: TextNodeStyle;
    /** Styling for block quote nodes. */
    blockquote?: TextNodeStyle;
    /** Styling for code block nodes. */
    codeBlock?: TextNodeStyle;
}
interface TextNodeStyle {
    /** The decorations to apply to the node. */
    decorations?: Decoration[];
    /** Padding and background color for the node. */
    nodeStyle?: NodeStyle;
    /** Line height for text in the node. */
    lineHeight?: string | null;
}
interface Media {
    /**
     * Main media (image, video, etc.) associated with this product.
     * @readonly
     */
    main?: ProductMedia;
    /**
     * All media items.
     * > **Note:** Returned only when you pass `"MEDIA_ITEMS_INFO"` to the `fields` array in Products API requests.
     */
    itemsInfo?: MediaItemsInfo;
}
interface ProductMedia extends ProductMediaSetByOneOf, ProductMediaMediaOneOf {
    /** ID of existing media from Wix Media Manager. */
    _id?: string;
    /** Media URL. */
    url?: string;
    /**
     * Product image.
     * @readonly
     */
    image?: string;
    /**
     * Product video.
     * @readonly
     */
    video?: string;
    /** Image alt text. */
    altText?: string | null;
    /**
     * Media display name.
     * Allows to override the default media name. Can be passed only when `setBy: url`.
     */
    displayName?: string | null;
    /**
     * Media type.
     * @readonly
     */
    mediaType?: MediaType;
    /**
     * Media thumbnail.
     * > **Note:** Returned only when you pass `"THUMBNAIL"` to the `fields` array in Products API requests.
     */
    thumbnail?: Thumbnail;
    /**
     * ID used to upload media to Wix Media Manager.
     * @readonly
     */
    uploadId?: string;
}
/** @oneof */
interface ProductMediaSetByOneOf {
    /** ID of existing media from Wix Media Manager. */
    _id?: string;
    /** Media URL. */
    url?: string;
}
/** @oneof */
interface ProductMediaMediaOneOf {
    /**
     * Product image.
     * @readonly
     */
    image?: string;
    /**
     * Product video.
     * @readonly
     */
    video?: string;
}
declare enum MediaType {
    UNKNOWN_MEDIA_TYPE = "UNKNOWN_MEDIA_TYPE",
    IMAGE = "IMAGE",
    VIDEO = "VIDEO"
}
interface Thumbnail {
    /** Thumbnail url. */
    url?: string;
    /** Thumbnail height. */
    height?: number;
    /** Thumbnail width. */
    width?: number;
    /** Thumbnail alt text. */
    altText?: string | null;
}
interface MediaItemsInfo {
    /** All media items (images, videos etc) associated with this product. */
    items?: ProductMedia[];
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /** The source that added the keyword terms to the SEO settings. */
    origin?: string | null;
}
interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
     * For example: `{'name': 'description', 'content': 'the description itself'}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /** User-selected keyword terms for a specific page. */
    keywords?: Keyword[];
}
interface ConnectedOption extends ConnectedOptionOptionSettingsOneOf {
    /** Choices settings. */
    choicesSettings?: ChoicesSettings;
    /** ID of a customization with `customizationType: PRODUCT_OPTION`. */
    _id?: string | null;
    /** Option name. */
    name?: string | null;
    /** Option render type. */
    optionRenderType?: ProductOptionRenderType;
}
/** @oneof */
interface ConnectedOptionOptionSettingsOneOf {
    /** Choices settings. */
    choicesSettings?: ChoicesSettings;
}
declare enum ProductOptionRenderType {
    UNKNOWN_OPTION_RENDER_TYPE = "UNKNOWN_OPTION_RENDER_TYPE",
    TEXT_CHOICES = "TEXT_CHOICES",
    SWATCH_CHOICES = "SWATCH_CHOICES"
}
interface ChoicesSettings {
    /** List of available choices for the option. */
    choices?: ConnectedOptionChoice[];
}
interface ConnectedOptionChoice extends ConnectedOptionChoiceValueOneOf {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
    /** The id of the choice. */
    choiceId?: string | null;
    /**
     * Product media overrides. When not empty only these images will be shown when such choices selected by customer. Otherwise all images of product.
     * When several choices from different options selected only media filter present in `media_overrides` of ALL choices will be shown.
     * For example if Color:red has images 1,2,3 and Material:Silk has images 2,3,5 then only images 2,3 will be shown when both of them selected.
     */
    linkedMedia?: ProductMedia[];
    /** The type of this choice. */
    choiceType?: ChoiceType;
    /** Choice name. */
    name?: string | null;
    /**
     * A flag that indicates if at least one variant with this choice is in stock in the default store's location.
     * For example, a product with 'Color' and 'Size' options with variants: [Blue, Small] which is out of stock and [Red Large] which is in stock. For choice 'Blue' ths flag will be 'false' and for 'Red' the flag will be true
     * @readonly
     */
    inStock?: boolean;
    /**
     * Whether at least one variant with this choice is visible.
     *
     * Default: `false`
     * @readonly
     */
    visible?: boolean;
}
/** @oneof */
interface ConnectedOptionChoiceValueOneOf {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
}
declare enum ChoiceType {
    UNKNOWN_CHOICE_TYPE = "UNKNOWN_CHOICE_TYPE",
    CHOICE_TEXT = "CHOICE_TEXT",
    ONE_COLOR = "ONE_COLOR",
    MULTIPLE_COLORS = "MULTIPLE_COLORS",
    IMAGE = "IMAGE"
}
interface ConnectedModifier extends ConnectedModifierModifierSettingsOneOf {
    /** Free text modifier settings. */
    freeTextSettings?: FreeTextSettings;
    /** Choice settings. */
    choicesSettings?: ModifierChoicesSettings;
    /** ID of a customization with `customizationType: MODIFIER`. */
    _id?: string | null;
    /** Modifier title. */
    name?: string | null;
    /** Modifier render type. */
    modifierRenderType?: ModifierRenderType;
    /** Whether customer input is required for this modifier. */
    mandatory?: boolean;
}
/** @oneof */
interface ConnectedModifierModifierSettingsOneOf {
    /** Free text modifier settings. */
    freeTextSettings?: FreeTextSettings;
    /** Choice settings. */
    choicesSettings?: ModifierChoicesSettings;
}
declare enum ModifierRenderType {
    UNKNOWN_MODIFIER_RENDER_TYPE = "UNKNOWN_MODIFIER_RENDER_TYPE",
    FREE_TEXT = "FREE_TEXT",
    TEXT_CHOICES = "TEXT_CHOICES",
    SWATCH_CHOICES = "SWATCH_CHOICES"
}
interface FreeTextSettings {
    /** Minimum number of characters. */
    minCharCount?: number;
    /** Maximum number of characters. */
    maxCharCount?: number;
    /** Default amount to be added to the product's price. */
    defaultAddedPrice?: string | null;
    /** Title of the text to be input by the customer. */
    title?: string;
}
interface ModifierChoicesSettings {
    /** List of modifier choices. */
    choices?: ConnectedModifierChoice[];
}
interface ConnectedModifierChoice extends ConnectedModifierChoiceValueOneOf {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
    /** Choice ID. */
    choiceId?: string | null;
    /** Product media. */
    linkedMedia?: ProductMedia[];
    /** Choice type. */
    choiceType?: ChoiceType;
    /**
     * Modifier key. Used for eCommerce integration.
     * @readonly
     */
    key?: string;
    /** Choice name. */
    name?: string | null;
    /** Added price. */
    addedPrice?: string | null;
}
/** @oneof */
interface ConnectedModifierChoiceValueOneOf {
    /** Color code in HEX format, [as described by MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color). */
    colorCode?: string;
}
interface Brand {
    /** Brand ID. */
    _id?: string | null;
    /** Brand name. */
    name?: string | null;
}
interface InfoSection {
    /** Info section ID. */
    _id?: string | null;
    /**
     * Info section unique name.
     * > **Note:** Returned only when you pass `"INFO_SECTION"` to the `fields` array in Products API requests.
     */
    uniqueName?: string | null;
    /**
     * Info section title.
     * > **Note:** Returned only when you pass `"INFO_SECTION"` to the `fields` array in Products API requests.
     * @readonly
     */
    title?: string | null;
    /**
     * Info section description using rich content.
     * > **Note:** Returned only when you pass `"INFO_SECTION_DESCRIPTION"` to the `fields` array in Products API requests.
     *
     * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="indent.emoji.divider.codeBlock.file.gallery.giphy.image.table.link.textHighlight.textColor" exampleid="7dc9240e-d548-417a-abcf-0291b68b4303">
     * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
     * </widget>
     * @readonly
     */
    description?: RichContent;
    /**
     * Info section description in HTML.
     *
     * When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * `plainDescription` is ignored when value is also passed to the `description` field.
     * > **Note:** Returned only when you pass `"INFO_SECTION_PLAIN_DESCRIPTION"` to the `fields` array in Products API requests.
     */
    plainDescription?: string | null;
}
interface Ribbon$2 {
    /** Ribbon ID. */
    _id?: string | null;
    /** Ribbon name. */
    name?: string | null;
}
interface ProductCategoriesInfo {
    /**
     * A list of categories related to product.
     * @readonly
     */
    categories?: ProductCategory[];
}
interface ProductCategory {
    /** Category ID. */
    _id?: string;
    /** Index location of the product within the category, which can be utilized for sorting products in a specific category. For detailed instructions on how to set this up, refer to the [Add and arrange products in category](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/products-v3/sample-use-cases-and-flows#add-and-arrange-products-in-category) sample flow. */
    index?: number | null;
}
interface PriceRange {
    /** Minimum value. */
    minValue?: FixedMonetaryAmount;
    /** Maximum value. */
    maxValue?: FixedMonetaryAmount;
}
interface FixedMonetaryAmount {
    /** Monetary amount. For example, `"3.99"`, or `"-4.99"` for a negative amount. */
    amount?: string;
    /**
     * Formatted monetary amount. For example, `"$3.99"`.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    formattedAmount?: string | null;
}
interface Inventory {
    /**
     * Current availability status.
     *
     * + `IN_STOCK`: All variants are in stock and available for purchase
     * + `OUT_OF_STOCK`: All variants are out of stock
     * + `PARTIALLY_OUT_OF_STOCK`: Some variants are out of stock and some are in stock and available for purchase
     * @readonly
     */
    availabilityStatus?: InventoryAvailabilityStatus;
    /**
     * Current preorder status/
     *
     * + `ENABLED`: All variants are enabled for preorder
     * + `DISABLED`: All variants are disabled for preorder
     * + `PARTIALLY_ENABLED`: Some variants are disabled and some are enabled for preorder
     * @readonly
     */
    preorderStatus?: PreorderStatus;
    /**
     * Supported values:
     * + `ALL_VARIANTS`: All the product variants are available for preorder.
     * + `NO_VARIANTS`: None of the product variants are available for preorder.
     * + `SOME_VARIANTS`: Some of the product variants are available for preorder.
     * @readonly
     */
    preorderAvailability?: ProductPreorderAvailability;
}
declare enum InventoryAvailabilityStatus {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    IN_STOCK = "IN_STOCK",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    PARTIALLY_OUT_OF_STOCK = "PARTIALLY_OUT_OF_STOCK"
}
declare enum PreorderStatus {
    UNKNOWN_PREORDER_STATUS = "UNKNOWN_PREORDER_STATUS",
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    PARTIALLY_ENABLED = "PARTIALLY_ENABLED"
}
declare enum ProductPreorderAvailability {
    UNKNOWN_PREORDER_AVAILABILITY_STATUS = "UNKNOWN_PREORDER_AVAILABILITY_STATUS",
    ALL_VARIANTS = "ALL_VARIANTS",
    NO_VARIANTS = "NO_VARIANTS",
    SOME_VARIANTS = "SOME_VARIANTS"
}
declare enum ProductType {
    UNKNOWN_PRODUCT_TYPE = "UNKNOWN_PRODUCT_TYPE",
    PHYSICAL = "PHYSICAL",
    DIGITAL = "DIGITAL"
}
interface PhysicalProperties {
    /** Price per unit settings. */
    pricePerUnit?: PricePerUnitSettings;
    /** Fulfiller ID. */
    fulfillerId?: string | null;
    /**
     * Product shipping weight range - minimum and maximum weights of all the variants.
     * @readonly
     */
    shippingWeightRange?: WeightRange;
    /**
     * Product price per unit range. The minimum and maximum price per unit of all the variants.
     * @readonly
     */
    pricePerUnitRange?: PricePerUnitRange;
    /**
     * Weight measurement unit.
     * > **Note:** Returned only when you pass `"WEIGHT_MEASUREMENT_UNIT_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    weightMeasurementUnitInfo?: WeightMeasurementUnitInfo;
}
interface PricePerUnitSettings {
    /**
     * Quantity.
     * For example, to define price per per 100 grams, set this field to `100`.
     */
    quantity?: number;
    /**
     * Measurement unit.
     * For example, to define price per 100 grams, set this field to "G".
     */
    measurementUnit?: MeasurementUnit;
}
declare enum MeasurementUnit {
    UNSPECIFIED = "UNSPECIFIED",
    ML = "ML",
    CL = "CL",
    L = "L",
    CBM = "CBM",
    MG = "MG",
    G = "G",
    KG = "KG",
    MM = "MM",
    CM = "CM",
    M = "M",
    SQM = "SQM",
    OZ = "OZ",
    LB = "LB",
    FLOZ = "FLOZ",
    PT = "PT",
    QT = "QT",
    GAL = "GAL",
    IN = "IN",
    FT = "FT",
    YD = "YD",
    SQFT = "SQFT"
}
interface WeightRange {
    /** Minimum weight across all variants associated with this product. */
    minValue?: number;
    /** Maximum weight across all variants associated with this product. */
    maxValue?: number;
}
interface PricePerUnitRange {
    /** Minimum price per unit across all variants. */
    minValue?: PricePerUnitRangePricePerUnit;
    /** Maximum price per unit across all variants. */
    maxValue?: PricePerUnitRangePricePerUnit;
}
interface PricePerUnitRangePricePerUnit {
    /**
     * Calculated value of price per unit. Takes into account pricePerUnit settings of product and variants and sale price of variants.
     * For example if discounted price is 2$, product's price per unit setting is 1 Kg, variant price per unit setting is 0.5 Kg then this value is 4$ (means variant weight is 0.5 Kg and it costs 2$ but we want to show price per 1 Kg so we show 4$).
     * @readonly
     */
    value?: string;
    /**
     * Price per unit info in the format of variant specific data / product setting, for example €4.00 / 1 Kg.
     * > **Note:** This field is returned by the API only when you pass `fields: "CURRENCY"` in a request.
     * @readonly
     */
    description?: string | null;
}
interface WeightMeasurementUnitInfo {
    /**
     * Weight measurement unit.
     * @readonly
     */
    weightMeasurementUnit?: WeightUnit;
}
declare enum WeightUnit {
    /** Weight unit can't be classified, due to an error */
    UNSPECIFIED_WEIGHT_UNIT = "UNSPECIFIED_WEIGHT_UNIT",
    /** Kilograms */
    KG = "KG",
    /** Pounds */
    LB = "LB"
}
interface BreadcrumbsInfo {
    /**
     * Breadcrumbs.
     * @readonly
     */
    breadcrumbs?: BreadCrumb[];
}
interface BreadCrumb {
    /** Category ID. */
    categoryId?: string;
    /** Category name. */
    categoryName?: string;
    /** Category slug. */
    categorySlug?: string;
}
interface VariantsInfo {
    /** List of related variants. */
    variants?: Variant[];
}
interface Variant extends VariantTypedPropertiesOneOf {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties;
    /** Variant ID. */
    _id?: string | null;
    /**
     * Whether the variant is visible to site visitors.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string | null;
    /** Variant barcode. */
    barcode?: string | null;
    /**
     * List of choices.
     * In case this list is empty, this is the default variant of an unmanaged product.
     */
    choices?: OptionChoice[];
    /** Variant price. */
    price?: PriceInfo;
    /**
     * Variant revenue details.
     *
     * > **Note:** Returned only when the following conditions are met:
     * > + You pass `"MERCHANT_DATA"` to the `fields` array in Products API requests.
     * > + Your app has the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     */
    revenueDetails?: RevenueDetails;
    /**
     * Variant media.
     * @readonly
     */
    media?: ProductMedia;
    /**
     * Subscription prices calculated by applying subscription discount to the variant `price.salePrice`.
     * > **Note:** Returned only when you pass `"SUBSCRIPTION_PRICES_INFO"` to the `fields` array in Products API requests.
     * @readonly
     */
    subscriptionPricesInfo?: SubscriptionPricesInfo;
    /**
     * Variant inventory status.
     * @readonly
     */
    inventoryStatus?: InventoryStatus;
}
/** @oneof */
interface VariantTypedPropertiesOneOf {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties;
}
interface OptionChoice {
    /** Option and choice IDs. */
    optionChoiceIds?: OptionChoiceIds;
    /**
     * Option and choice names.
     * > **Note:** Returned only when you pass `"VARIANT_OPTION_CHOICE_NAMES"` to the `fields` array in Products API requests.
     */
    optionChoiceNames?: OptionChoiceNames;
}
interface OptionChoiceIds {
    /** Option ID. */
    optionId?: string;
    /** Choice ID. */
    choiceId?: string;
}
interface OptionChoiceNames {
    /** Option name. */
    optionName?: string;
    /** Choice name. */
    choiceName?: string;
    /** Render type. */
    renderType?: ProductOptionRenderType;
}
interface PriceInfo {
    /** Variant price. Must be greater or equal to 0. */
    basePrice?: FixedMonetaryAmount;
    /** Variant sale price. If not provided, sale price will be equal to `basePrice`. When provided, value must be greater or equal to 0, and less than or equal to `basePrice`. */
    salePrice?: FixedMonetaryAmount;
}
interface RevenueDetails {
    /** Item cost. */
    cost?: FixedMonetaryAmount;
    /**
     * Profit. Calculated by reducing `cost` from `discountedPrice`.
     * @readonly
     */
    profit?: FixedMonetaryAmount;
    /**
     * Profit Margin. Calculated by dividing `profit` by `discountedPrice`.
     * The result is rounded to 4 decimal places.
     * @readonly
     */
    profitMargin?: number;
}
interface VariantPhysicalProperties {
    /** Variant shipping weight. */
    weight?: number | null;
    /**
     * Price per unit info, in order to show price per unit on the product page.
     * For example if one sells cheese and defines 100g here then we know that buying this variant buyer receives 100g of cheese.
     * But on product page price will be displayed for units defined on product level. See `pricePerUnit.value` to understand how it's calculated.
     */
    pricePerUnit?: PricePerUnit;
}
interface PricePerUnit {
    /**
     * Price per unit data for this variant.
     * `measurementUnit` value must correspond to the measurement unit set on the product.
     */
    settings?: PricePerUnitSettings;
    /**
     * Calculated value of price per unit. Takes into account `pricePerUnit` settings of parent product, of this variant, and discounted price of variant.
     * For example if discounted price is 2$, product's price per unit setting is 1 Kg, variant price per unit setting is 0.5 Kg then this value is 4$ (means variant weight is 0.5 Kg and it costs 2$ but we want to show price per 1 Kg so we show 4$).
     * @readonly
     */
    value?: string;
    /**
     * Price per unit description.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    description?: string | null;
}
interface VariantDigitalProperties {
    /** Digital file which will be downloaded by customer after successful purchase. */
    digitalFile?: SecuredMedia;
}
interface SecuredMedia {
    /** Media ID in media manager. */
    _id?: string;
    /**
     * Original file name.
     * @readonly
     */
    fileName?: string;
    /**
     * Original file size.
     * @readonly
     */
    fileSize?: string | null;
    /**
     * File type.
     * @readonly
     */
    fileType?: FileType;
}
declare enum FileType {
    UNSPECIFIED = "UNSPECIFIED",
    SECURE_PICTURE = "SECURE_PICTURE",
    SECURE_VIDEO = "SECURE_VIDEO",
    SECURE_DOCUMENT = "SECURE_DOCUMENT",
    SECURE_MUSIC = "SECURE_MUSIC",
    SECURE_ARCHIVE = "SECURE_ARCHIVE"
}
interface SubscriptionPricesInfo {
    /** Subscription prices. */
    subscriptionPrices?: SubscriptionPrice[];
}
interface SubscriptionPrice {
    /**
     * Subscription ID.
     * @readonly
     */
    subscriptionId?: string;
    /**
     * Subscription price calculated by applying subscription discount to the variant `price.salePrice`
     * @readonly
     */
    price?: FixedMonetaryAmount;
    /**
     * Price per unit info.
     * @readonly
     */
    pricePerUnit?: SubscriptionPricePerUnit;
}
interface SubscriptionPricePerUnit {
    /**
     * Calculated value of price per unit. Takes into account `pricePerUnit` settings of parent product, `pricePerUnit` settings of this variant, and the variant subscription price.
     * @readonly
     */
    value?: string;
    /**
     * Price per unit description.
     * > **Note:** Returned only when you pass `"CURRENCY"` to the `fields` array in Products API requests.
     * @readonly
     */
    description?: string | null;
}
interface InventoryStatus {
    /** Whether the variant is in stock. */
    inStock?: boolean;
    /** Whether preorder is enabled for this variant. */
    preorderEnabled?: boolean;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface SubscriptionDetails {
    /** Subscriptions. */
    subscriptions?: Subscription[];
    /**
     * Whether to allow one-time purchases in addition to subscription-based purchases.
     *
     * Default: `false`
     */
    allowOneTimePurchases?: boolean | null;
}
interface Subscription extends SubscriptionCyclesOneOf {
    /** Whether subscription is renewed automatically at the end of each period. Cannot be `false`, instead set `billingCycles`. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. */
    billingCycles?: number;
    /** Subscription ID. */
    _id?: string | null;
    /** Subscription title. */
    title?: string;
    /** Subscription description. */
    description?: string | null;
    /**
     * Whether the subscription is visible to site visitors.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /**
     * Frequency of recurring payment.
     * For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months.
     */
    frequency?: SubscriptionFrequency$2;
    /** Interval of recurring payment. Default: `1`. For example, if `frequency: MONTH`, `billingCycles: 3` and `interval: 2`; payment will be made every 2 months for a total of 6 months. */
    interval?: number | null;
    /**
     * Discount info (optional).
     * For example, a $20 discount would be `amount: 20`, `type: AMOUNT`.
     */
    discount?: SubscriptionDiscount;
}
/** @oneof */
interface SubscriptionCyclesOneOf {
    /** Whether subscription is renewed automatically at the end of each period. Cannot be `false`, instead set `billingCycles`. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. */
    billingCycles?: number;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency$2 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface SubscriptionDiscount extends SubscriptionDiscountDiscountOneOf {
    /** Amount to discount from the variant discounted_price. */
    amountOff?: string;
    /** Percentage to discount from variant discounted_price. */
    percentOff?: number;
    /** Discount type. */
    type?: DiscountType$2;
}
/** @oneof */
interface SubscriptionDiscountDiscountOneOf {
    /** Amount to discount from the variant discounted_price. */
    amountOff?: string;
    /** Percentage to discount from variant discounted_price. */
    percentOff?: number;
}
declare enum DiscountType$2 {
    UNKNOWN_DISCOUNT = "UNKNOWN_DISCOUNT",
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface VariantSummary {
    /**
     * The total number of variants for the product.
     * @readonly
     */
    variantCount?: number;
}
interface CreateProductRequest {
    /**
     * Product to create.
     *
     * At least 1 variant must be provided and each variant must have relevant item in `choices` field for every item in `options`.
     * If `options` is empty one default variant must be provided with empty `choices` list.
     */
    product: V3Product;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
declare enum SingleEntityOpsRequestedFields {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    URL = "URL",
    CURRENCY = "CURRENCY",
    INFO_SECTION = "INFO_SECTION",
    /** You can request merchant data only if you have `WIX_STORES.PRODUCT_MERCHANT_DATA_READ` permission. */
    MERCHANT_DATA = "MERCHANT_DATA",
    PLAIN_DESCRIPTION = "PLAIN_DESCRIPTION",
    INFO_SECTION_PLAIN_DESCRIPTION = "INFO_SECTION_PLAIN_DESCRIPTION",
    SUBSCRIPTION_PRICES_INFO = "SUBSCRIPTION_PRICES_INFO",
    VARIANTS_INFO = "VARIANTS_INFO",
    BREADCRUMBS_INFO = "BREADCRUMBS_INFO",
    WEIGHT_MEASUREMENT_UNIT_INFO = "WEIGHT_MEASUREMENT_UNIT_INFO",
    VARIANT_OPTION_CHOICE_NAMES = "VARIANT_OPTION_CHOICE_NAMES",
    MEDIA_ITEMS_INFO = "MEDIA_ITEMS_INFO",
    DESCRIPTION = "DESCRIPTION",
    DIRECT_CATEGORIES_INFO = "DIRECT_CATEGORIES_INFO",
    ALL_CATEGORIES_INFO = "ALL_CATEGORIES_INFO",
    MIN_VARIANT_PRICE_INFO = "MIN_VARIANT_PRICE_INFO",
    INFO_SECTION_DESCRIPTION = "INFO_SECTION_DESCRIPTION",
    THUMBNAIL = "THUMBNAIL",
    DIRECT_CATEGORY_IDS = "DIRECT_CATEGORY_IDS"
}
interface CreateProductResponse {
    /** Created product. */
    product?: V3Product;
}
interface CreateProductWithInventoryRequest {
    /**
     * Product to create with inventory.
     *
     * At least one variant must be provided and each variant must have relevant item in `choices` field for every item in `options`.
     * If `options` is empty one default variant must be provided with empty `choices` list.
     */
    product: ProductWithInventory;
    /**
     * Whether to return inventory entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
interface ProductWithInventory extends ProductWithInventoryTypedPropertiesOneOf {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties;
    /**
     * Product ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the product is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the product.
     *
     * Ignored when creating a product with inventory.
     * @readonly
     */
    revision?: string | null;
    /** Product name. */
    name?: string | null;
    /**
     * Product slug.
     *
     * If not provided, the slug is autogenerated based on the product name.
     */
    slug?: string | null;
    /**
     * Product description in HTML.
     *
     * + When provided on create/update, this string must be a valid HTML. It will then be converted to rich content.
     * + `plainDescription` is ignored when value is also passed to the `description` field.
     * > **Note:** Returned only when you pass `"PLAIN_DESCRIPTION"` to the `fields` array in Products API requests.
     */
    plainDescription?: string | null;
    /**
     * Whether the product is visible to site visitors on the site.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /**
     * Whether the product is visible in POS (point of sale).
     *
     * Default: `true`
     * > **Note:** Always `false` for `productType: DIGITAL`.
     */
    visibleInPos?: boolean | null;
    /** Product media items. */
    media?: Media;
    /** Product SEO data. */
    seoData?: SeoSchema;
    /** Tax group ID. */
    taxGroupId?: string | null;
    /**
     * Product options. Allows buyer to customize product, e.g. select Color, Size and so on.
     * Always generates variants: every variant must have exactly one choice related to each option.
     * Since options and variants tightly coupled and rely on each other they usually should be provided together in all operations.
     * For existing options and choices provide ids only, all other data (e.g. names, title, types and so on) will be resolved for you by ids.
     * If you don't have ids it's ok to omit them but provide all other data instead. For existing options ids will be resolved, not existing options will be created.
     * *None*: you cannot change name of existing option via this endpoint but you can do it by calling CustomizationService
     */
    options?: ConnectedOption[];
    /**
     * Product Modifiers. Allows buyer to customize product, e.g. select Color, Size and so on similarly to `options` but with one main difference - `modifiers` never generate any variants.
     * For existing modifiers and choices provide ids only, all other data (e.g. names, title, types and so on) will be resolved for you by ids.
     * If you don't have ids it's ok to omit them but provide all other data instead. For existing modifiers ids will be resolved, not existing modifiers will be created.
     * *None*: you cannot change name of existing modifier via this endpoint by passing id and changed name, if you pass id name will be ignored. If you want to update existing modifier name do it by calling CustomizationService
     */
    modifiers?: ConnectedModifier[];
    /**
     * Product brand.
     *
     * + Pass `brand.name` to add a new brand while creating a product.
     * + Pass an existing brand's `id` to assign that brand to the product.
     */
    brand?: Brand;
    /**
     * Product info section.
     *
     * + Pass `infoSection.uniqueName`, `infoSection.title`, and `infoSection.description` to add a new info section while creating a product.
     * + Pass an existing info section's `id` or `uniqueName` to assign that info section to the product.
     */
    infoSections?: InfoSection[];
    /**
     * Product ribbon.
     *
     * + Pass `ribbon.name` to add a new ribbon while creating a product.
     * + Pass an existing ribbon's `id` or `name` to assign that ribbon to the product.
     */
    ribbon?: Ribbon$2;
    /** Main category ID. */
    mainCategoryId?: string | null;
    /**
     * Product type.
     *
     * When passing `productType: PHYSICAL`, you must also pass `physicalProperties`.
     */
    productType?: ProductType;
    /**
     * A unique human-friendly identifier for the product.
     * Unlike the product ID, the handle can be set by the user to ensure consistency across multiple platforms.
     * In case handle wasn't given, the handle will be automatically generated.
     */
    handle?: string | null;
    /** Product variants. */
    variantsInfo?: V3VariantsInfo;
    /** Subscription details. */
    subscriptionDetails?: SubscriptionDetails;
    /**
     * Custom extended fields for the product object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the Wix Dev Center before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
/** @oneof */
interface ProductWithInventoryTypedPropertiesOneOf {
    /**
     * Physical properties.
     *
     * Required when `productType: PHYSICAL`.
     */
    physicalProperties?: PhysicalProperties;
}
interface V3VariantsInfo {
    /**
     * List of related variants.
     * Partial update of variants is not supported so on update you must pass all data for all of them.
     * If you want to update existing variant you must provide `id`, otherwise new variant with different id will be created which might break some integrations that rely on variant ids.
     */
    variants?: VariantWithInventory[];
}
interface VariantWithInventory extends VariantWithInventoryTypedPropertiesOneOf {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties;
    /** Variant ID. */
    _id?: string | null;
    /**
     * Whether the variant is visible to site visitors.
     *
     * Default: `true`
     */
    visible?: boolean | null;
    /** Variant SKU (stock keeping unit). */
    sku?: string | null;
    /** Variant barcode. */
    barcode?: string | null;
    /** Variant price. */
    price?: PriceInfo;
    /**
     * Variant revenue details.
     *
     * > **Note:** Returned only when the following conditions are met:
     * > + You pass `"MERCHANT_DATA"` to the `fields` array in Products API requests.
     * > + Your app has the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     */
    revenueDetails?: RevenueDetails;
    /** Inventory item of the variant on the default location. */
    inventoryItem?: InventoryItemComposite;
    /** List of choices. */
    choices?: OptionChoiceReferences[];
}
/** @oneof */
interface VariantWithInventoryTypedPropertiesOneOf {
    /** Physical properties. Must be passed when `productType: PHYSICAL` */
    physicalProperties?: VariantPhysicalProperties;
    /** Digital properties. Must be passed when `productType: DIGITAL` */
    digitalProperties?: VariantDigitalProperties;
}
interface InventoryItemComposite extends InventoryItemCompositeTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Inventory item revision.
     * @readonly
     */
    revision?: string | null;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo$2;
}
/** @oneof */
interface InventoryItemCompositeTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
interface PreorderInfo$2 {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /** A message the customer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
interface OptionChoiceReferences {
    /** Option and choice IDs. */
    optionChoiceIds?: V3OptionChoiceIds;
    /** Option and choice names. */
    optionChoiceNames?: V3OptionChoiceNames;
}
interface V3OptionChoiceIds {
    /** Option ID. */
    optionId?: string;
    /** Choice ID. */
    choiceId?: string;
}
interface V3OptionChoiceNames {
    /** Option name. */
    optionName?: string;
    /** Choice name. */
    choiceName?: string;
    /** Render type. */
    renderType?: ProductOptionRenderType;
}
interface CreateProductWithInventoryResponse {
    /** Created product. */
    product?: V3Product;
    /** Inventories created by bulk action. */
    inventoryResults?: BulkInventoryItemResults;
}
interface BulkInventoryItemResults {
    /** Inventories modified by bulk action. */
    results?: BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
    /** Error details in case of failed action. */
    error?: ApplicationError$2;
}
interface BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: CommonItemMetadata;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem;
}
interface CommonItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$2;
}
interface ApplicationError$2 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/** Inventory Item. */
interface InventoryItem extends InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo$2;
    /**
     * Product.
     * @readonly
     */
    product?: Product;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
/** @oneof */
interface InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
declare enum AvailabilityStatus {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    IN_STOCK = "IN_STOCK",
    /**
     * Whether the variant is available for preorder. InventoryItem will be available only when all below conditions are met:
     * 1. the variant is out of stock
     * 2. preorder is enabled on inventory item level (preorder_setting.enabled is true)
     * 3. preorder limit wasn't reached (preorder_setting.limit)
     */
    PREORDER = "PREORDER"
}
interface Product {
    /** Product name. */
    name?: string | null;
    /** List of category IDs that this product is included in directly. */
    directCategoryIds?: string[];
    /** Variant name. */
    variantName?: string | null;
    /** Variant SKU (stock keeping unit). */
    variantSku?: string | null;
}
interface CommonBulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface UpdateProductRequest {
    /** Product to update. */
    product: V3Product;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
interface UpdateProductResponse {
    /** Updated product. */
    product?: V3Product;
}
interface UpdateProductWithInventoryRequest {
    /** Product to update. */
    product: ProductWithInventory;
    /**
     * Whether to return the full inventory entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
interface UpdateProductWithInventoryResponse {
    /** Updated product. */
    product?: V3Product;
    /** Inventories updated by bulk action. */
    inventoryResults?: BulkInventoryItemResults;
}
interface BulkCreateProductsRequest {
    /** List of products to create. */
    products: V3Product[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
declare enum RequestedFields$2 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    URL = "URL",
    CURRENCY = "CURRENCY",
    INFO_SECTION = "INFO_SECTION",
    /** You can request merchant data only if you have `WIX_STORES.PRODUCT_MERCHANT_DATA_READ` permission. */
    MERCHANT_DATA = "MERCHANT_DATA",
    PLAIN_DESCRIPTION = "PLAIN_DESCRIPTION",
    INFO_SECTION_PLAIN_DESCRIPTION = "INFO_SECTION_PLAIN_DESCRIPTION",
    SUBSCRIPTION_PRICES_INFO = "SUBSCRIPTION_PRICES_INFO",
    VARIANTS_INFO = "VARIANTS_INFO",
    BREADCRUMBS_INFO = "BREADCRUMBS_INFO",
    WEIGHT_MEASUREMENT_UNIT_INFO = "WEIGHT_MEASUREMENT_UNIT_INFO",
    VARIANT_OPTION_CHOICE_NAMES = "VARIANT_OPTION_CHOICE_NAMES",
    MEDIA_ITEMS_INFO = "MEDIA_ITEMS_INFO",
    DESCRIPTION = "DESCRIPTION",
    DIRECT_CATEGORIES_INFO = "DIRECT_CATEGORIES_INFO",
    ALL_CATEGORIES_INFO = "ALL_CATEGORIES_INFO",
    MIN_VARIANT_PRICE_INFO = "MIN_VARIANT_PRICE_INFO",
    INFO_SECTION_DESCRIPTION = "INFO_SECTION_DESCRIPTION",
    THUMBNAIL = "THUMBNAIL",
    DIRECT_CATEGORY_IDS = "DIRECT_CATEGORY_IDS"
}
interface BulkCreateProductsResponse {
    /** Products created by bulk action. */
    results?: CatalogV3BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
}
interface CatalogV3BulkProductResult {
    /** Information about successful action or error for failure. */
    itemMetadata?: WixCommonItemMetadata;
    /**
     * Full product entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: V3Product;
}
interface WixCommonItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$2;
}
interface BulkCreateProductsWithInventoryRequest {
    /** List of products to create with inventory. */
    products: ProductWithInventory[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface BulkCreateProductsWithInventoryResponse {
    /** Products created by bulk action. */
    productResults?: BulkProductResults;
    /** Inventories created by bulk action. */
    inventoryResults?: BulkInventoryItemResults;
}
interface BulkProductResults {
    /** Products modified by bulk action. */
    results?: CatalogV3BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
}
interface BulkUpdateProductsRequest {
    /** List of products to update. */
    products: V3MaskedProduct[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface V3MaskedProduct {
    /** Product to update. */
    product?: V3Product;
}
interface BulkUpdateProductsResponse {
    /** Products updated by bulk action. */
    results?: CatalogV3BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
}
interface BulkUpdateProductsWithInventoryRequest {
    /** List of products to update. */
    products: MaskedProductWithInventory[];
    /**
     * Whether to return the full product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface MaskedProductWithInventory {
    /** Product to update. */
    product?: ProductWithInventory;
}
interface BulkUpdateProductsWithInventoryResponse {
    /** Products updated by bulk action. */
    productResults?: BulkProductResults;
    /** Inventories updated by bulk action. */
    inventoryResults?: BulkInventoryItemResults;
}
interface V3BulkUpdateProductsByFilterRequest {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Product to update. */
    product: V3Product;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface WixCommonSearchDetails {
    /** Defines how separate search terms in `expression` are combined */
    mode?: CommonSearchDetailsMode;
    /** Search term or expression */
    expression?: string | null;
    /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path */
    fields?: string[];
    /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
    fuzzy?: boolean;
}
declare enum CommonSearchDetailsMode {
    /** Any of the search terms must be present */
    OR = "OR",
    /** All search terms must be present */
    AND = "AND"
}
interface V3BulkUpdateProductsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3UpdateExtendedFieldsRequest {
    /** Product ID. */
    productId: string;
    /** App namespace. */
    namespace: string;
    /** Data to update. */
    namespaceData: Record<string, any> | null;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
interface V3UpdateExtendedFieldsResponse {
    /** Updated product. */
    product?: V3Product;
}
interface V3DeleteProductRequest {
    /** Product ID. */
    productId: string;
}
interface V3DeleteProductResponse {
}
interface V3BulkDeleteProductsRequest {
    /** IDs of products to delete. */
    productIds: string[];
}
interface V3BulkDeleteProductsResponse {
    /** Products deleted by bulk action. */
    results?: BulkDeleteProductsResponseBulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
}
interface BulkDeleteProductsResponseBulkProductResult {
    /** Bulk action metadata for products. */
    itemMetadata?: WixCommonItemMetadata;
}
interface V3BulkDeleteProductsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface V3BulkDeleteProductsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3GetProductRequest {
    /** Product ID. */
    productId: string;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
interface V3GetProductResponse {
    /** Product. */
    product?: V3Product;
}
interface V3GetProductBySlugRequest {
    /** Product slug. */
    slug: string;
    /** Fields to include in the response. */
    fields?: SingleEntityOpsRequestedFields[];
}
interface V3GetProductBySlugResponse {
    /** Product. */
    product?: V3Product;
}
interface V3SearchProductsRequest {
    /** Search options. */
    search?: CommonCursorSearch;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface CommonCursorSearch extends CommonCursorSearchPagingMethodOneOf {
    /**
     * Cursor pointing to page of results.
     * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
     */
    cursorPaging?: CommonCursorPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: WixCommonSorting[];
    /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: WixCommonAggregation[];
    /** Free text to match in searchable fields */
    search?: WixCommonSearchDetails;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
     */
    timeZone?: string | null;
}
/** @oneof */
interface CommonCursorSearchPagingMethodOneOf {
    /**
     * Cursor pointing to page of results.
     * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
     */
    cursorPaging?: CommonCursorPaging;
}
interface WixCommonSorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: WixCommonSortOrder;
    /**
     * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
     * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
     *
     * If multiple filters are provided, they are combined with AND operator.
     *
     * Example:
     * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
     * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
     * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
     */
    selectItemsBy?: Record<string, any>[] | null;
}
declare enum WixCommonSortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface WixCommonAggregation extends WixCommonAggregationKindOneOf {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation;
    /** Nested aggregation */
    nested?: CommonAggregationNestedAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: WixCommonAggregationType;
    /** Field to aggregate by, use dot notation to specify json path */
    fieldPath?: string;
}
/** @oneof */
interface WixCommonAggregationKindOneOf {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation;
    /** Nested aggregation */
    nested?: CommonAggregationNestedAggregation;
}
interface AggregationRangeAggregationRangeBucket {
    /** Inclusive lower bound of the range. Required if to is not given */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if from is not given */
    to?: number | null;
}
declare enum AggregationValueAggregationSortType {
    /** Should sort by number of matches */
    COUNT = "COUNT",
    /** Should sort by value of the field alphabetically */
    VALUE = "VALUE"
}
declare enum AggregationValueAggregationSortDirection {
    /** Should sort in descending order */
    DESC = "DESC",
    /** Should sort in ascending order */
    ASC = "ASC"
}
declare enum AggregationValueAggregationMissingValues {
    /** Should missing values be excluded from the aggregation results */
    EXCLUDE = "EXCLUDE",
    /** Should missing values be included in the aggregation results */
    INCLUDE = "INCLUDE"
}
interface AggregationValueAggregationIncludeMissingValuesOptions {
    /** Can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
    addToBucket?: string;
}
declare enum WixCommonScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value */
    MIN = "MIN",
    /** Maximum value */
    MAX = "MAX",
    /** Sum of values */
    SUM = "SUM",
    /** Average of values */
    AVG = "AVG"
}
interface CommonAggregationValueAggregation extends CommonAggregationValueAggregationOptionsOneOf {
    /** Options for including missing values */
    includeOptions?: AggregationValueAggregationIncludeMissingValuesOptions;
    /** Should sort by number of matches or value of the field */
    sortType?: AggregationValueAggregationSortType;
    /** Should sort in ascending or descending order */
    sortDirection?: AggregationValueAggregationSortDirection;
    /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
    missingValues?: AggregationValueAggregationMissingValues;
}
/** @oneof */
interface CommonAggregationValueAggregationOptionsOneOf {
    /** Options for including missing values */
    includeOptions?: AggregationValueAggregationIncludeMissingValuesOptions;
}
declare enum AggregationNestedAggregationNestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
interface CommonAggregationRangeAggregation {
    /** List of range buckets, where during aggregation each entity will be placed in the first bucket where its value falls into based on provided range bounds */
    buckets?: AggregationRangeAggregationRangeBucket[];
}
interface CommonAggregationScalarAggregation {
    /** Define the operator for the scalar aggregation */
    type?: WixCommonScalarType;
}
interface CommonAggregationDateHistogramAggregation {
    /** Interval for date histogram aggregation */
    interval?: AggregationDateHistogramAggregationInterval;
}
declare enum AggregationDateHistogramAggregationInterval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
interface AggregationNestedAggregationNestedAggregationItem extends AggregationNestedAggregationNestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: AggregationNestedAggregationNestedAggregationType;
    /** Field to aggregate by, use dont notation to specify json path */
    fieldPath?: string;
}
/** @oneof */
interface AggregationNestedAggregationNestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: CommonAggregationValueAggregation;
    /** Range aggregation */
    range?: CommonAggregationRangeAggregation;
    /** Scalar aggregation */
    scalar?: CommonAggregationScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: CommonAggregationDateHistogramAggregation;
}
declare enum WixCommonAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket */
    RANGE = "RANGE",
    /** A single-value metric aggregation - e.g. min, max, sum, avg */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one */
    NESTED = "NESTED"
}
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
interface CommonAggregationNestedAggregation {
    /** Flattened list of aggregations, where each next aggregation is nested within previous one */
    nestedAggregations?: AggregationNestedAggregationNestedAggregationItem[];
}
interface CommonCursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface V3SearchProductsResponse {
    /** List of products. */
    products?: V3Product[];
    /** Paging metadata. */
    pagingMetadata?: CommonCursorPagingMetadata;
    /** Aggregation data. */
    aggregationData?: CommonAggregationData;
}
interface CommonCursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: CommonCursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface CommonCursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface CommonAggregationData {
    /** key = aggregation name (as derived from search request) */
    results?: AggregationDataAggregationResults[];
}
interface ValueResultsValueAggregationResult {
    /** Value of the field */
    value?: string;
    /** Count of entities with this value */
    count?: number;
}
interface RangeResultsRangeAggregationResult {
    /** Inclusive lower bound of the range */
    from?: number | null;
    /** Exclusive upper bound of the range */
    to?: number | null;
    /** Count of entities in this range */
    count?: number;
}
interface AggregationResultsNestedAggregationResults extends AggregationResultsNestedAggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: AggregationResultsValueResults;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult;
    /** User-defined name of aggregation, matches the one provided in request */
    name?: string;
    /** Type of aggregation that matches result */
    type?: WixCommonAggregationType;
    /** Field to aggregate by, matches the one provided in request */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsNestedAggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: AggregationResultsValueResults;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult;
}
interface AggregationResultsValueResults {
    /** List of value aggregations */
    results?: ValueResultsValueAggregationResult[];
}
interface AggregationResultsRangeResults {
    /** List of ranges returned in same order as requested */
    results?: RangeResultsRangeAggregationResult[];
}
interface AggregationDataAggregationResultsScalarResult {
    /** Type of scalar aggregation */
    type?: WixCommonScalarType;
    /** Value of the scalar aggregation */
    value?: number;
}
interface GroupByValueResultsNestedValueAggregationResult {
    /** Value of the field */
    value?: string;
    /** Nested aggregations */
    nestedResults?: AggregationResultsNestedAggregationResults;
}
interface NestedResultsValueResult {
    /** Value of the field */
    value?: string;
    /** Count of entities with this value */
    count?: number | null;
}
interface NestedResultsRangeResult {
    /** Inclusive lower bound of the range */
    from?: number | null;
    /** Exclusive upper bound of the range */
    to?: number | null;
    /** Count of entities in this range */
    count?: number | null;
}
interface NestedResultsScalarResult {
    /** Value of the scalar aggregation */
    value?: number;
}
interface NestedResultsNestedResultValue extends NestedResultsNestedResultValueResultOneOf {
    /** Value aggregation result */
    value?: NestedResultsValueResult;
    /** Range aggregation result */
    range?: NestedResultsRangeResult;
    /** Scalar aggregation result */
    scalar?: NestedResultsScalarResult;
    /** Date histogram aggregation result */
    dateHistogram?: NestedResultsValueResult;
}
/** @oneof */
interface NestedResultsNestedResultValueResultOneOf {
    /** Value aggregation result */
    value?: NestedResultsValueResult;
    /** Range aggregation result */
    range?: NestedResultsRangeResult;
    /** Scalar aggregation result */
    scalar?: NestedResultsScalarResult;
    /** Date histogram aggregation result */
    dateHistogram?: NestedResultsValueResult;
}
interface NestedResultsResults {
    /** List of nested aggregations */
    results?: Record<string, NestedResultsNestedResultValue>;
}
interface DateHistogramResultsDateHistogramResult {
    /** Date in ISO 8601 format */
    value?: string;
    /** Count of documents in the bucket */
    count?: number;
}
interface AggregationResultsGroupByValueResults {
    /** List of value aggregations */
    results?: GroupByValueResultsNestedValueAggregationResult[];
}
interface AggregationResultsDateHistogramResults {
    /** List of date histogram aggregations */
    results?: DateHistogramResultsDateHistogramResult[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form
 * aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface AggregationResultsNestedResults {
    /** List of nested aggregations */
    results?: NestedResultsResults[];
}
interface AggregationDataAggregationResults extends AggregationDataAggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: AggregationResultsValueResults;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult;
    /** Group by value aggregation results */
    groupedByValue?: AggregationResultsGroupByValueResults;
    /** Date histogram aggregation results */
    dateHistogram?: AggregationResultsDateHistogramResults;
    /** Nested aggregation results */
    nested?: AggregationResultsNestedResults;
    /** User-defined name of aggregation as derived from search request */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request */
    type?: WixCommonAggregationType;
    /** Field to aggregate by as derived from search request */
    fieldPath?: string;
}
/** @oneof */
interface AggregationDataAggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: AggregationResultsValueResults;
    /** Range aggregation results */
    ranges?: AggregationResultsRangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationDataAggregationResultsScalarResult;
    /** Group by value aggregation results */
    groupedByValue?: AggregationResultsGroupByValueResults;
    /** Date histogram aggregation results */
    dateHistogram?: AggregationResultsDateHistogramResults;
    /** Nested aggregation results */
    nested?: AggregationResultsNestedResults;
}
interface V3QueryProductsRequest {
    /** Query options. */
    query?: CommonCursorQuery;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface CommonCursorQuery extends CommonCursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CommonCursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: WixCommonSorting[];
}
/** @oneof */
interface CommonCursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CommonCursorPaging;
}
interface V3QueryProductsResponse {
    /** List of products. */
    products?: V3Product[];
    /** Paging metadata. */
    pagingMetadata?: CommonCursorPagingMetadata;
}
interface V3CountProductsRequest {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
    /**
     * Whether to return non-visible products (`visible:false`). Your app must have the required `SCOPE.STORES.PRODUCT_READ_ADMIN` permission scope.
     *
     * Default: `false`
     */
    returnNonVisibleProducts?: boolean;
}
interface V3CountProductsResponse {
    /** Total number of products. */
    count?: number;
}
interface BulkUpdateProductVariantsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Variant to update. */
    variant: Variant;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface BulkUpdateProductVariantsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface BulkAdjustProductVariantsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Base price adjustment. */
    basePrice?: V3AdjustValue;
    /** Sale price adjustment. */
    salePrice?: V3AdjustValue;
    /** Cost adjustment. */
    cost?: V3AdjustValue;
    /**
     * Set variant sale price from base price by applying provided discount to it.
     * For example variant base price 100$, variant sale price 95$, requested `salePriceFromBasePrice.percentage` is 10, then old sale price ignored and new sale price set to 90 (100$ - 10%).
     */
    salePriceFromBasePrice?: V3UnsignedAdjustValue;
    /**
     * Rounding strategy of new calculated prices.
     *
     * + `NO_ROUNDING`: Calculated prices will be saved without rounding to keep max possible precision.
     * + `CURRENCY_PRECISION`: Calculated prices will be rounded according to the currency's precision requirements. For example. `$3.5555` will be saved as `$3.56`; `¥3.5555` will be saved as `¥4`.
     * + `NEAREST_WHOLE_NUMBER`: Calculated prices will be rounded to the nearest whole number.
     */
    rounding?: BulkAdjustProductVariantsByFilterRequestRoundingStrategy;
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface V3AdjustValue extends V3AdjustValueAdjustValueOneOf {
    /** A decimal value to increase or reduce from the original value, can be negative. */
    amount?: string;
    /** The percentage value to increase or reduce from the current value, can be negative. */
    percentage?: number;
}
/** @oneof */
interface V3AdjustValueAdjustValueOneOf {
    /** A decimal value to increase or reduce from the original value, can be negative. */
    amount?: string;
    /** The percentage value to increase or reduce from the current value, can be negative. */
    percentage?: number;
}
interface V3UnsignedAdjustValue extends V3UnsignedAdjustValueAdjustValueOneOf {
    /** A decimal value to reduce from the original value. */
    amount?: string;
    /** The percentage value to reduce from the original value. */
    percentage?: number;
}
/** @oneof */
interface V3UnsignedAdjustValueAdjustValueOneOf {
    /** A decimal value to reduce from the original value. */
    amount?: string;
    /** The percentage value to reduce from the original value. */
    percentage?: number;
}
declare enum BulkAdjustProductVariantsByFilterRequestRoundingStrategy {
    UNKNOWN_ROUNDING_STRATEGY = "UNKNOWN_ROUNDING_STRATEGY",
    /**
     * Calculated prices will be saved without rounding to keep max possible precision. It's still good idea to round numbers before displaying them.
     * Example: input $3.5555 -> saved value $3.5555
     */
    NO_ROUNDING = "NO_ROUNDING",
    /**
     * Calculated prices will be rounded according to currency precision.
     * Example: input $3.5555 -> saved value $3.56, input ¥3.5555 -> saved value ¥4
     */
    CURRENCY_PRECISION = "CURRENCY_PRECISION",
    /**
     * Calculated prices will be rounded to nearest whole number.
     * Example: input $3.5555 -> saved value $4
     */
    NEAREST_WHOLE_NUMBER = "NEAREST_WHOLE_NUMBER"
}
interface BulkAdjustProductVariantsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3BulkAddInfoSectionsToProductsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** IDs of the info sections to add. */
    infoSectionIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface V3BulkAddInfoSectionsToProductsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3BulkAddInfoSectionsToProductsRequest {
    /** List of product IDs and revisions. */
    products: V3ProductIdWithRevision[];
    /** List of IDs of info sections to add. */
    infoSectionIds: string[];
    /**
     * Whether to return the full updated product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface V3ProductIdWithRevision {
    /** Product ID. */
    productId?: string;
    /**
     * Revision number, which increments by 1 each time the product is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the product.
     */
    revision?: string;
}
interface V3BulkAddInfoSectionsToProductsResponse {
    /** Products updated by bulk action. */
    results?: CatalogV3BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
}
interface V3BulkRemoveInfoSectionsFromProductsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** IDs of info sections to remove. */
    infoSectionIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface V3BulkRemoveInfoSectionsFromProductsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface V3BulkRemoveInfoSectionsFromProductsRequest {
    /** List of product IDs and revisions. */
    products: V3ProductIdWithRevision[];
    /** List of IDs of info sections to remove. */
    infoSectionIds: string[];
    /**
     * Whether to return the full updated product entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Fields to include in the response. */
    fields?: RequestedFields$2[];
}
interface V3BulkRemoveInfoSectionsFromProductsResponse {
    /** Products updated by bulk action. */
    results?: CatalogV3BulkProductResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: CommonBulkActionMetadata;
}
interface BulkAddProductsToCategoriesByFilterRequest {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** IDs of the categories to which products will be added. */
    categoryIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface BulkAddProductsToCategoriesByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface BulkRemoveProductsFromCategoriesByFilterRequest {
    /** Filter object. */
    filter?: Record<string, any> | null;
    /** IDs of the categories from which products will be removed. */
    categoryIds: string[];
    /** Free text to match in searchable fields. */
    search?: WixCommonSearchDetails;
}
interface BulkRemoveProductsFromCategoriesByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata..
     */
    jobId?: string;
}
interface PricePerUnitSettingsNonNullableFields {
    quantity: number;
    measurementUnit: MeasurementUnit;
}
interface WeightRangeNonNullableFields {
    minValue: number;
    maxValue: number;
}
interface PricePerUnitRangePricePerUnitNonNullableFields {
    value: string;
}
interface PricePerUnitRangeNonNullableFields {
    minValue?: PricePerUnitRangePricePerUnitNonNullableFields;
    maxValue?: PricePerUnitRangePricePerUnitNonNullableFields;
}
interface WeightMeasurementUnitInfoNonNullableFields {
    weightMeasurementUnit: WeightUnit;
}
interface PhysicalPropertiesNonNullableFields {
    pricePerUnit?: PricePerUnitSettingsNonNullableFields;
    shippingWeightRange?: WeightRangeNonNullableFields;
    pricePerUnitRange?: PricePerUnitRangeNonNullableFields;
    weightMeasurementUnitInfo?: WeightMeasurementUnitInfoNonNullableFields;
}
interface PluginContainerDataWidthNonNullableFields {
    size: WidthType;
}
interface PluginContainerDataNonNullableFields {
    width?: PluginContainerDataWidthNonNullableFields;
    alignment: PluginContainerDataAlignment;
}
interface LinkNonNullableFields {
    url: string;
    anchor: string;
    target: Target;
}
interface ButtonDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    type: Type;
    link?: LinkNonNullableFields;
}
interface TextStyleNonNullableFields {
    textAlignment: TextAlignment;
}
interface CodeBlockDataNonNullableFields {
    textStyle?: TextStyleNonNullableFields;
}
interface DividerDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    lineStyle: LineStyle;
    width: Width;
    alignment: Alignment;
}
interface PDFSettingsNonNullableFields {
    viewMode: ViewMode;
}
interface FileDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    pdfSettings?: PDFSettingsNonNullableFields;
}
interface ImageNonNullableFields {
    link?: LinkNonNullableFields;
}
interface ItemNonNullableFields {
    image?: ImageNonNullableFields;
}
interface LayoutNonNullableFields {
    type: LayoutType;
    orientation: Orientation;
}
interface ItemStyleNonNullableFields {
    crop: Crop;
}
interface ThumbnailsNonNullableFields {
    placement: ThumbnailsAlignment;
}
interface GalleryOptionsNonNullableFields {
    layout?: LayoutNonNullableFields;
    item?: ItemStyleNonNullableFields;
    thumbnails?: ThumbnailsNonNullableFields;
}
interface GalleryDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    items: ItemNonNullableFields[];
    options?: GalleryOptionsNonNullableFields;
}
interface GIFDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    height: number;
    width: number;
}
interface HeadingDataNonNullableFields {
    level: number;
    textStyle?: TextStyleNonNullableFields;
}
interface HTMLDataNonNullableFields {
    url: string;
    html: string;
    containerData?: PluginContainerDataNonNullableFields;
    source: Source;
}
interface ImageDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    link?: LinkNonNullableFields;
}
interface LinkPreviewDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    link?: LinkNonNullableFields;
}
interface MapSettingsNonNullableFields {
    mapType: MapType;
}
interface MapDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    mapSettings?: MapSettingsNonNullableFields;
}
interface ParagraphDataNonNullableFields {
    textStyle?: TextStyleNonNullableFields;
}
interface PermissionsNonNullableFields {
    view: ViewRole;
    vote: VoteRole;
}
interface PollSettingsNonNullableFields {
    permissions?: PermissionsNonNullableFields;
}
interface PollNonNullableFields {
    settings?: PollSettingsNonNullableFields;
}
interface PollLayoutNonNullableFields {
    type: PollLayoutType;
    direction: PollLayoutDirection;
}
interface PollDataLayoutNonNullableFields {
    poll?: PollLayoutNonNullableFields;
}
interface BackgroundNonNullableFields {
    type: BackgroundType;
}
interface PollDesignNonNullableFields {
    background?: BackgroundNonNullableFields;
}
interface DesignNonNullableFields {
    poll?: PollDesignNonNullableFields;
}
interface PollDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    poll?: PollNonNullableFields;
    layout?: PollDataLayoutNonNullableFields;
    design?: DesignNonNullableFields;
}
interface AnchorDataNonNullableFields {
    anchor: string;
}
interface LinkDataNonNullableFields {
    link?: LinkNonNullableFields;
}
interface MentionDataNonNullableFields {
    name: string;
    slug: string;
}
interface FontSizeDataNonNullableFields {
    unit: FontType;
}
interface DecorationNonNullableFields {
    anchorData?: AnchorDataNonNullableFields;
    linkData?: LinkDataNonNullableFields;
    mentionData?: MentionDataNonNullableFields;
    fontSizeData?: FontSizeDataNonNullableFields;
    type: DecorationType;
}
interface TextDataNonNullableFields {
    text: string;
    decorations: DecorationNonNullableFields[];
}
interface AppEmbedDataNonNullableFields {
    type: AppType;
}
interface VideoDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
}
interface EmbedDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
}
interface CollapsibleListDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    initialExpandedItems: InitialExpandedItems;
    direction: Direction;
}
interface DimensionsNonNullableFields {
    colsWidthRatio: number[];
    rowsHeight: number[];
    colsMinWidth: number[];
}
interface TableDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
    dimensions?: DimensionsNonNullableFields;
}
interface CellStyleNonNullableFields {
    verticalAlignment: VerticalAlignment;
}
interface TableCellDataNonNullableFields {
    cellStyle?: CellStyleNonNullableFields;
}
interface AudioDataNonNullableFields {
    containerData?: PluginContainerDataNonNullableFields;
}
interface OrderedListDataNonNullableFields {
    indentation: number;
}
interface BulletedListDataNonNullableFields {
    indentation: number;
}
interface BlockquoteDataNonNullableFields {
    indentation: number;
}
interface CaptionDataNonNullableFields {
    textStyle?: TextStyleNonNullableFields;
}
interface NodeNonNullableFields {
    buttonData?: ButtonDataNonNullableFields;
    codeBlockData?: CodeBlockDataNonNullableFields;
    dividerData?: DividerDataNonNullableFields;
    fileData?: FileDataNonNullableFields;
    galleryData?: GalleryDataNonNullableFields;
    gifData?: GIFDataNonNullableFields;
    headingData?: HeadingDataNonNullableFields;
    htmlData?: HTMLDataNonNullableFields;
    imageData?: ImageDataNonNullableFields;
    linkPreviewData?: LinkPreviewDataNonNullableFields;
    mapData?: MapDataNonNullableFields;
    paragraphData?: ParagraphDataNonNullableFields;
    pollData?: PollDataNonNullableFields;
    textData?: TextDataNonNullableFields;
    appEmbedData?: AppEmbedDataNonNullableFields;
    videoData?: VideoDataNonNullableFields;
    embedData?: EmbedDataNonNullableFields;
    collapsibleListData?: CollapsibleListDataNonNullableFields;
    tableData?: TableDataNonNullableFields;
    tableCellData?: TableCellDataNonNullableFields;
    audioData?: AudioDataNonNullableFields;
    orderedListData?: OrderedListDataNonNullableFields;
    bulletedListData?: BulletedListDataNonNullableFields;
    blockquoteData?: BlockquoteDataNonNullableFields;
    captionData?: CaptionDataNonNullableFields;
    type: NodeType;
    _id: string;
    nodes: NodeNonNullableFields[];
}
interface MetadataNonNullableFields {
    version: number;
}
interface TextNodeStyleNonNullableFields {
    decorations: DecorationNonNullableFields[];
}
interface DocumentStyleNonNullableFields {
    headerOne?: TextNodeStyleNonNullableFields;
    headerTwo?: TextNodeStyleNonNullableFields;
    headerThree?: TextNodeStyleNonNullableFields;
    headerFour?: TextNodeStyleNonNullableFields;
    headerFive?: TextNodeStyleNonNullableFields;
    headerSix?: TextNodeStyleNonNullableFields;
    paragraph?: TextNodeStyleNonNullableFields;
    blockquote?: TextNodeStyleNonNullableFields;
    codeBlock?: TextNodeStyleNonNullableFields;
}
interface RichContentNonNullableFields {
    nodes: NodeNonNullableFields[];
    metadata?: MetadataNonNullableFields;
    documentStyle?: DocumentStyleNonNullableFields;
}
interface ThumbnailNonNullableFields {
    url: string;
    height: number;
    width: number;
}
interface ProductMediaNonNullableFields {
    _id: string;
    url: string;
    image: string;
    video: string;
    mediaType: MediaType;
    thumbnail?: ThumbnailNonNullableFields;
    uploadId: string;
}
interface MediaItemsInfoNonNullableFields {
    items: ProductMediaNonNullableFields[];
}
interface MediaNonNullableFields {
    main?: ProductMediaNonNullableFields;
    itemsInfo?: MediaItemsInfoNonNullableFields;
}
interface TagNonNullableFields {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields[];
}
interface SeoSchemaNonNullableFields {
    tags: TagNonNullableFields[];
    settings?: SettingsNonNullableFields;
}
interface MultipleColorsNonNullableFields {
    colorCodes: string[];
}
interface ConnectedOptionChoiceNonNullableFields {
    colorCode: string;
    colorCodes?: MultipleColorsNonNullableFields;
    image: string;
    linkedMedia: ProductMediaNonNullableFields[];
    choiceType: ChoiceType;
    key: string;
    inStock: boolean;
    visible: boolean;
}
interface ChoicesSettingsNonNullableFields {
    choices: ConnectedOptionChoiceNonNullableFields[];
}
interface ConnectedOptionNonNullableFields {
    choicesSettings?: ChoicesSettingsNonNullableFields;
    optionRenderType: ProductOptionRenderType;
    key: string;
}
interface FreeTextSettingsNonNullableFields {
    minCharCount: number;
    maxCharCount: number;
    title: string;
    key: string;
}
interface ConnectedModifierChoiceNonNullableFields {
    colorCode: string;
    colorCodes?: MultipleColorsNonNullableFields;
    image: string;
    linkedMedia: ProductMediaNonNullableFields[];
    choiceType: ChoiceType;
    key: string;
}
interface ModifierChoicesSettingsNonNullableFields {
    choices: ConnectedModifierChoiceNonNullableFields[];
}
interface ConnectedModifierNonNullableFields {
    freeTextSettings?: FreeTextSettingsNonNullableFields;
    choicesSettings?: ModifierChoicesSettingsNonNullableFields;
    modifierRenderType: ModifierRenderType;
    mandatory: boolean;
    key: string;
}
interface InfoSectionNonNullableFields {
    description?: RichContentNonNullableFields;
}
interface ProductCategoryNonNullableFields {
    _id: string;
}
interface ProductCategoriesInfoNonNullableFields {
    categories: ProductCategoryNonNullableFields[];
}
interface ProductCategoryIdsInfoNonNullableFields {
    categoryIds: string[];
}
interface FixedMonetaryAmountNonNullableFields {
    amount: string;
}
interface PriceRangeNonNullableFields {
    minValue?: FixedMonetaryAmountNonNullableFields;
    maxValue?: FixedMonetaryAmountNonNullableFields;
}
interface InventoryNonNullableFields {
    availabilityStatus: InventoryAvailabilityStatus;
    preorderStatus: PreorderStatus;
    preorderAvailability: ProductPreorderAvailability;
}
interface BreadCrumbNonNullableFields {
    categoryId: string;
    categoryName: string;
    categorySlug: string;
}
interface BreadcrumbsInfoNonNullableFields {
    breadcrumbs: BreadCrumbNonNullableFields[];
}
interface PricePerUnitNonNullableFields {
    settings?: PricePerUnitSettingsNonNullableFields;
    value: string;
}
interface VariantPhysicalPropertiesNonNullableFields {
    pricePerUnit?: PricePerUnitNonNullableFields;
}
interface SecuredMediaNonNullableFields {
    _id: string;
    fileName: string;
    fileType: FileType;
}
interface VariantDigitalPropertiesNonNullableFields {
    digitalFile?: SecuredMediaNonNullableFields;
}
interface OptionChoiceIdsNonNullableFields {
    optionId: string;
    choiceId: string;
}
interface OptionChoiceNamesNonNullableFields {
    optionName: string;
    choiceName: string;
    renderType: ProductOptionRenderType;
}
interface OptionChoiceNonNullableFields {
    optionChoiceIds?: OptionChoiceIdsNonNullableFields;
    optionChoiceNames?: OptionChoiceNamesNonNullableFields;
}
interface PriceInfoNonNullableFields {
    basePrice?: FixedMonetaryAmountNonNullableFields;
    salePrice?: FixedMonetaryAmountNonNullableFields;
}
interface RevenueDetailsNonNullableFields {
    cost?: FixedMonetaryAmountNonNullableFields;
    profit?: FixedMonetaryAmountNonNullableFields;
    profitMargin: number;
}
interface SubscriptionPricePerUnitNonNullableFields {
    value: string;
}
interface SubscriptionPriceNonNullableFields {
    subscriptionId: string;
    price?: FixedMonetaryAmountNonNullableFields;
    pricePerUnit?: SubscriptionPricePerUnitNonNullableFields;
}
interface SubscriptionPricesInfoNonNullableFields {
    subscriptionPrices: SubscriptionPriceNonNullableFields[];
}
interface InventoryStatusNonNullableFields {
    inStock: boolean;
    preorderEnabled: boolean;
}
interface VariantNonNullableFields {
    physicalProperties?: VariantPhysicalPropertiesNonNullableFields;
    digitalProperties?: VariantDigitalPropertiesNonNullableFields;
    choices: OptionChoiceNonNullableFields[];
    price?: PriceInfoNonNullableFields;
    revenueDetails?: RevenueDetailsNonNullableFields;
    media?: ProductMediaNonNullableFields;
    subscriptionPricesInfo?: SubscriptionPricesInfoNonNullableFields;
    inventoryStatus?: InventoryStatusNonNullableFields;
}
interface VariantsInfoNonNullableFields {
    variants: VariantNonNullableFields[];
}
interface SubscriptionDiscountNonNullableFields {
    amountOff: string;
    percentOff: number;
    type: DiscountType$2;
}
interface SubscriptionNonNullableFields {
    autoRenewal: boolean;
    billingCycles: number;
    title: string;
    frequency: SubscriptionFrequency$2;
    discount?: SubscriptionDiscountNonNullableFields;
}
interface SubscriptionDetailsNonNullableFields {
    subscriptions: SubscriptionNonNullableFields[];
}
interface VariantSummaryNonNullableFields {
    variantCount: number;
}
interface MinVariantPriceInfoNonNullableFields {
    basePrice?: FixedMonetaryAmountNonNullableFields;
    salePrice?: FixedMonetaryAmountNonNullableFields;
    minSubscriptionPrice?: FixedMonetaryAmountNonNullableFields;
    pricePerUnitData?: PricePerUnitNonNullableFields;
    revenueDetails?: RevenueDetailsNonNullableFields;
}
interface V3ProductNonNullableFields {
    physicalProperties?: PhysicalPropertiesNonNullableFields;
    numericId: string;
    url: string;
    description?: RichContentNonNullableFields;
    media?: MediaNonNullableFields;
    seoData?: SeoSchemaNonNullableFields;
    options: ConnectedOptionNonNullableFields[];
    modifiers: ConnectedModifierNonNullableFields[];
    infoSections: InfoSectionNonNullableFields[];
    directCategoriesInfo?: ProductCategoriesInfoNonNullableFields;
    allCategoriesInfo?: ProductCategoriesInfoNonNullableFields;
    directCategoryIdsInfo?: ProductCategoryIdsInfoNonNullableFields;
    basePriceRange?: PriceRangeNonNullableFields;
    salePriceRange?: PriceRangeNonNullableFields;
    costRange?: PriceRangeNonNullableFields;
    inventory?: InventoryNonNullableFields;
    productType: ProductType;
    breadcrumbsInfo?: BreadcrumbsInfoNonNullableFields;
    variantsInfo?: VariantsInfoNonNullableFields;
    subscriptionDetails?: SubscriptionDetailsNonNullableFields;
    flattenOptions: string[];
    flattenModifiers: string[];
    variantSummary?: VariantSummaryNonNullableFields;
    minVariantPriceInfo?: MinVariantPriceInfoNonNullableFields;
}
interface CreateProductResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
}
interface ApplicationErrorNonNullableFields$2 {
    code: string;
    description: string;
}
interface CommonItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$2;
}
interface ProductNonNullableFields {
    directCategoryIds: string[];
}
interface InventoryItemNonNullableFields {
    inStock: boolean;
    quantity: number;
    variantId: string;
    productId: string;
    trackQuantity: boolean;
    availabilityStatus: AvailabilityStatus;
    product?: ProductNonNullableFields;
}
interface BulkInventoryItemResultNonNullableFields {
    itemMetadata?: CommonItemMetadataNonNullableFields;
    item?: InventoryItemNonNullableFields;
}
interface CommonBulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkInventoryItemResultsNonNullableFields {
    results: BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
    error?: ApplicationErrorNonNullableFields$2;
}
interface CreateProductWithInventoryResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields;
}
interface UpdateProductResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
}
interface UpdateProductWithInventoryResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields;
}
interface WixCommonItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$2;
}
interface CatalogV3BulkProductResultNonNullableFields {
    itemMetadata?: WixCommonItemMetadataNonNullableFields;
    item?: V3ProductNonNullableFields;
}
interface BulkCreateProductsResponseNonNullableFields {
    results: CatalogV3BulkProductResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
}
interface BulkProductResultsNonNullableFields {
    results: CatalogV3BulkProductResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
}
interface BulkCreateProductsWithInventoryResponseNonNullableFields {
    productResults?: BulkProductResultsNonNullableFields;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields;
}
interface BulkUpdateProductsResponseNonNullableFields {
    results: CatalogV3BulkProductResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
}
interface BulkUpdateProductsWithInventoryResponseNonNullableFields {
    productResults?: BulkProductResultsNonNullableFields;
    inventoryResults?: BulkInventoryItemResultsNonNullableFields;
}
interface V3BulkUpdateProductsByFilterResponseNonNullableFields {
    jobId: string;
}
interface V3UpdateExtendedFieldsResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
}
interface BulkDeleteProductsResponseBulkProductResultNonNullableFields {
    itemMetadata?: WixCommonItemMetadataNonNullableFields;
}
interface V3BulkDeleteProductsResponseNonNullableFields {
    results: BulkDeleteProductsResponseBulkProductResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
}
interface V3BulkDeleteProductsByFilterResponseNonNullableFields {
    jobId: string;
}
interface V3GetProductResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
}
interface V3GetProductBySlugResponseNonNullableFields {
    product?: V3ProductNonNullableFields;
}
interface ValueResultsValueAggregationResultNonNullableFields {
    value: string;
    count: number;
}
interface AggregationResultsValueResultsNonNullableFields {
    results: ValueResultsValueAggregationResultNonNullableFields[];
}
interface RangeResultsRangeAggregationResultNonNullableFields {
    count: number;
}
interface AggregationResultsRangeResultsNonNullableFields {
    results: RangeResultsRangeAggregationResultNonNullableFields[];
}
interface AggregationDataAggregationResultsScalarResultNonNullableFields {
    type: WixCommonScalarType;
    value: number;
}
interface AggregationResultsNestedAggregationResultsNonNullableFields {
    values?: AggregationResultsValueResultsNonNullableFields;
    ranges?: AggregationResultsRangeResultsNonNullableFields;
    scalar?: AggregationDataAggregationResultsScalarResultNonNullableFields;
    name: string;
    type: WixCommonAggregationType;
    fieldPath: string;
}
interface GroupByValueResultsNestedValueAggregationResultNonNullableFields {
    value: string;
    nestedResults?: AggregationResultsNestedAggregationResultsNonNullableFields;
}
interface AggregationResultsGroupByValueResultsNonNullableFields {
    results: GroupByValueResultsNestedValueAggregationResultNonNullableFields[];
}
interface DateHistogramResultsDateHistogramResultNonNullableFields {
    value: string;
    count: number;
}
interface AggregationResultsDateHistogramResultsNonNullableFields {
    results: DateHistogramResultsDateHistogramResultNonNullableFields[];
}
interface AggregationDataAggregationResultsNonNullableFields {
    values?: AggregationResultsValueResultsNonNullableFields;
    ranges?: AggregationResultsRangeResultsNonNullableFields;
    scalar?: AggregationDataAggregationResultsScalarResultNonNullableFields;
    groupedByValue?: AggregationResultsGroupByValueResultsNonNullableFields;
    dateHistogram?: AggregationResultsDateHistogramResultsNonNullableFields;
    name: string;
    type: WixCommonAggregationType;
    fieldPath: string;
}
interface CommonAggregationDataNonNullableFields {
    results: AggregationDataAggregationResultsNonNullableFields[];
}
interface V3SearchProductsResponseNonNullableFields {
    products: V3ProductNonNullableFields[];
    aggregationData?: CommonAggregationDataNonNullableFields;
}
interface V3QueryProductsResponseNonNullableFields {
    products: V3ProductNonNullableFields[];
}
interface V3CountProductsResponseNonNullableFields {
    count: number;
}
interface BulkUpdateProductVariantsByFilterResponseNonNullableFields {
    jobId: string;
}
interface BulkAdjustProductVariantsByFilterResponseNonNullableFields {
    jobId: string;
}
interface V3BulkAddInfoSectionsToProductsByFilterResponseNonNullableFields {
    jobId: string;
}
interface V3BulkAddInfoSectionsToProductsResponseNonNullableFields {
    results: CatalogV3BulkProductResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
}
interface V3BulkRemoveInfoSectionsFromProductsByFilterResponseNonNullableFields {
    jobId: string;
}
interface V3BulkRemoveInfoSectionsFromProductsResponseNonNullableFields {
    results: CatalogV3BulkProductResultNonNullableFields[];
    bulkActionMetadata?: CommonBulkActionMetadataNonNullableFields;
}
interface BulkAddProductsToCategoriesByFilterResponseNonNullableFields {
    jobId: string;
}
interface BulkRemoveProductsFromCategoriesByFilterResponseNonNullableFields {
    jobId: string;
}

type __PublicMethodMetaInfo$5<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createProduct(): __PublicMethodMetaInfo$5<'POST', {}, CreateProductRequest, CreateProductRequest$1, CreateProductResponse & CreateProductResponseNonNullableFields, CreateProductResponse$1 & CreateProductResponseNonNullableFields$1>;
declare function createProductWithInventory(): __PublicMethodMetaInfo$5<'POST', {}, CreateProductWithInventoryRequest, CreateProductWithInventoryRequest$1, CreateProductWithInventoryResponse & CreateProductWithInventoryResponseNonNullableFields, CreateProductWithInventoryResponse$1 & CreateProductWithInventoryResponseNonNullableFields$1>;
declare function updateProduct(): __PublicMethodMetaInfo$5<'PATCH', {
    productId: string;
}, UpdateProductRequest, UpdateProductRequest$1, UpdateProductResponse & UpdateProductResponseNonNullableFields, UpdateProductResponse$1 & UpdateProductResponseNonNullableFields$1>;
declare function updateProductWithInventory(): __PublicMethodMetaInfo$5<'PATCH', {
    productId: string;
}, UpdateProductWithInventoryRequest, UpdateProductWithInventoryRequest$1, UpdateProductWithInventoryResponse & UpdateProductWithInventoryResponseNonNullableFields, UpdateProductWithInventoryResponse$1 & UpdateProductWithInventoryResponseNonNullableFields$1>;
declare function bulkCreateProducts(): __PublicMethodMetaInfo$5<'POST', {}, BulkCreateProductsRequest, BulkCreateProductsRequest$1, BulkCreateProductsResponse & BulkCreateProductsResponseNonNullableFields, BulkCreateProductsResponse$1 & BulkCreateProductsResponseNonNullableFields$1>;
declare function bulkCreateProductsWithInventory(): __PublicMethodMetaInfo$5<'POST', {}, BulkCreateProductsWithInventoryRequest, BulkCreateProductsWithInventoryRequest$1, BulkCreateProductsWithInventoryResponse & BulkCreateProductsWithInventoryResponseNonNullableFields, BulkCreateProductsWithInventoryResponse$1 & BulkCreateProductsWithInventoryResponseNonNullableFields$1>;
declare function bulkUpdateProducts(): __PublicMethodMetaInfo$5<'POST', {}, BulkUpdateProductsRequest, BulkUpdateProductsRequest$1, BulkUpdateProductsResponse & BulkUpdateProductsResponseNonNullableFields, BulkUpdateProductsResponse$1 & BulkUpdateProductsResponseNonNullableFields$1>;
declare function bulkUpdateProductsWithInventory(): __PublicMethodMetaInfo$5<'POST', {}, BulkUpdateProductsWithInventoryRequest, BulkUpdateProductsWithInventoryRequest$1, BulkUpdateProductsWithInventoryResponse & BulkUpdateProductsWithInventoryResponseNonNullableFields, BulkUpdateProductsWithInventoryResponse$1 & BulkUpdateProductsWithInventoryResponseNonNullableFields$1>;
declare function bulkUpdateProductsByFilter(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkUpdateProductsByFilterRequest, V3BulkUpdateProductsByFilterRequest$1, V3BulkUpdateProductsByFilterResponse & V3BulkUpdateProductsByFilterResponseNonNullableFields, V3BulkUpdateProductsByFilterResponse$1 & V3BulkUpdateProductsByFilterResponseNonNullableFields$1>;
declare function updateExtendedFields(): __PublicMethodMetaInfo$5<'POST', {
    productId: string;
}, V3UpdateExtendedFieldsRequest, V3UpdateExtendedFieldsRequest$1, V3UpdateExtendedFieldsResponse & V3UpdateExtendedFieldsResponseNonNullableFields, V3UpdateExtendedFieldsResponse$1 & V3UpdateExtendedFieldsResponseNonNullableFields$1>;
declare function deleteProduct(): __PublicMethodMetaInfo$5<'DELETE', {
    productId: string;
}, V3DeleteProductRequest, V3DeleteProductRequest$1, V3DeleteProductResponse, V3DeleteProductResponse$1>;
declare function bulkDeleteProducts(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkDeleteProductsRequest, V3BulkDeleteProductsRequest$1, V3BulkDeleteProductsResponse & V3BulkDeleteProductsResponseNonNullableFields, V3BulkDeleteProductsResponse$1 & V3BulkDeleteProductsResponseNonNullableFields$1>;
declare function bulkDeleteProductsByFilter(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkDeleteProductsByFilterRequest, V3BulkDeleteProductsByFilterRequest$1, V3BulkDeleteProductsByFilterResponse & V3BulkDeleteProductsByFilterResponseNonNullableFields, V3BulkDeleteProductsByFilterResponse$1 & V3BulkDeleteProductsByFilterResponseNonNullableFields$1>;
declare function getProduct(): __PublicMethodMetaInfo$5<'GET', {
    productId: string;
}, V3GetProductRequest, V3GetProductRequest$1, V3GetProductResponse & V3GetProductResponseNonNullableFields, V3GetProductResponse$1 & V3GetProductResponseNonNullableFields$1>;
declare function getProductBySlug(): __PublicMethodMetaInfo$5<'GET', {
    slug: string;
}, V3GetProductBySlugRequest, V3GetProductBySlugRequest$1, V3GetProductBySlugResponse & V3GetProductBySlugResponseNonNullableFields, V3GetProductBySlugResponse$1 & V3GetProductBySlugResponseNonNullableFields$1>;
declare function searchProducts(): __PublicMethodMetaInfo$5<'POST', {}, V3SearchProductsRequest, V3SearchProductsRequest$1, V3SearchProductsResponse & V3SearchProductsResponseNonNullableFields, V3SearchProductsResponse$1 & V3SearchProductsResponseNonNullableFields$1>;
declare function queryProducts(): __PublicMethodMetaInfo$5<'POST', {}, V3QueryProductsRequest, V3QueryProductsRequest$1, V3QueryProductsResponse & V3QueryProductsResponseNonNullableFields, V3QueryProductsResponse$1 & V3QueryProductsResponseNonNullableFields$1>;
declare function countProducts(): __PublicMethodMetaInfo$5<'POST', {}, V3CountProductsRequest, V3CountProductsRequest$1, V3CountProductsResponse & V3CountProductsResponseNonNullableFields, V3CountProductsResponse$1 & V3CountProductsResponseNonNullableFields$1>;
declare function bulkUpdateProductVariantsByFilter(): __PublicMethodMetaInfo$5<'POST', {}, BulkUpdateProductVariantsByFilterRequest, BulkUpdateProductVariantsByFilterRequest$1, BulkUpdateProductVariantsByFilterResponse & BulkUpdateProductVariantsByFilterResponseNonNullableFields, BulkUpdateProductVariantsByFilterResponse$1 & BulkUpdateProductVariantsByFilterResponseNonNullableFields$1>;
declare function bulkAdjustProductVariantsByFilter(): __PublicMethodMetaInfo$5<'POST', {}, BulkAdjustProductVariantsByFilterRequest, BulkAdjustProductVariantsByFilterRequest$1, BulkAdjustProductVariantsByFilterResponse & BulkAdjustProductVariantsByFilterResponseNonNullableFields, BulkAdjustProductVariantsByFilterResponse$1 & BulkAdjustProductVariantsByFilterResponseNonNullableFields$1>;
declare function bulkAddInfoSectionsToProductsByFilter(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkAddInfoSectionsToProductsByFilterRequest, V3BulkAddInfoSectionsToProductsByFilterRequest$1, V3BulkAddInfoSectionsToProductsByFilterResponse & V3BulkAddInfoSectionsToProductsByFilterResponseNonNullableFields, V3BulkAddInfoSectionsToProductsByFilterResponse$1 & V3BulkAddInfoSectionsToProductsByFilterResponseNonNullableFields$1>;
declare function bulkAddInfoSectionsToProducts(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkAddInfoSectionsToProductsRequest, V3BulkAddInfoSectionsToProductsRequest$1, V3BulkAddInfoSectionsToProductsResponse & V3BulkAddInfoSectionsToProductsResponseNonNullableFields, V3BulkAddInfoSectionsToProductsResponse$1 & V3BulkAddInfoSectionsToProductsResponseNonNullableFields$1>;
declare function bulkRemoveInfoSectionsFromProductsByFilter(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkRemoveInfoSectionsFromProductsByFilterRequest, V3BulkRemoveInfoSectionsFromProductsByFilterRequest$1, V3BulkRemoveInfoSectionsFromProductsByFilterResponse & V3BulkRemoveInfoSectionsFromProductsByFilterResponseNonNullableFields, V3BulkRemoveInfoSectionsFromProductsByFilterResponse$1 & V3BulkRemoveInfoSectionsFromProductsByFilterResponseNonNullableFields$1>;
declare function bulkRemoveInfoSectionsFromProducts(): __PublicMethodMetaInfo$5<'POST', {}, V3BulkRemoveInfoSectionsFromProductsRequest, V3BulkRemoveInfoSectionsFromProductsRequest$1, V3BulkRemoveInfoSectionsFromProductsResponse & V3BulkRemoveInfoSectionsFromProductsResponseNonNullableFields, V3BulkRemoveInfoSectionsFromProductsResponse$1 & V3BulkRemoveInfoSectionsFromProductsResponseNonNullableFields$1>;
declare function bulkAddProductsToCategoriesByFilter(): __PublicMethodMetaInfo$5<'POST', {}, BulkAddProductsToCategoriesByFilterRequest, BulkAddProductsToCategoriesByFilterRequest$1, BulkAddProductsToCategoriesByFilterResponse & BulkAddProductsToCategoriesByFilterResponseNonNullableFields, BulkAddProductsToCategoriesByFilterResponse$1 & BulkAddProductsToCategoriesByFilterResponseNonNullableFields$1>;
declare function bulkRemoveProductsFromCategoriesByFilter(): __PublicMethodMetaInfo$5<'POST', {}, BulkRemoveProductsFromCategoriesByFilterRequest, BulkRemoveProductsFromCategoriesByFilterRequest$1, BulkRemoveProductsFromCategoriesByFilterResponse & BulkRemoveProductsFromCategoriesByFilterResponseNonNullableFields, BulkRemoveProductsFromCategoriesByFilterResponse$1 & BulkRemoveProductsFromCategoriesByFilterResponseNonNullableFields$1>;

declare const meta$5_bulkAddInfoSectionsToProducts: typeof bulkAddInfoSectionsToProducts;
declare const meta$5_bulkAddInfoSectionsToProductsByFilter: typeof bulkAddInfoSectionsToProductsByFilter;
declare const meta$5_bulkAddProductsToCategoriesByFilter: typeof bulkAddProductsToCategoriesByFilter;
declare const meta$5_bulkAdjustProductVariantsByFilter: typeof bulkAdjustProductVariantsByFilter;
declare const meta$5_bulkCreateProducts: typeof bulkCreateProducts;
declare const meta$5_bulkCreateProductsWithInventory: typeof bulkCreateProductsWithInventory;
declare const meta$5_bulkDeleteProducts: typeof bulkDeleteProducts;
declare const meta$5_bulkDeleteProductsByFilter: typeof bulkDeleteProductsByFilter;
declare const meta$5_bulkRemoveInfoSectionsFromProducts: typeof bulkRemoveInfoSectionsFromProducts;
declare const meta$5_bulkRemoveInfoSectionsFromProductsByFilter: typeof bulkRemoveInfoSectionsFromProductsByFilter;
declare const meta$5_bulkRemoveProductsFromCategoriesByFilter: typeof bulkRemoveProductsFromCategoriesByFilter;
declare const meta$5_bulkUpdateProductVariantsByFilter: typeof bulkUpdateProductVariantsByFilter;
declare const meta$5_bulkUpdateProducts: typeof bulkUpdateProducts;
declare const meta$5_bulkUpdateProductsByFilter: typeof bulkUpdateProductsByFilter;
declare const meta$5_bulkUpdateProductsWithInventory: typeof bulkUpdateProductsWithInventory;
declare const meta$5_countProducts: typeof countProducts;
declare const meta$5_createProduct: typeof createProduct;
declare const meta$5_createProductWithInventory: typeof createProductWithInventory;
declare const meta$5_deleteProduct: typeof deleteProduct;
declare const meta$5_getProduct: typeof getProduct;
declare const meta$5_getProductBySlug: typeof getProductBySlug;
declare const meta$5_queryProducts: typeof queryProducts;
declare const meta$5_searchProducts: typeof searchProducts;
declare const meta$5_updateExtendedFields: typeof updateExtendedFields;
declare const meta$5_updateProduct: typeof updateProduct;
declare const meta$5_updateProductWithInventory: typeof updateProductWithInventory;
declare namespace meta$5 {
  export { type __PublicMethodMetaInfo$5 as __PublicMethodMetaInfo, meta$5_bulkAddInfoSectionsToProducts as bulkAddInfoSectionsToProducts, meta$5_bulkAddInfoSectionsToProductsByFilter as bulkAddInfoSectionsToProductsByFilter, meta$5_bulkAddProductsToCategoriesByFilter as bulkAddProductsToCategoriesByFilter, meta$5_bulkAdjustProductVariantsByFilter as bulkAdjustProductVariantsByFilter, meta$5_bulkCreateProducts as bulkCreateProducts, meta$5_bulkCreateProductsWithInventory as bulkCreateProductsWithInventory, meta$5_bulkDeleteProducts as bulkDeleteProducts, meta$5_bulkDeleteProductsByFilter as bulkDeleteProductsByFilter, meta$5_bulkRemoveInfoSectionsFromProducts as bulkRemoveInfoSectionsFromProducts, meta$5_bulkRemoveInfoSectionsFromProductsByFilter as bulkRemoveInfoSectionsFromProductsByFilter, meta$5_bulkRemoveProductsFromCategoriesByFilter as bulkRemoveProductsFromCategoriesByFilter, meta$5_bulkUpdateProductVariantsByFilter as bulkUpdateProductVariantsByFilter, meta$5_bulkUpdateProducts as bulkUpdateProducts, meta$5_bulkUpdateProductsByFilter as bulkUpdateProductsByFilter, meta$5_bulkUpdateProductsWithInventory as bulkUpdateProductsWithInventory, meta$5_countProducts as countProducts, meta$5_createProduct as createProduct, meta$5_createProductWithInventory as createProductWithInventory, meta$5_deleteProduct as deleteProduct, meta$5_getProduct as getProduct, meta$5_getProductBySlug as getProductBySlug, meta$5_queryProducts as queryProducts, meta$5_searchProducts as searchProducts, meta$5_updateExtendedFields as updateExtendedFields, meta$5_updateProduct as updateProduct, meta$5_updateProductWithInventory as updateProductWithInventory };
}

declare enum Version$1 {
    V1_CATALOG = "V1_CATALOG",
    V3_CATALOG = "V3_CATALOG"
}
interface GetCatalogVersionRequest$1 {
}
interface GetCatalogVersionResponse$1 {
    /** The version of Stores Catalog installed on a site. */
    catalogVersion?: Version$1;
}
interface GetCatalogVersionResponseNonNullableFields$1 {
    catalogVersion: Version$1;
}

declare enum Version {
    V1_CATALOG = "V1_CATALOG",
    V3_CATALOG = "V3_CATALOG"
}
interface GetCatalogVersionRequest {
}
interface GetCatalogVersionResponse {
    /** The version of Stores Catalog installed on a site. */
    catalogVersion?: Version;
}
interface GetCatalogVersionResponseNonNullableFields {
    catalogVersion: Version;
}

type __PublicMethodMetaInfo$4<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getCatalogVersion(): __PublicMethodMetaInfo$4<'GET', {}, GetCatalogVersionRequest, GetCatalogVersionRequest$1, GetCatalogVersionResponse & GetCatalogVersionResponseNonNullableFields, GetCatalogVersionResponse$1 & GetCatalogVersionResponseNonNullableFields$1>;

declare const meta$4_getCatalogVersion: typeof getCatalogVersion;
declare namespace meta$4 {
  export { type __PublicMethodMetaInfo$4 as __PublicMethodMetaInfo, meta$4_getCatalogVersion as getCatalogVersion };
}

/** A Ribbon is a visual element that you can assign to products to highlight them on your site. */
interface Ribbon$1 {
    /**
     * Ribbon ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the ribbon is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the ribbon.
     *
     * Ignored when creating a ribbon.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the ribbon was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the ribbon was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** Ribbon name. */
    name?: string;
    /**
     * Number of products this ribbon is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCT_COUNT"` to the `fields` array in Ribbon API requests.
     * @readonly
     */
    assignedProductCount?: number | null;
}
interface CreateRibbonRequest$1 {
    /** Ribbon to create. */
    ribbon: Ribbon$1;
}
interface CreateRibbonResponse$1 {
    /** Created ribbon. */
    ribbon?: Ribbon$1;
}
interface GetRibbonRequest$1 {
    /** Ribbon ID. */
    ribbonId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$1[];
}
declare enum RequestedFields$1 {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCT_COUNT = "ASSIGNED_PRODUCT_COUNT"
}
interface GetRibbonResponse$1 {
    /** Ribbon. */
    ribbon?: Ribbon$1;
}
interface UpdateRibbonRequest$1 {
    /** Ribbon to update. */
    ribbon: Ribbon$1;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$1[];
}
interface UpdateRibbonResponse$1 {
    /** Updated Ribbon. */
    ribbon?: Ribbon$1;
}
interface DeleteRibbonRequest$1 {
    /** Ribbon ID. */
    ribbonId: string;
}
interface DeleteRibbonResponse$1 {
}
interface QueryRibbonsRequest$1 {
    /** Query options. */
    query?: CursorQuery$3;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$1[];
}
interface CursorQuery$3 extends CursorQueryPagingMethodOneOf$3 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$3;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$3[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$3 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$3;
}
interface Sorting$3 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$3;
}
declare enum SortOrder$3 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$3 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryRibbonsResponse$1 {
    /** List of ribbons. */
    ribbons?: Ribbon$1[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$3;
}
interface CursorPagingMetadata$3 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$3;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$3 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateRibbonsRequest$1 {
    /** Ribbons to create. */
    ribbons: Ribbon$1[];
    /**
     * Whether to return the full created ribbon entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateRibbonsResponse$1 {
    /** Ribbons created by bulk action. */
    results?: V3BulkRibbonResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$1;
}
interface V3BulkRibbonResult$1 {
    /** Bulk action metadata for ribbon. */
    itemMetadata?: ItemMetadata$1;
    /**
     * Full ribbon entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: Ribbon$1;
}
interface ItemMetadata$1 {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError$1;
}
interface ApplicationError$1 {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata$1 {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateRibbonsRequest$1 {
    /** List of ribbons to update. */
    ribbons: MaskedRibbon$1[];
    /**
     * Whether to return the full updated ribbon entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$1[];
}
interface MaskedRibbon$1 {
    /** Ribbon to update. */
    ribbon?: Ribbon$1;
}
interface BulkUpdateRibbonsResponse$1 {
    /** Ribbons updated by bulk action. */
    results?: V3BulkRibbonResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$1;
}
interface GetOrCreateRibbonRequest$1 {
    /** Ribbon name to retrieve or create. */
    ribbonName: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$1[];
}
interface GetOrCreateRibbonResponse$1 {
    /** Ribbon. */
    ribbon?: Ribbon$1;
}
interface BulkGetOrCreateRibbonsRequest$1 {
    /** Ribbon names to retrieve or create. */
    ribbonNames: string[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields$1[];
}
interface BulkGetOrCreateRibbonsResponse$1 {
    /** Ribbons retrieved or created by bulk action. */
    results?: V3BulkRibbonResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$1;
}
interface BulkDeleteRibbonsRequest$1 {
    /** IDs of ribbons to delete. */
    ribbonIds: string[];
}
interface BulkDeleteRibbonsResponse$1 {
    /** Ribbons deleted by bulk action. */
    results?: BulkRibbonResult$1[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata$1;
}
interface BulkRibbonResult$1 {
    /** Bulk action metadata for ribbon. */
    itemMetadata?: ItemMetadata$1;
}
interface RibbonNonNullableFields$1 {
    name: string;
}
interface CreateRibbonResponseNonNullableFields$1 {
    ribbon?: RibbonNonNullableFields$1;
}
interface GetRibbonResponseNonNullableFields$1 {
    ribbon?: RibbonNonNullableFields$1;
}
interface UpdateRibbonResponseNonNullableFields$1 {
    ribbon?: RibbonNonNullableFields$1;
}
interface QueryRibbonsResponseNonNullableFields$1 {
    ribbons: RibbonNonNullableFields$1[];
}
interface ApplicationErrorNonNullableFields$1 {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields$1 {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields$1;
}
interface V3BulkRibbonResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$1;
    item?: RibbonNonNullableFields$1;
}
interface BulkActionMetadataNonNullableFields$1 {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateRibbonsResponseNonNullableFields$1 {
    results: V3BulkRibbonResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$1;
}
interface BulkUpdateRibbonsResponseNonNullableFields$1 {
    results: V3BulkRibbonResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$1;
}
interface GetOrCreateRibbonResponseNonNullableFields$1 {
    ribbon?: RibbonNonNullableFields$1;
}
interface BulkGetOrCreateRibbonsResponseNonNullableFields$1 {
    results: V3BulkRibbonResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$1;
}
interface BulkRibbonResultNonNullableFields$1 {
    itemMetadata?: ItemMetadataNonNullableFields$1;
}
interface BulkDeleteRibbonsResponseNonNullableFields$1 {
    results: BulkRibbonResultNonNullableFields$1[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields$1;
}

/** A Ribbon is a visual element that you can assign to products to highlight them on your site. */
interface Ribbon {
    /**
     * Ribbon ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the ribbon is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the ribbon.
     *
     * Ignored when creating a ribbon.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the ribbon was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the ribbon was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Ribbon name. */
    name?: string;
    /**
     * Number of products this ribbon is assigned to.
     * > **Note:** Returned only when you pass `"ASSIGNED_PRODUCT_COUNT"` to the `fields` array in Ribbon API requests.
     * @readonly
     */
    assignedProductCount?: number | null;
}
interface CreateRibbonRequest {
    /** Ribbon to create. */
    ribbon: Ribbon;
}
interface CreateRibbonResponse {
    /** Created ribbon. */
    ribbon?: Ribbon;
}
interface GetRibbonRequest {
    /** Ribbon ID. */
    ribbonId: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
declare enum RequestedFields {
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    ASSIGNED_PRODUCT_COUNT = "ASSIGNED_PRODUCT_COUNT"
}
interface GetRibbonResponse {
    /** Ribbon. */
    ribbon?: Ribbon;
}
interface UpdateRibbonRequest {
    /** Ribbon to update. */
    ribbon: Ribbon;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface UpdateRibbonResponse {
    /** Updated Ribbon. */
    ribbon?: Ribbon;
}
interface DeleteRibbonRequest {
    /** Ribbon ID. */
    ribbonId: string;
}
interface DeleteRibbonResponse {
}
interface QueryRibbonsRequest {
    /** Query options. */
    query?: CursorQuery$2;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface CursorQuery$2 extends CursorQueryPagingMethodOneOf$2 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$2;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$2[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$2 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$2;
}
interface Sorting$2 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$2;
}
declare enum SortOrder$2 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$2 {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryRibbonsResponse {
    /** List of ribbons. */
    ribbons?: Ribbon[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$2;
}
interface CursorPagingMetadata$2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors$2;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$2 {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface BulkCreateRibbonsRequest {
    /** Ribbons to create. */
    ribbons: Ribbon[];
    /**
     * Whether to return the full created ribbon entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateRibbonsResponse {
    /** Ribbons created by bulk action. */
    results?: V3BulkRibbonResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface V3BulkRibbonResult {
    /** Bulk action metadata for ribbon. */
    itemMetadata?: ItemMetadata;
    /**
     * Full ribbon entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: Ribbon;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface BulkUpdateRibbonsRequest {
    /** List of ribbons to update. */
    ribbons: MaskedRibbon[];
    /**
     * Whether to return the full updated ribbon entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface MaskedRibbon {
    /** Ribbon to update. */
    ribbon?: Ribbon;
}
interface BulkUpdateRibbonsResponse {
    /** Ribbons updated by bulk action. */
    results?: V3BulkRibbonResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface GetOrCreateRibbonRequest {
    /** Ribbon name to retrieve or create. */
    ribbonName: string;
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface GetOrCreateRibbonResponse {
    /** Ribbon. */
    ribbon?: Ribbon;
}
interface BulkGetOrCreateRibbonsRequest {
    /** Ribbon names to retrieve or create. */
    ribbonNames: string[];
    /**
     * Fields to include in the response.
     *
     * Supported values: `ASSIGNED_PRODUCTS_COUNT`
     */
    fields?: RequestedFields[];
}
interface BulkGetOrCreateRibbonsResponse {
    /** Ribbons retrieved or created by bulk action. */
    results?: V3BulkRibbonResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkDeleteRibbonsRequest {
    /** IDs of ribbons to delete. */
    ribbonIds: string[];
}
interface BulkDeleteRibbonsResponse {
    /** Ribbons deleted by bulk action. */
    results?: BulkRibbonResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkRibbonResult {
    /** Bulk action metadata for ribbon. */
    itemMetadata?: ItemMetadata;
}
interface RibbonNonNullableFields {
    name: string;
}
interface CreateRibbonResponseNonNullableFields {
    ribbon?: RibbonNonNullableFields;
}
interface GetRibbonResponseNonNullableFields {
    ribbon?: RibbonNonNullableFields;
}
interface UpdateRibbonResponseNonNullableFields {
    ribbon?: RibbonNonNullableFields;
}
interface QueryRibbonsResponseNonNullableFields {
    ribbons: RibbonNonNullableFields[];
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface V3BulkRibbonResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: RibbonNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateRibbonsResponseNonNullableFields {
    results: V3BulkRibbonResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkUpdateRibbonsResponseNonNullableFields {
    results: V3BulkRibbonResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface GetOrCreateRibbonResponseNonNullableFields {
    ribbon?: RibbonNonNullableFields;
}
interface BulkGetOrCreateRibbonsResponseNonNullableFields {
    results: V3BulkRibbonResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkRibbonResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
}
interface BulkDeleteRibbonsResponseNonNullableFields {
    results: BulkRibbonResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}

type __PublicMethodMetaInfo$3<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createRibbon(): __PublicMethodMetaInfo$3<'POST', {}, CreateRibbonRequest, CreateRibbonRequest$1, CreateRibbonResponse & CreateRibbonResponseNonNullableFields, CreateRibbonResponse$1 & CreateRibbonResponseNonNullableFields$1>;
declare function getRibbon(): __PublicMethodMetaInfo$3<'GET', {
    ribbonId: string;
}, GetRibbonRequest, GetRibbonRequest$1, GetRibbonResponse & GetRibbonResponseNonNullableFields, GetRibbonResponse$1 & GetRibbonResponseNonNullableFields$1>;
declare function updateRibbon(): __PublicMethodMetaInfo$3<'PATCH', {
    ribbonId: string;
}, UpdateRibbonRequest, UpdateRibbonRequest$1, UpdateRibbonResponse & UpdateRibbonResponseNonNullableFields, UpdateRibbonResponse$1 & UpdateRibbonResponseNonNullableFields$1>;
declare function deleteRibbon(): __PublicMethodMetaInfo$3<'DELETE', {
    ribbonId: string;
}, DeleteRibbonRequest, DeleteRibbonRequest$1, DeleteRibbonResponse, DeleteRibbonResponse$1>;
declare function queryRibbons(): __PublicMethodMetaInfo$3<'POST', {}, QueryRibbonsRequest, QueryRibbonsRequest$1, QueryRibbonsResponse & QueryRibbonsResponseNonNullableFields, QueryRibbonsResponse$1 & QueryRibbonsResponseNonNullableFields$1>;
declare function bulkCreateRibbons(): __PublicMethodMetaInfo$3<'POST', {}, BulkCreateRibbonsRequest, BulkCreateRibbonsRequest$1, BulkCreateRibbonsResponse & BulkCreateRibbonsResponseNonNullableFields, BulkCreateRibbonsResponse$1 & BulkCreateRibbonsResponseNonNullableFields$1>;
declare function bulkUpdateRibbons(): __PublicMethodMetaInfo$3<'POST', {}, BulkUpdateRibbonsRequest, BulkUpdateRibbonsRequest$1, BulkUpdateRibbonsResponse & BulkUpdateRibbonsResponseNonNullableFields, BulkUpdateRibbonsResponse$1 & BulkUpdateRibbonsResponseNonNullableFields$1>;
declare function getOrCreateRibbon(): __PublicMethodMetaInfo$3<'POST', {}, GetOrCreateRibbonRequest, GetOrCreateRibbonRequest$1, GetOrCreateRibbonResponse & GetOrCreateRibbonResponseNonNullableFields, GetOrCreateRibbonResponse$1 & GetOrCreateRibbonResponseNonNullableFields$1>;
declare function bulkGetOrCreateRibbons(): __PublicMethodMetaInfo$3<'POST', {}, BulkGetOrCreateRibbonsRequest, BulkGetOrCreateRibbonsRequest$1, BulkGetOrCreateRibbonsResponse & BulkGetOrCreateRibbonsResponseNonNullableFields, BulkGetOrCreateRibbonsResponse$1 & BulkGetOrCreateRibbonsResponseNonNullableFields$1>;
declare function bulkDeleteRibbons(): __PublicMethodMetaInfo$3<'POST', {}, BulkDeleteRibbonsRequest, BulkDeleteRibbonsRequest$1, BulkDeleteRibbonsResponse & BulkDeleteRibbonsResponseNonNullableFields, BulkDeleteRibbonsResponse$1 & BulkDeleteRibbonsResponseNonNullableFields$1>;

declare const meta$3_bulkCreateRibbons: typeof bulkCreateRibbons;
declare const meta$3_bulkDeleteRibbons: typeof bulkDeleteRibbons;
declare const meta$3_bulkGetOrCreateRibbons: typeof bulkGetOrCreateRibbons;
declare const meta$3_bulkUpdateRibbons: typeof bulkUpdateRibbons;
declare const meta$3_createRibbon: typeof createRibbon;
declare const meta$3_deleteRibbon: typeof deleteRibbon;
declare const meta$3_getOrCreateRibbon: typeof getOrCreateRibbon;
declare const meta$3_getRibbon: typeof getRibbon;
declare const meta$3_queryRibbons: typeof queryRibbons;
declare const meta$3_updateRibbon: typeof updateRibbon;
declare namespace meta$3 {
  export { type __PublicMethodMetaInfo$3 as __PublicMethodMetaInfo, meta$3_bulkCreateRibbons as bulkCreateRibbons, meta$3_bulkDeleteRibbons as bulkDeleteRibbons, meta$3_bulkGetOrCreateRibbons as bulkGetOrCreateRibbons, meta$3_bulkUpdateRibbons as bulkUpdateRibbons, meta$3_createRibbon as createRibbon, meta$3_deleteRibbon as deleteRibbon, meta$3_getOrCreateRibbon as getOrCreateRibbon, meta$3_getRibbon as getRibbon, meta$3_queryRibbons as queryRibbons, meta$3_updateRibbon as updateRibbon };
}

/** A location is a physical or virtual site where products are sold. */
interface StoresLocation$1 {
    /**
     * Stores location ID.
     * @readonly
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the Stores location is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the Stores location.
     *
     * Ignored when creating a Stores location.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the Stores location was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the Stores location was last updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /**
     * Wix location ID.
     * Learn more about the [Locations API](https://dev.wix.com/docs/rest/business-management/locations/introduction).
     */
    wixLocationId?: string | null;
    /**
     * Location type.
     *
     * + `VIRTUAL`: Online store.
     * + `PHYSICAL`: Physical location. For example, for POS.
     * @readonly
     */
    locationType?: LocationType$1;
    /**
     * Stores location name.
     * @readonly
     */
    name?: string;
    /** Whether the location is the site's default location. */
    defaultLocation?: boolean;
}
declare enum LocationType$1 {
    UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
    /** Online stores location. */
    VIRTUAL = "VIRTUAL",
    /** Physical location like POS */
    PHYSICAL = "PHYSICAL"
}
interface GetStoresLocationRequest$1 {
    /** Stores location ID. */
    storesLocationId: string;
}
interface GetStoresLocationResponse$1 {
    /** Stores location. */
    storesLocation?: StoresLocation$1;
}
interface QueryStoresLocationsRequest$1 {
    /** Query options. */
    query?: CursorQuery$1;
}
interface CursorQuery$1 extends CursorQueryPagingMethodOneOf$1 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$1;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting$1[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf$1 {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging$1;
}
interface Sorting$1 {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder$1;
}
declare enum SortOrder$1 {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging$1 {
    /** Number of items to load. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryStoresLocationsResponse$1 {
    /** List of Stores locations. */
    storesLocations?: StoresLocation$1[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata$1;
}
interface CursorPagingMetadata$1 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    cursors?: Cursors$1;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors$1 {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
interface StoresLocationNonNullableFields$1 {
    locationType: LocationType$1;
    name: string;
    defaultLocation: boolean;
}
interface GetStoresLocationResponseNonNullableFields$1 {
    storesLocation?: StoresLocationNonNullableFields$1;
}
interface QueryStoresLocationsResponseNonNullableFields$1 {
    storesLocations: StoresLocationNonNullableFields$1[];
}

/** A location is a physical or virtual site where products are sold. */
interface StoresLocation {
    /**
     * Stores location ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the Stores location is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the Stores location.
     *
     * Ignored when creating a Stores location.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the Stores location was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the Stores location was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Wix location ID.
     * Learn more about the [Locations API](https://dev.wix.com/docs/rest/business-management/locations/introduction).
     */
    wixLocationId?: string | null;
    /**
     * Location type.
     *
     * + `VIRTUAL`: Online store.
     * + `PHYSICAL`: Physical location. For example, for POS.
     * @readonly
     */
    locationType?: LocationType;
    /**
     * Stores location name.
     * @readonly
     */
    name?: string;
    /** Whether the location is the site's default location. */
    defaultLocation?: boolean;
}
declare enum LocationType {
    UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
    /** Online stores location. */
    VIRTUAL = "VIRTUAL",
    /** Physical location like POS */
    PHYSICAL = "PHYSICAL"
}
interface GetStoresLocationRequest {
    /** Stores location ID. */
    storesLocationId: string;
}
interface GetStoresLocationResponse {
    /** Stores location. */
    storesLocation?: StoresLocation;
}
interface QueryStoresLocationsRequest {
    /** Query options. */
    query?: CursorQuery;
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging {
    /** Number of items to load. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryStoresLocationsResponse {
    /** List of Stores locations. */
    storesLocations?: StoresLocation[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
interface StoresLocationNonNullableFields {
    locationType: LocationType;
    name: string;
    defaultLocation: boolean;
}
interface GetStoresLocationResponseNonNullableFields {
    storesLocation?: StoresLocationNonNullableFields;
}
interface QueryStoresLocationsResponseNonNullableFields {
    storesLocations: StoresLocationNonNullableFields[];
}

type __PublicMethodMetaInfo$2<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getStoresLocation(): __PublicMethodMetaInfo$2<'GET', {
    storesLocationId: string;
}, GetStoresLocationRequest, GetStoresLocationRequest$1, GetStoresLocationResponse & GetStoresLocationResponseNonNullableFields, GetStoresLocationResponse$1 & GetStoresLocationResponseNonNullableFields$1>;
declare function queryStoresLocations(): __PublicMethodMetaInfo$2<'POST', {}, QueryStoresLocationsRequest, QueryStoresLocationsRequest$1, QueryStoresLocationsResponse & QueryStoresLocationsResponseNonNullableFields, QueryStoresLocationsResponse$1 & QueryStoresLocationsResponseNonNullableFields$1>;

declare const meta$2_getStoresLocation: typeof getStoresLocation;
declare const meta$2_queryStoresLocations: typeof queryStoresLocations;
declare namespace meta$2 {
  export { type __PublicMethodMetaInfo$2 as __PublicMethodMetaInfo, meta$2_getStoresLocation as getStoresLocation, meta$2_queryStoresLocations as queryStoresLocations };
}

interface SubscriptionOption$1 {
    /** Subscription option ID (auto-generated upon subscription option creation). */
    id?: string | null;
    /** Subscription option title. */
    title?: string | null;
    /** Subscription option description (optional). */
    description?: string | null;
    /** Subscription charge times. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months. */
    subscriptionSettings?: SubscriptionSettings$1;
    /**
     * Discount info (optional).
     * For example, a $20 discount would be `value: 20`, `type: AMOUNT`.
     */
    discount?: Discount$1;
}
interface SubscriptionSettings$1 {
    /** Frequency of recurring payment. */
    frequency?: SubscriptionFrequency$1;
    /** Whether subscription is renewed automatically at the end of each period. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. Ignored if `autoRenewal: true`. */
    billingCycles?: number | null;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency$1 {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Discount$1 {
    /** Discount type. */
    type?: DiscountType$1;
    /** Discount value. */
    value?: number;
}
declare enum DiscountType$1 {
    UNDEFINED = "UNDEFINED",
    /** No discount */
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface CreateSubscriptionOptionRequest$1 {
    /** Subscription option info. */
    subscriptionOption: SubscriptionOption$1;
}
interface CreateSubscriptionOptionResponse$1 {
    /** Newly created subscription option. */
    subscriptionOption?: SubscriptionOption$1;
}
interface UpdateSubscriptionOptionRequest$1 {
    /** Subscription option info. Only the passed parameters will be updated. */
    subscriptionOption: SubscriptionOption$1;
}
interface UpdateSubscriptionOptionResponse$1 {
    /** Updated subscription option. */
    subscriptionOption?: SubscriptionOption$1;
}
interface DeleteSubscriptionOptionRequest$1 {
    /** ID of the subscription option to delete. */
    id: string;
}
interface DeleteSubscriptionOptionResponse$1 {
}
interface BulkCreateSubscriptionOptionsRequest$1 {
    /** Subscription options info. */
    subscriptionOptions: SubscriptionOption$1[];
}
interface BulkCreateSubscriptionOptionsResponse$1 {
    /** Newly created subscription options. */
    subscriptionOptions?: SubscriptionOption$1[];
}
interface BulkUpdateSubscriptionOptionsRequest$1 {
    /** Subscription options info. Only the passed parameters in each subscription option will be updated. */
    subscriptionOptions: SubscriptionOption$1[];
}
interface BulkUpdateSubscriptionOptionsResponse$1 {
    /** Updated subscription options. */
    subscriptionOptions?: SubscriptionOption$1[];
}
interface BulkDeleteSubscriptionOptionsRequest$1 {
    /** IDs of the subscription options to delete. */
    ids: string[];
}
interface BulkDeleteSubscriptionOptionsResponse$1 {
}
interface AssignSubscriptionOptionsToProductRequest$1 {
    /** Product ID. */
    productId: string;
    /** Ordered array of subscription options that will be assigned to the product. Pass an empty array to remove all subscription options from the product. */
    assignedSubscriptionOptions?: SubscriptionOptionInProduct$1[];
}
interface SubscriptionOptionInProduct$1 {
    /** Subscription option ID. */
    id?: string;
    /** Whether the subscription option is hidden for the product (the default is false). */
    hidden?: boolean;
    /**
     * Subscription option title.
     * @readonly
     */
    title?: string | null;
    /**
     * Subscription option description (optional).
     * @readonly
     */
    description?: string | null;
    /**
     * Subscription payment settings. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months.
     * @readonly
     */
    subscriptionSettings?: SubscriptionSettings$1;
    /**
     * Discount info (optional).
     * @readonly
     */
    discount?: Discount$1;
}
interface AssignSubscriptionOptionsToProductResponse$1 {
}
interface AllowOneTimePurchasesRequest$1 {
    /** Product ID. */
    productId: string;
    /** Pass `true` to offer product by subscription and as one-time purchase. Pass `false` to offer product as subscription only. */
    allowed: boolean | null;
}
interface AllowOneTimePurchasesResponse$1 {
}
interface GetSubscriptionOptionRequest$1 {
    /** Subscription option ID. */
    id: string;
}
interface GetSubscriptionOptionResponse$1 {
    /** Subscription option. */
    subscriptionOption?: SubscriptionOption$1;
}
interface GetSubscriptionOptionsForProductRequest$1 {
    /** Product ID. */
    productId: string;
    /** Whether to include hidden subscription options in the results. */
    includeHiddenSubscriptionOptions?: boolean;
}
interface GetSubscriptionOptionsForProductResponse$1 {
    /** Subscription options. */
    subscriptionOptions?: SubscriptionOptionInProduct$1[];
}
interface GetProductIdsForSubscriptionOptionRequest$1 {
    /** Subscription option ID. */
    id: string;
    /** Whether to include hidden products in the returned results. */
    includeHiddenProducts?: boolean;
    /** Optional pagination parameters */
    paging?: Paging$3;
}
interface Paging$3 {
    /** Amount of items to load per page. */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first). */
    offset?: number | null;
}
interface GetProductIdsForSubscriptionOptionResponse$1 {
    /** IDs of products associated with the specified subscription option. */
    productIds?: string[];
    /** Paging metadata. */
    metadata?: PagingMetadata$3;
    /** Number of total results. */
    totalResults?: number;
}
interface PagingMetadata$3 {
    /** Amount of items to load per page. */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first). */
    offset?: number;
}
interface GetOneTimePurchasesStatusRequest$1 {
    /** Product ID. */
    productId: string;
}
interface GetOneTimePurchasesStatusResponse$1 {
    /** Whether the specified product is available for one-time purchase */
    allowed?: boolean;
}
interface SubscriptionSettingsNonNullableFields$1 {
    frequency: SubscriptionFrequency$1;
    autoRenewal: boolean;
}
interface DiscountNonNullableFields$1 {
    type: DiscountType$1;
    value: number;
}
interface SubscriptionOptionNonNullableFields$1 {
    subscriptionSettings?: SubscriptionSettingsNonNullableFields$1;
    discount?: DiscountNonNullableFields$1;
}
interface CreateSubscriptionOptionResponseNonNullableFields$1 {
    subscriptionOption?: SubscriptionOptionNonNullableFields$1;
}
interface UpdateSubscriptionOptionResponseNonNullableFields$1 {
    subscriptionOption?: SubscriptionOptionNonNullableFields$1;
}
interface BulkCreateSubscriptionOptionsResponseNonNullableFields$1 {
    subscriptionOptions: SubscriptionOptionNonNullableFields$1[];
}
interface BulkUpdateSubscriptionOptionsResponseNonNullableFields$1 {
    subscriptionOptions: SubscriptionOptionNonNullableFields$1[];
}
interface GetSubscriptionOptionResponseNonNullableFields$1 {
    subscriptionOption?: SubscriptionOptionNonNullableFields$1;
}
interface SubscriptionOptionInProductNonNullableFields$1 {
    id: string;
    hidden: boolean;
    subscriptionSettings?: SubscriptionSettingsNonNullableFields$1;
    discount?: DiscountNonNullableFields$1;
}
interface GetSubscriptionOptionsForProductResponseNonNullableFields$1 {
    subscriptionOptions: SubscriptionOptionInProductNonNullableFields$1[];
}
interface PagingMetadataNonNullableFields$3 {
    items: number;
    offset: number;
}
interface GetProductIdsForSubscriptionOptionResponseNonNullableFields$1 {
    productIds: string[];
    metadata?: PagingMetadataNonNullableFields$3;
    totalResults: number;
}
interface GetOneTimePurchasesStatusResponseNonNullableFields$1 {
    allowed: boolean;
}

interface SubscriptionOption {
    /** Subscription option ID (auto-generated upon subscription option creation). */
    _id?: string | null;
    /** Subscription option title. */
    title?: string | null;
    /** Subscription option description (optional). */
    description?: string | null;
    /** Subscription charge times. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months. */
    subscriptionSettings?: SubscriptionSettings;
    /**
     * Discount info (optional).
     * For example, a $20 discount would be `value: 20`, `type: AMOUNT`.
     */
    discount?: Discount;
}
interface SubscriptionSettings {
    /** Frequency of recurring payment. */
    frequency?: SubscriptionFrequency;
    /** Whether subscription is renewed automatically at the end of each period. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. Ignored if `autoRenewal: true`. */
    billingCycles?: number | null;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Discount {
    /** Discount type. */
    type?: DiscountType;
    /** Discount value. */
    value?: number;
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** No discount */
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface CreateSubscriptionOptionRequest {
    /** Subscription option info. */
    subscriptionOption: SubscriptionOption;
}
interface CreateSubscriptionOptionResponse {
    /** Newly created subscription option. */
    subscriptionOption?: SubscriptionOption;
}
interface UpdateSubscriptionOptionRequest {
    /** Subscription option info. Only the passed parameters will be updated. */
    subscriptionOption: SubscriptionOption;
}
interface UpdateSubscriptionOptionResponse {
    /** Updated subscription option. */
    subscriptionOption?: SubscriptionOption;
}
interface DeleteSubscriptionOptionRequest {
    /** ID of the subscription option to delete. */
    _id: string;
}
interface DeleteSubscriptionOptionResponse {
}
interface BulkCreateSubscriptionOptionsRequest {
    /** Subscription options info. */
    subscriptionOptions: SubscriptionOption[];
}
interface BulkCreateSubscriptionOptionsResponse {
    /** Newly created subscription options. */
    subscriptionOptions?: SubscriptionOption[];
}
interface BulkUpdateSubscriptionOptionsRequest {
    /** Subscription options info. Only the passed parameters in each subscription option will be updated. */
    subscriptionOptions: SubscriptionOption[];
}
interface BulkUpdateSubscriptionOptionsResponse {
    /** Updated subscription options. */
    subscriptionOptions?: SubscriptionOption[];
}
interface BulkDeleteSubscriptionOptionsRequest {
    /** IDs of the subscription options to delete. */
    ids: string[];
}
interface BulkDeleteSubscriptionOptionsResponse {
}
interface AssignSubscriptionOptionsToProductRequest {
    /** Product ID. */
    productId: string;
    /** Ordered array of subscription options that will be assigned to the product. Pass an empty array to remove all subscription options from the product. */
    assignedSubscriptionOptions?: SubscriptionOptionInProduct[];
}
interface SubscriptionOptionInProduct {
    /** Subscription option ID. */
    _id?: string;
    /** Whether the subscription option is hidden for the product (the default is false). */
    hidden?: boolean;
    /**
     * Subscription option title.
     * @readonly
     */
    title?: string | null;
    /**
     * Subscription option description (optional).
     * @readonly
     */
    description?: string | null;
    /**
     * Subscription payment settings. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months.
     * @readonly
     */
    subscriptionSettings?: SubscriptionSettings;
    /**
     * Discount info (optional).
     * @readonly
     */
    discount?: Discount;
}
interface AssignSubscriptionOptionsToProductResponse {
}
interface AllowOneTimePurchasesRequest {
    /** Product ID. */
    productId: string;
    /** Pass `true` to offer product by subscription and as one-time purchase. Pass `false` to offer product as subscription only. */
    allowed: boolean | null;
}
interface AllowOneTimePurchasesResponse {
}
interface GetSubscriptionOptionRequest {
    /** Subscription option ID. */
    _id: string;
}
interface GetSubscriptionOptionResponse {
    /** Subscription option. */
    subscriptionOption?: SubscriptionOption;
}
interface GetSubscriptionOptionsForProductRequest {
    /** Product ID. */
    productId: string;
    /** Whether to include hidden subscription options in the results. */
    includeHiddenSubscriptionOptions?: boolean;
}
interface GetSubscriptionOptionsForProductResponse {
    /** Subscription options. */
    subscriptionOptions?: SubscriptionOptionInProduct[];
}
interface GetProductIdsForSubscriptionOptionRequest {
    /** Subscription option ID. */
    _id: string;
    /** Whether to include hidden products in the returned results. */
    includeHiddenProducts?: boolean;
    /** Optional pagination parameters */
    paging?: Paging$2;
}
interface Paging$2 {
    /** Amount of items to load per page. */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first). */
    offset?: number | null;
}
interface GetProductIdsForSubscriptionOptionResponse {
    /** IDs of products associated with the specified subscription option. */
    productIds?: string[];
    /** Paging metadata. */
    metadata?: PagingMetadata$2;
    /** Number of total results. */
    totalResults?: number;
}
interface PagingMetadata$2 {
    /** Amount of items to load per page. */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first). */
    offset?: number;
}
interface GetOneTimePurchasesStatusRequest {
    /** Product ID. */
    productId: string;
}
interface GetOneTimePurchasesStatusResponse {
    /** Whether the specified product is available for one-time purchase */
    allowed?: boolean;
}
interface SubscriptionSettingsNonNullableFields {
    frequency: SubscriptionFrequency;
    autoRenewal: boolean;
}
interface DiscountNonNullableFields {
    type: DiscountType;
    value: number;
}
interface SubscriptionOptionNonNullableFields {
    subscriptionSettings?: SubscriptionSettingsNonNullableFields;
    discount?: DiscountNonNullableFields;
}
interface CreateSubscriptionOptionResponseNonNullableFields {
    subscriptionOption?: SubscriptionOptionNonNullableFields;
}
interface UpdateSubscriptionOptionResponseNonNullableFields {
    subscriptionOption?: SubscriptionOptionNonNullableFields;
}
interface BulkCreateSubscriptionOptionsResponseNonNullableFields {
    subscriptionOptions: SubscriptionOptionNonNullableFields[];
}
interface BulkUpdateSubscriptionOptionsResponseNonNullableFields {
    subscriptionOptions: SubscriptionOptionNonNullableFields[];
}
interface GetSubscriptionOptionResponseNonNullableFields {
    subscriptionOption?: SubscriptionOptionNonNullableFields;
}
interface SubscriptionOptionInProductNonNullableFields {
    _id: string;
    hidden: boolean;
    subscriptionSettings?: SubscriptionSettingsNonNullableFields;
    discount?: DiscountNonNullableFields;
}
interface GetSubscriptionOptionsForProductResponseNonNullableFields {
    subscriptionOptions: SubscriptionOptionInProductNonNullableFields[];
}
interface PagingMetadataNonNullableFields$2 {
    items: number;
    offset: number;
}
interface GetProductIdsForSubscriptionOptionResponseNonNullableFields {
    productIds: string[];
    metadata?: PagingMetadataNonNullableFields$2;
    totalResults: number;
}
interface GetOneTimePurchasesStatusResponseNonNullableFields {
    allowed: boolean;
}

type __PublicMethodMetaInfo$1<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function createSubscriptionOption(): __PublicMethodMetaInfo$1<'POST', {}, CreateSubscriptionOptionRequest, CreateSubscriptionOptionRequest$1, CreateSubscriptionOptionResponse & CreateSubscriptionOptionResponseNonNullableFields, CreateSubscriptionOptionResponse$1 & CreateSubscriptionOptionResponseNonNullableFields$1>;
declare function updateSubscriptionOption(): __PublicMethodMetaInfo$1<'PATCH', {
    subscriptionOptionId: string;
}, UpdateSubscriptionOptionRequest, UpdateSubscriptionOptionRequest$1, UpdateSubscriptionOptionResponse & UpdateSubscriptionOptionResponseNonNullableFields, UpdateSubscriptionOptionResponse$1 & UpdateSubscriptionOptionResponseNonNullableFields$1>;
declare function deleteSubscriptionOption(): __PublicMethodMetaInfo$1<'DELETE', {
    id: string;
}, DeleteSubscriptionOptionRequest, DeleteSubscriptionOptionRequest$1, DeleteSubscriptionOptionResponse, DeleteSubscriptionOptionResponse$1>;
declare function bulkCreateSubscriptionOptions(): __PublicMethodMetaInfo$1<'POST', {}, BulkCreateSubscriptionOptionsRequest, BulkCreateSubscriptionOptionsRequest$1, BulkCreateSubscriptionOptionsResponse & BulkCreateSubscriptionOptionsResponseNonNullableFields, BulkCreateSubscriptionOptionsResponse$1 & BulkCreateSubscriptionOptionsResponseNonNullableFields$1>;
declare function bulkUpdateSubscriptionOptions(): __PublicMethodMetaInfo$1<'PATCH', {}, BulkUpdateSubscriptionOptionsRequest, BulkUpdateSubscriptionOptionsRequest$1, BulkUpdateSubscriptionOptionsResponse & BulkUpdateSubscriptionOptionsResponseNonNullableFields, BulkUpdateSubscriptionOptionsResponse$1 & BulkUpdateSubscriptionOptionsResponseNonNullableFields$1>;
declare function bulkDeleteSubscriptionOptions(): __PublicMethodMetaInfo$1<'POST', {}, BulkDeleteSubscriptionOptionsRequest, BulkDeleteSubscriptionOptionsRequest$1, BulkDeleteSubscriptionOptionsResponse, BulkDeleteSubscriptionOptionsResponse$1>;
declare function assignSubscriptionOptionsToProduct(): __PublicMethodMetaInfo$1<'POST', {
    productId: string;
}, AssignSubscriptionOptionsToProductRequest, AssignSubscriptionOptionsToProductRequest$1, AssignSubscriptionOptionsToProductResponse, AssignSubscriptionOptionsToProductResponse$1>;
declare function allowOneTimePurchases(): __PublicMethodMetaInfo$1<'PATCH', {
    productId: string;
}, AllowOneTimePurchasesRequest, AllowOneTimePurchasesRequest$1, AllowOneTimePurchasesResponse, AllowOneTimePurchasesResponse$1>;
declare function getSubscriptionOption(): __PublicMethodMetaInfo$1<'GET', {
    id: string;
}, GetSubscriptionOptionRequest, GetSubscriptionOptionRequest$1, GetSubscriptionOptionResponse & GetSubscriptionOptionResponseNonNullableFields, GetSubscriptionOptionResponse$1 & GetSubscriptionOptionResponseNonNullableFields$1>;
declare function getSubscriptionOptionsForProduct(): __PublicMethodMetaInfo$1<'GET', {
    productId: string;
}, GetSubscriptionOptionsForProductRequest, GetSubscriptionOptionsForProductRequest$1, GetSubscriptionOptionsForProductResponse & GetSubscriptionOptionsForProductResponseNonNullableFields, GetSubscriptionOptionsForProductResponse$1 & GetSubscriptionOptionsForProductResponseNonNullableFields$1>;
declare function getProductIdsForSubscriptionOption(): __PublicMethodMetaInfo$1<'GET', {
    id: string;
}, GetProductIdsForSubscriptionOptionRequest, GetProductIdsForSubscriptionOptionRequest$1, GetProductIdsForSubscriptionOptionResponse & GetProductIdsForSubscriptionOptionResponseNonNullableFields, GetProductIdsForSubscriptionOptionResponse$1 & GetProductIdsForSubscriptionOptionResponseNonNullableFields$1>;
declare function getOneTimePurchasesStatus(): __PublicMethodMetaInfo$1<'GET', {
    productId: string;
}, GetOneTimePurchasesStatusRequest, GetOneTimePurchasesStatusRequest$1, GetOneTimePurchasesStatusResponse & GetOneTimePurchasesStatusResponseNonNullableFields, GetOneTimePurchasesStatusResponse$1 & GetOneTimePurchasesStatusResponseNonNullableFields$1>;

declare const meta$1_allowOneTimePurchases: typeof allowOneTimePurchases;
declare const meta$1_assignSubscriptionOptionsToProduct: typeof assignSubscriptionOptionsToProduct;
declare const meta$1_bulkCreateSubscriptionOptions: typeof bulkCreateSubscriptionOptions;
declare const meta$1_bulkDeleteSubscriptionOptions: typeof bulkDeleteSubscriptionOptions;
declare const meta$1_bulkUpdateSubscriptionOptions: typeof bulkUpdateSubscriptionOptions;
declare const meta$1_createSubscriptionOption: typeof createSubscriptionOption;
declare const meta$1_deleteSubscriptionOption: typeof deleteSubscriptionOption;
declare const meta$1_getOneTimePurchasesStatus: typeof getOneTimePurchasesStatus;
declare const meta$1_getProductIdsForSubscriptionOption: typeof getProductIdsForSubscriptionOption;
declare const meta$1_getSubscriptionOption: typeof getSubscriptionOption;
declare const meta$1_getSubscriptionOptionsForProduct: typeof getSubscriptionOptionsForProduct;
declare const meta$1_updateSubscriptionOption: typeof updateSubscriptionOption;
declare namespace meta$1 {
  export { type __PublicMethodMetaInfo$1 as __PublicMethodMetaInfo, meta$1_allowOneTimePurchases as allowOneTimePurchases, meta$1_assignSubscriptionOptionsToProduct as assignSubscriptionOptionsToProduct, meta$1_bulkCreateSubscriptionOptions as bulkCreateSubscriptionOptions, meta$1_bulkDeleteSubscriptionOptions as bulkDeleteSubscriptionOptions, meta$1_bulkUpdateSubscriptionOptions as bulkUpdateSubscriptionOptions, meta$1_createSubscriptionOption as createSubscriptionOption, meta$1_deleteSubscriptionOption as deleteSubscriptionOption, meta$1_getOneTimePurchasesStatus as getOneTimePurchasesStatus, meta$1_getProductIdsForSubscriptionOption as getProductIdsForSubscriptionOption, meta$1_getSubscriptionOption as getSubscriptionOption, meta$1_getSubscriptionOptionsForProduct as getSubscriptionOptionsForProduct, meta$1_updateSubscriptionOption as updateSubscriptionOption };
}

interface InventoryItemV2$1 {
    /** Inventory item ID. */
    id?: string | null;
    /**
     * Deprecated: use productId.
     * @readonly
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string | null;
    /**
     * Product ID.
     * @readonly
     */
    productId?: string | null;
    /** Whether quantity is being tracked. */
    trackQuantity?: boolean | null;
    /** Variants associated with this inventory item. */
    variants?: InventoryVariantV2$1[];
    /**
     * Last updated timestamp.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Inventory’s unique numeric ID (assigned in ascending order).
     * Primarily for sorting and filtering when crawling all inventories.
     * @readonly
     */
    numericId?: string;
    /** Preorder information. */
    preorderInfo?: PreorderInfo$1;
}
interface InventoryVariantV2$1 {
    /** Variant ID. */
    variantId?: string;
    /** Whether the product is listed as in stock. */
    inStock?: boolean | null;
    /** Quantity currently left in inventory. */
    quantity?: number | null;
    /**
     * Whether the variant is available for preorder. When `true`, the variant is out of stock and preorder is enabled on inventory level.
     * @readonly
     */
    availableForPreorder?: boolean;
}
interface PreorderInfo$1 {
    /** Whether the item is available for preorder. */
    enabled?: boolean;
    /** A message the buyer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /** Number of products that can be preordered after stock reaches zero. */
    limit?: number | null;
}
interface GetInventoryVariantsRequest$1 extends GetInventoryVariantsRequestIdOneOf$1 {
    /** Inventory item ID. */
    inventoryId: string;
    /**
     * Deprecated (use productID instead).
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant IDs to query for this inventory item (optional). */
    variantIds?: string[];
}
/** @oneof */
interface GetInventoryVariantsRequestIdOneOf$1 {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * Deprecated (use productID instead).
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
}
interface GetInventoryVariantsResponse$1 {
    /** Inventory item. */
    inventoryItem?: InventoryItemV2$1;
}
interface QueryInventoryRequest$1 {
    query?: Query$1;
}
interface Query$1 {
    paging?: Paging$1;
    /** Filter string */
    filter?: string | null;
    /** Sort string */
    sort?: string | null;
}
interface Paging$1 {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface QueryInventoryResponse$1 {
    /** Inventory items. */
    inventoryItems?: InventoryItemV2$1[];
    /** Display metadata. */
    metadata?: PagingMetadata$1;
    /** Number of total results. */
    totalResults?: number;
}
interface PagingMetadata$1 {
    /** Amount of items to load per page */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number;
}
interface UpdateInventoryVariantsRequest$1 {
    /** Inventory item. */
    inventoryItem: InventoryItemV2$1;
}
interface UpdateInventoryVariantsResponse$1 {
}
interface DecrementInventoryRequest$1 {
    decrementData?: DecrementData$1[];
}
interface DecrementData$1 extends DecrementDataIdOneOf$1 {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * Deprecated: use productId.
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant ID. */
    variantId?: string;
    /** Number to decrement inventory by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the item's inventory was made as part of a purchase that includes preorder items.
     * If true and the item is available for preorder, we allow negative inventory.
     * If false and the item is not available for preorder, we allow regular buy flow (no negative inventory).
     */
    preorderRequest?: boolean;
}
/** @oneof */
interface DecrementDataIdOneOf$1 {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * Deprecated: use productId.
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
}
interface DecrementInventoryResponse$1 {
}
interface IncrementInventoryRequest$1 {
    incrementData?: IncrementData$1[];
}
interface IncrementData$1 extends IncrementDataIdOneOf$1 {
    /** Inventory item ID. */
    inventoryId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant ID. */
    variantId?: string;
    /** Number to increment inventory by. */
    incrementBy?: number;
}
/** @oneof */
interface IncrementDataIdOneOf$1 {
    /** Inventory item ID. */
    inventoryId?: string;
    /** Product ID. */
    productId?: string;
}
interface IncrementInventoryResponse$1 {
}
interface InventoryVariantV2NonNullableFields$1 {
    variantId: string;
    availableForPreorder: boolean;
}
interface PreorderInfoNonNullableFields$1 {
    enabled: boolean;
}
interface InventoryItemV2NonNullableFields$1 {
    variants: InventoryVariantV2NonNullableFields$1[];
    numericId: string;
    preorderInfo?: PreorderInfoNonNullableFields$1;
}
interface GetInventoryVariantsResponseNonNullableFields$1 {
    inventoryItem?: InventoryItemV2NonNullableFields$1;
}
interface PagingMetadataNonNullableFields$1 {
    items: number;
    offset: number;
}
interface QueryInventoryResponseNonNullableFields$1 {
    inventoryItems: InventoryItemV2NonNullableFields$1[];
    metadata?: PagingMetadataNonNullableFields$1;
    totalResults: number;
}

interface InventoryItemV2 {
    /** Inventory item ID. */
    _id?: string | null;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string | null;
    /**
     * Product ID.
     * @readonly
     */
    productId?: string | null;
    /** Whether quantity is being tracked. */
    trackQuantity?: boolean | null;
    /** Variants associated with this inventory item. */
    variants?: InventoryVariantV2[];
    /**
     * Last updated timestamp.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Inventory’s unique numeric ID (assigned in ascending order).
     * Primarily for sorting and filtering when crawling all inventories.
     * @readonly
     */
    numericId?: string;
    /** Preorder information. */
    preorderInfo?: PreorderInfo;
}
interface InventoryVariantV2 {
    /** Variant ID. */
    variantId?: string;
    /** Whether the product is listed as in stock. */
    inStock?: boolean | null;
    /** Quantity currently left in inventory. */
    quantity?: number | null;
    /**
     * Whether the variant is available for preorder. When `true`, the variant is out of stock and preorder is enabled on inventory level.
     * @readonly
     */
    availableForPreorder?: boolean;
}
interface PreorderInfo {
    /** Whether the item is available for preorder. */
    enabled?: boolean;
    /** A message the buyer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /** Number of products that can be preordered after stock reaches zero. */
    limit?: number | null;
}
interface GetInventoryVariantsRequest extends GetInventoryVariantsRequestIdOneOf {
    /** Inventory item ID. */
    inventoryId: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant IDs to query for this inventory item (optional). */
    variantIds?: string[];
}
/** @oneof */
interface GetInventoryVariantsRequestIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
}
interface GetInventoryVariantsResponse {
    /** Inventory item. */
    inventoryItem?: InventoryItemV2;
}
interface QueryInventoryRequest {
    /** Information about paging, filters, sorting. */
    query?: Query;
}
interface Query {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Filter string */
    filter?: string | null;
    /** Sort string */
    sort?: string | null;
}
interface Paging {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface QueryInventoryResponse {
    /** Inventory items. */
    inventoryItems?: InventoryItemV2[];
    /** Display metadata. */
    metadata?: PagingMetadata;
    /** Number of total results. */
    totalResults?: number;
}
interface PagingMetadata {
    /** Amount of items to load per page */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number;
}
interface UpdateInventoryVariantsRequest {
    /** Inventory item. */
    inventoryItem: InventoryItemV2;
}
interface UpdateInventoryVariantsResponse {
}
interface DecrementInventoryRequest {
    /** Item or product to decrement. */
    decrementData?: DecrementData[];
}
interface DecrementData extends DecrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant ID. */
    variantId?: string;
    /** Number to decrement inventory by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the item's inventory was made as part of a purchase that includes preorder items.
     * If true and the item is available for preorder, we allow negative inventory.
     * If false and the item is not available for preorder, we allow regular buy flow (no negative inventory).
     */
    preorderRequest?: boolean;
}
/** @oneof */
interface DecrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
}
interface DecrementInventoryResponse {
}
interface IncrementInventoryRequest {
    /** Item or product to increment. */
    incrementData?: IncrementData[];
}
interface IncrementData extends IncrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant ID. */
    variantId?: string;
    /** Number to increment inventory by. */
    incrementBy?: number;
}
/** @oneof */
interface IncrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /** Product ID. */
    productId?: string;
}
interface IncrementInventoryResponse {
}
interface InventoryVariantV2NonNullableFields {
    variantId: string;
    availableForPreorder: boolean;
}
interface PreorderInfoNonNullableFields {
    enabled: boolean;
}
interface InventoryItemV2NonNullableFields {
    variants: InventoryVariantV2NonNullableFields[];
    numericId: string;
    preorderInfo?: PreorderInfoNonNullableFields;
}
interface GetInventoryVariantsResponseNonNullableFields {
    inventoryItem?: InventoryItemV2NonNullableFields;
}
interface PagingMetadataNonNullableFields {
    items: number;
    offset: number;
}
interface QueryInventoryResponseNonNullableFields {
    inventoryItems: InventoryItemV2NonNullableFields[];
    metadata?: PagingMetadataNonNullableFields;
    totalResults: number;
}

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function getInventoryVariants(): __PublicMethodMetaInfo<'POST', {
    inventoryId: string;
}, GetInventoryVariantsRequest, GetInventoryVariantsRequest$1, GetInventoryVariantsResponse & GetInventoryVariantsResponseNonNullableFields, GetInventoryVariantsResponse$1 & GetInventoryVariantsResponseNonNullableFields$1>;
declare function queryInventory(): __PublicMethodMetaInfo<'POST', {}, QueryInventoryRequest, QueryInventoryRequest$1, QueryInventoryResponse & QueryInventoryResponseNonNullableFields, QueryInventoryResponse$1 & QueryInventoryResponseNonNullableFields$1>;
declare function updateInventoryVariants(): __PublicMethodMetaInfo<'PATCH', {
    inventoryItemProductId: string;
}, UpdateInventoryVariantsRequest, UpdateInventoryVariantsRequest$1, UpdateInventoryVariantsResponse, UpdateInventoryVariantsResponse$1>;
declare function decrementInventory(): __PublicMethodMetaInfo<'POST', {}, DecrementInventoryRequest, DecrementInventoryRequest$1, DecrementInventoryResponse, DecrementInventoryResponse$1>;
declare function incrementInventory(): __PublicMethodMetaInfo<'POST', {}, IncrementInventoryRequest, IncrementInventoryRequest$1, IncrementInventoryResponse, IncrementInventoryResponse$1>;

type meta___PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = __PublicMethodMetaInfo<K, M, T, S, Q, R>;
declare const meta_decrementInventory: typeof decrementInventory;
declare const meta_getInventoryVariants: typeof getInventoryVariants;
declare const meta_incrementInventory: typeof incrementInventory;
declare const meta_queryInventory: typeof queryInventory;
declare const meta_updateInventoryVariants: typeof updateInventoryVariants;
declare namespace meta {
  export { type meta___PublicMethodMetaInfo as __PublicMethodMetaInfo, meta_decrementInventory as decrementInventory, meta_getInventoryVariants as getInventoryVariants, meta_incrementInventory as incrementInventory, meta_queryInventory as queryInventory, meta_updateInventoryVariants as updateInventoryVariants };
}

export { meta$9 as brandsV3, meta$4 as catalogVersioning, meta$b as collections, meta$8 as customizationsV3, meta$7 as infoSectionsV3, meta as inventory, meta$6 as inventoryItemsV3, meta$a as products, meta$5 as productsV3, meta$3 as ribbonsV3, meta$2 as storesLocationsV3, meta$1 as subscriptionOptions, meta$c as wishlist };
