type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

/** Inventory Item. */
interface InventoryItem extends InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo;
    /**
     * Product.
     * @readonly
     */
    product?: Product;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
/** @oneof */
interface InventoryItemTrackingMethodOneOf {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
}
declare enum AvailabilityStatus {
    UNKNOWN_AVAILABILITY_STATUS = "UNKNOWN_AVAILABILITY_STATUS",
    OUT_OF_STOCK = "OUT_OF_STOCK",
    IN_STOCK = "IN_STOCK",
    /**
     * Whether the variant is available for preorder. InventoryItem will be available only when all below conditions are met:
     * 1. the variant is out of stock
     * 2. preorder is enabled on inventory item level (preorder_setting.enabled is true)
     * 3. preorder limit wasn't reached (preorder_setting.limit)
     */
    PREORDER = "PREORDER"
}
interface PreorderInfo {
    /**
     * Whether preorder is enabled for the product.
     *
     * Default: `false`
     */
    enabled?: boolean | null;
    /** A message the customer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /**
     * Number of products that can be preordered after stock reaches zero.
     * Supported only for inventory items with `trackQuantity = true`.
     *
     * Default: `100000`
     */
    limit?: number | null;
    /**
     * Number of times the product was preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    counter?: number | null;
    /**
     * Quantity of products that can be preordered.
     *
     * Supported only for inventory items with `trackQuantity = true`.
     * @readonly
     */
    quantity?: number | null;
}
interface Product {
    /** Product name. */
    name?: string | null;
    /** List of category IDs that this product is included in directly. */
    directCategoryIds?: string[];
    /** Variant name. */
    variantName?: string | null;
    /** Variant SKU (stock keeping unit). */
    variantSku?: string | null;
}
interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** tell us why you're invalidating the cache. You don't need to add your app name */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
interface App {
    /** The AppDefId */
    appDefId?: string;
    /** The instance Id */
    instanceId?: string;
}
interface Page {
    /** the msid the page is on */
    metaSiteId?: string;
    /** Invalidate by Page ID */
    pageId?: string;
}
interface URI {
    /** the msid the URI is on */
    metaSiteId?: string;
    /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
    uriPath?: string;
}
interface File {
    /** the msid the file is related to */
    metaSiteId?: string;
    /** Invalidate by filename (for media files such as PDFs) */
    fileName?: string;
}
interface BulkInventoryItemAction {
    /** Inventory items. */
    inventoryItems?: InventoryItem[];
}
interface CreateInventoryItemRequest {
    /** Inventory item to create. */
    inventoryItem: InventoryItem;
}
interface CreateInventoryItemResponse {
    /** Created inventory item. */
    inventoryItem?: InventoryItem;
}
interface BulkCreateInventoryItemsRequest {
    /** Inventory items to create. */
    inventoryItems: InventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface BulkCreateInventoryItemsResponse {
    /** Inventory items created by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface V3BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
    /**
     * Full inventory item entity.
     *
     * Returned only if `returnEntity: true` is passed in the request.
     */
    item?: InventoryItem;
}
interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
interface GetInventoryItemRequest {
    /** Inventory item ID. */
    inventoryItemId: string;
}
interface GetInventoryItemResponse {
    /** Inventory item. */
    inventoryItem?: InventoryItem;
}
interface UpdateInventoryItemRequest {
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Reason for update. */
    reason?: ReasonType;
}
/** The reason for the inventory change. */
declare enum ReasonType {
    UNKNOWN = "UNKNOWN",
    ORDER = "ORDER",
    MANUAL = "MANUAL",
    REVERT_INVENTORY_CHANGE = "REVERT_INVENTORY_CHANGE"
}
interface UpdateInventoryItemResponse {
    /** Updated inventory item. */
    inventoryItem?: InventoryItem;
}
/** Report when Inventory item stock status changed from in stock to out of stock and the opposite. */
interface InventoryItemStockStatusUpdatedEvent {
    /** Inventory item new status. */
    inStock?: boolean;
}
interface InventoryItemUpdatedWithReason {
    /** Updated inventory item. */
    currentEntity?: InventoryItem;
    /** Reason for the update. */
    reason?: ReasonType;
    /**
     * ID of the app that updated this inventory item.
     *
     * When Wix Stores updates an inventory item, value will always be: `"215238eb-22a5-4c36-9e7b-e7c08025e04e"`.
     */
    appId?: string;
}
interface BulkUpdateInventoryItemsRequest {
    /** Inventory items to update. */
    inventoryItems: MaskedInventoryItem[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonType;
}
interface MaskedInventoryItem {
    /** Inventory item to update. */
    inventoryItem?: InventoryItem;
}
interface BulkUpdateInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkUpdateInventoryItemsByFilterRequest {
    /** Filter object. */
    filter: Record<string, any> | null;
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
interface SearchDetails {
    /** Defines how separate search terms in `expression` are combined. */
    mode?: Mode;
    /** Search term or expression. */
    expression?: string | null;
    /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path. */
    fields?: string[];
    /** Whether to use auto fuzzy search (allowing typos by a managed proximity algorithm). */
    fuzzy?: boolean;
}
declare enum Mode {
    /** Any of the search terms must be present. */
    OR = "OR",
    /** All search terms must be present. */
    AND = "AND"
}
interface BulkUpdateInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     */
    jobId?: string;
}
interface BulkSetOrAdjustInventoryItemsByFilterRequest {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /** Action to adjust the inventory by. (e.g increment or decrement) */
    adjustedInventoryAction?: AdjustInventoryAction;
    /** Free text to match in searchable fields */
    search?: SearchDetails;
}
interface AdjustInventoryAction extends AdjustInventoryActionActionOneOf {
    /** Amount to increment by. */
    incrementBy?: number;
    /** Amount to decrement by. */
    decrementBy?: number;
}
/** @oneof */
interface AdjustInventoryActionActionOneOf {
    /** Amount to increment by. */
    incrementBy?: number;
    /** Amount to decrement by. */
    decrementBy?: number;
}
interface BulkSetOrAdjustInventoryItemsByFilterResponse {
    /**
     * Job ID.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     */
    jobId?: string;
}
interface DeleteInventoryItemRequest {
    /** Inventory item ID. */
    inventoryItemId: string;
}
interface DeleteInventoryItemResponse {
}
interface BulkDeleteInventoryItemsRequest {
    /** IDs of inventory items to delete. */
    inventoryItemIds: string[];
}
interface BulkDeleteInventoryItemsResponse {
    /** Inventory items deleted by bulk action. */
    results?: BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkInventoryItemResult {
    /** Bulk action metadata for inventory item. */
    itemMetadata?: ItemMetadata;
}
interface QueryInventoryItemsRequest {
    /** Query options. */
    query?: InventoryQuery;
}
interface InventoryQuery extends InventoryQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: InventoryPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: InventoryCursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface InventoryQueryPagingMethodOneOf {
    /** Pointer to page of results using offset. Cannot be used together with `cursorPaging`. */
    paging?: InventoryPaging;
    /** Cursor pointing to page of results. Cannot be used together with `paging`. `cursorPaging.cursor` can not be used together with `filter` or `sort`. */
    cursorPaging?: InventoryCursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface InventoryPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface InventoryCursorPaging {
    /**
     * Number of items to load.
     * Cursor token returned in the query response. To be used on the next query request, but not the first query request.
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryInventoryItemsResponse {
    /** List of inventory items. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. */
    pagingMetadata?: PlatformPagingMetadataV2;
}
interface PlatformPagingMetadataV2 {
    /** The number of items returned in this response. */
    count?: number | null;
    /** Cursors to navigate through result pages. Returned if cursor paging was used. */
    cursors?: Cursors;
}
interface Cursors {
    /** Cursor string pointing to the next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to the previous page in the list of results. */
    prev?: string | null;
}
interface SearchInventoryItemsRequest {
    /** Search options. */
    search?: CursorSearch;
}
interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * List of sort objects.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     */
    sort?: Sorting[];
    /** Aggregations are a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome.
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. For example, `"2023-12-20T10:52:34.795Z"`.
     */
    timeZone?: string | null;
}
/** @oneof */
interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor paging options.
     *
     * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
     */
    cursorPaging?: CursorPaging;
}
interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation. */
    nested?: NestedAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: AggregationType;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
    /**
     * Deprecated. Use `nested` instead.
     * @deprecated Deprecated. Use `nested` instead.
     * @replacedBy kind.nested
     * @targetRemovalDate 2024-03-30
     */
    groupBy?: GroupByAggregation;
}
/** @oneof */
interface AggregationKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation. */
    nested?: NestedAggregation;
}
interface RangeBucket {
    /** Inclusive lower bound of the range. Required if `to` is not provided. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if `from` is not provided. */
    to?: number | null;
}
declare enum SortType {
    /** Sort by number of matches. */
    COUNT = "COUNT",
    /** Sort by value of the field alphabetically. */
    VALUE = "VALUE"
}
declare enum SortDirection {
    /** Sort in descending order. */
    DESC = "DESC",
    /** Sort in ascending order. */
    ASC = "ASC"
}
declare enum MissingValues {
    /** Exclude missing values from the aggregation results. */
    EXCLUDE = "EXCLUDE",
    /** Include missing values in the aggregation results. */
    INCLUDE = "INCLUDE"
}
interface IncludeMissingValuesOptions {
    /** Specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
    addToBucket?: string;
}
declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    /** Count of distinct values. */
    COUNT_DISTINCT = "COUNT_DISTINCT",
    /** Minimum value. */
    MIN = "MIN",
    /** Maximum value. */
    MAX = "MAX",
    /** Sum of values. */
    SUM = "SUM",
    /** Average of values. */
    AVG = "AVG"
}
interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions;
    /** Whether to sort by number of matches or value of the field. */
    sortType?: SortType;
    /** Whether to sort in ascending or descending order. */
    sortDirection?: SortDirection;
    /** How many aggregations to return. Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** Whether to include or exclude missing values from the aggregation results. Default: `EXCLUDE`. */
    missingValues?: MissingValues;
}
/** @oneof */
interface ValueAggregationOptionsOneOf {
    /** Options for including missing values. */
    includeOptions?: IncludeMissingValuesOptions;
}
declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.). */
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
interface RangeAggregation {
    /** List of range buckets, where during aggregation each entity will be placed in the first bucket its value falls into, based on the provided range bounds. */
    buckets?: RangeBucket[];
}
interface ScalarAggregation {
    /** Define the operator for the scalar aggregation. */
    type?: ScalarType;
}
interface DateHistogramAggregation {
    /** Interval for date histogram aggregation. */
    interval?: Interval;
}
declare enum Interval {
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval */
    YEAR = "YEAR",
    /** Monthly interval */
    MONTH = "MONTH",
    /** Weekly interval */
    WEEK = "WEEK",
    /** Daily interval */
    DAY = "DAY",
    /** Hourly interval */
    HOUR = "HOUR",
    /** Minute interval */
    MINUTE = "MINUTE",
    /** Second interval */
    SECOND = "SECOND"
}
interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below. */
    type?: NestedAggregationType;
    /** Field to aggregate by, use dot notation to specify json path. */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationItemKindOneOf {
    /** Value aggregation. */
    value?: ValueAggregation;
    /** Range aggregation. */
    range?: RangeAggregation;
    /** Scalar aggregation. */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation. */
    dateHistogram?: DateHistogramAggregation;
}
declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    /** An aggregation where result buckets are dynamically built - one per unique value. */
    VALUE = "VALUE",
    /** An aggregation, where user can define set of ranges - each representing a bucket. */
    RANGE = "RANGE",
    /** A single-value metric aggregation. For example, min, max, sum, avg. */
    SCALAR = "SCALAR",
    /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    /** Multi-level aggregation, where each next aggregation is nested within previous one. */
    NESTED = "NESTED"
}
/** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one. */
interface NestedAggregation {
    /** Flattened list of aggregations, where each next aggregation is nested within previous one. */
    nestedAggregations?: NestedAggregationItem[];
}
interface GroupByAggregation extends GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
    /** User-defined name of aggregation, should be unique, will appear in aggregation results. */
    name?: string | null;
    /** Field to aggregate by. */
    fieldPath?: string;
}
/** @oneof */
interface GroupByAggregationKindOneOf {
    /** Value aggregation configuration. */
    value?: ValueAggregation;
}
interface CursorPaging {
    /** Maximum number of items to return in the results. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface SearchInventoryItemsResponse {
    /** List of inventory items. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
    /** Aggregation data. */
    aggregationData?: AggregationData;
}
interface CursorPagingMetadata {
    /** Number of items returned in current page. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface AggregationData {
    /** key = aggregation name (as derived from search request). */
    results?: AggregationResults[];
}
interface ValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number;
}
interface RangeAggregationResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number;
}
interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** User-defined name of aggregation, matches the one provided in request. */
    name?: string;
    /** Type of aggregation that matches result. */
    type?: AggregationType;
    /** Field to aggregate by, matches the one provided in request. */
    fieldPath?: string;
}
/** @oneof */
interface NestedAggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
}
interface ValueResults {
    /** List of value aggregations. */
    results?: ValueAggregationResult[];
}
interface RangeResults {
    /** List of ranges returned in same order as requested. */
    results?: RangeAggregationResult[];
}
interface AggregationResultsScalarResult {
    /** Type of scalar aggregation. */
    type?: ScalarType;
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedValueAggregationResult {
    /** Value of the field. */
    value?: string;
    /** Nested aggregations. */
    nestedResults?: NestedAggregationResults;
}
interface ValueResult {
    /** Value of the field. */
    value?: string;
    /** Count of entities with this value. */
    count?: number | null;
}
interface RangeResult {
    /** Inclusive lower bound of the range. */
    from?: number | null;
    /** Exclusive upper bound of the range. */
    to?: number | null;
    /** Count of entities in this range. */
    count?: number | null;
}
interface ScalarResult {
    /** Value of the scalar aggregation. */
    value?: number;
}
interface NestedResultValue extends NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
/** @oneof */
interface NestedResultValueResultOneOf {
    /** Value aggregation result. */
    value?: ValueResult;
    /** Range aggregation result. */
    range?: RangeResult;
    /** Scalar aggregation result. */
    scalar?: ScalarResult;
    /** Date histogram aggregation result. */
    dateHistogram?: ValueResult;
}
interface Results {
    /** List of nested aggregations. */
    results?: Record<string, NestedResultValue>;
}
interface DateHistogramResult {
    /** Date in ISO 8601 format. */
    value?: string;
    /** Count of documents in the bucket. */
    count?: number;
}
interface GroupByValueResults {
    /** List of value aggregations. */
    results?: NestedValueAggregationResult[];
}
interface DateHistogramResults {
    /** List of date histogram aggregations. */
    results?: DateHistogramResult[];
}
/**
 * Results of `NESTED` aggregation type in a flattened form.
 * Aggregations in resulting array are keyed by requested aggregation `name`.
 */
interface NestedResults {
    /** List of nested aggregations. */
    results?: Results[];
}
interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
    /** User-defined name of aggregation as derived from search request. */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request. */
    type?: AggregationType;
    /** Field to aggregate by as derived from search request. */
    fieldPath?: string;
}
/** @oneof */
interface AggregationResultsResultOneOf {
    /** Value aggregation results. */
    values?: ValueResults;
    /** Range aggregation results. */
    ranges?: RangeResults;
    /** Scalar aggregation results. */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results. */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results. */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results. */
    nested?: NestedResults;
}
interface SearchInventoryItemsWithOffsetRequest {
    /** WQL expression. */
    search?: PlatformOffsetSearch;
}
interface PlatformOffsetSearch extends PlatformOffsetSearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can not be used together with 'cursor_paging' */
    paging?: PlatformPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
    sort?: Sorting[];
    /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
    aggregations?: Aggregation[];
    /** free text to match in searchable fields */
    search?: SearchDetails;
}
/** @oneof */
interface PlatformOffsetSearchPagingMethodOneOf {
    /** Pointer to page of results using offset. Can not be used together with 'cursor_paging' */
    paging?: PlatformPaging;
}
interface PlatformPaging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
interface SearchInventoryItemsWithOffsetResponse {
    /** InventoryItems which satisfy the provided query. */
    inventoryItems?: InventoryItem[];
    /** Paging metadata. Contains cursor which can be used in next query. */
    pagingMetadata?: PagingMetadata;
}
interface PagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
}
interface BulkDecrementInventoryItemsRequest {
    /** Inventory item IDs and decrement data. */
    decrementData: DecrementDataById[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
interface DecrementDataById {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkIncrementInventoryItemsRequest {
    /** Inventory item IDs and increment data. */
    incrementData: IncrementDataById[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
interface IncrementDataById {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /** Amount to increment by. */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkDecrementInventoryItemsByVariantAndLocationRequest {
    /** Variant and location IDs, as well as decrement data. */
    decrementData: DecrementDataByVariantAndLocation[];
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
interface DecrementDataByVariantAndLocation {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to decrement by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the inventory item's quantity was made as part of a purchase that includes preorder items.
     *
     * + If `true` and the item is available for preorder in the default location, negative inventory quantity is allowed.
     * + If `false` and the item is not available for preorder, negative inventory is not allowed.
     */
    preorderRequest?: boolean;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkIncrementInventoryItemsByVariantAndLocationRequest {
    /** Variant and location IDs, as well as increment data. */
    incrementData: IncrementDataByVariantAndLocation[];
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
interface IncrementDataByVariantAndLocation {
    /** Variant ID. */
    variantId?: string;
    /** Location ID. */
    locationId?: string | null;
    /** Amount to increment by. */
    incrementBy?: number;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponse {
    /** Inventory items updated by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata details as: totalSuccess and totalFailure. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface BulkSetInventoryItemsForProductsInLocationRequest {
    /** Location ID to set inventory items to. */
    locationId?: string | null;
    /**
     * List of inventory items per product. All existing inventory items for given product in given location_id will be replaced by ones provided in this request.
     * >**Note:** you can provide up to 1000 inventory items in total. For example you can provide 100 products with 10 inventory items in each or 1 product with 1000 inventory items or something in between.
     */
    productInventoryItems?: ProductInventoryItems[];
    /**
     * Whether to return the full inventory item entity in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface ProductInventoryItems {
    /** The ID of the product to set inventory items to. */
    productId?: string;
    /** List of inventory items to be created (if no ID provided) or updated (if existing ID provided). */
    inventoryItems?: InventoryItem[];
}
interface BulkSetInventoryItemsForProductsInLocationResponse {
    /** Created inventory items by bulk action. */
    results?: V3BulkInventoryItemResult[];
    /** Bulk action metadata. */
    bulkActionMetadata?: BulkActionMetadata;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface ProductNonNullableFields {
    directCategoryIds: string[];
}
interface InventoryItemNonNullableFields {
    inStock: boolean;
    quantity: number;
    variantId: string;
    productId: string;
    trackQuantity: boolean;
    availabilityStatus: AvailabilityStatus;
    product?: ProductNonNullableFields;
}
interface CreateInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface V3BulkInventoryItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: InventoryItemNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
interface BulkCreateInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface GetInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields;
}
interface UpdateInventoryItemResponseNonNullableFields {
    inventoryItem?: InventoryItemNonNullableFields;
}
interface BulkUpdateInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkUpdateInventoryItemsByFilterResponseNonNullableFields {
    jobId: string;
}
interface BulkInventoryItemResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
}
interface BulkDeleteInventoryItemsResponseNonNullableFields {
    results: BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface QueryInventoryItemsResponseNonNullableFields {
    inventoryItems: InventoryItemNonNullableFields[];
}
interface ValueAggregationResultNonNullableFields {
    value: string;
    count: number;
}
interface ValueResultsNonNullableFields {
    results: ValueAggregationResultNonNullableFields[];
}
interface RangeAggregationResultNonNullableFields {
    count: number;
}
interface RangeResultsNonNullableFields {
    results: RangeAggregationResultNonNullableFields[];
}
interface AggregationResultsScalarResultNonNullableFields {
    type: ScalarType;
    value: number;
}
interface NestedAggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface NestedValueAggregationResultNonNullableFields {
    value: string;
    nestedResults?: NestedAggregationResultsNonNullableFields;
}
interface GroupByValueResultsNonNullableFields {
    results: NestedValueAggregationResultNonNullableFields[];
}
interface DateHistogramResultNonNullableFields {
    value: string;
    count: number;
}
interface DateHistogramResultsNonNullableFields {
    results: DateHistogramResultNonNullableFields[];
}
interface AggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    groupedByValue?: GroupByValueResultsNonNullableFields;
    dateHistogram?: DateHistogramResultsNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface AggregationDataNonNullableFields {
    results: AggregationResultsNonNullableFields[];
}
interface SearchInventoryItemsResponseNonNullableFields {
    inventoryItems: InventoryItemNonNullableFields[];
    aggregationData?: AggregationDataNonNullableFields;
}
interface BulkDecrementInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkIncrementInventoryItemsResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields {
    results: V3BulkInventoryItemResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface InventoryItemCreatedEnvelope {
    entity: InventoryItem;
    metadata: EventMetadata;
}
interface InventoryItemUpdatedEnvelope {
    entity: InventoryItem;
    metadata: EventMetadata;
}
interface InventoryItemStockStatusUpdatedEnvelope {
    data: InventoryItemStockStatusUpdatedEvent;
    metadata: EventMetadata;
}
interface InventoryItemUpdatedWithReasonEnvelope {
    data: InventoryItemUpdatedWithReason;
    metadata: EventMetadata;
}
interface InventoryItemDeletedEnvelope {
    entity: InventoryItem;
    metadata: EventMetadata;
}
interface BulkCreateInventoryItemsOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
}
interface UpdateInventoryItem {
    /**
     * Tracking method - in stock.
     *
     * When set to `true`, the item is available for sale without a quantity limit.
     */
    inStock?: boolean;
    /**
     * Tracking method - quantity left in inventory.
     *
     * Quantity can be negative when decrementing inventory for an order that has already been paid.
     */
    quantity?: number;
    /**
     * Inventory item ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the inventory item is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the inventory item.
     *
     * Ignored when creating an inventory item.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the inventory item was created.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Variant ID. */
    variantId?: string;
    /** Stores location ID. */
    locationId?: string | null;
    /** Product ID. */
    productId?: string;
    /**
     * Whether the quantity is being tracked.
     * @readonly
     */
    trackQuantity?: boolean;
    /**
     * Inventory item availability status.
     *
     * Supported values:
     * + OUT_OF_STOCK: Product is out of stock.
     * + IN_STOCK: Product is in stock. See `quantity` field for exact amount in stock.
     * + PREORDER: Product is only available for preorder. See `preorderInfo` field for more info.
     * @readonly
     */
    availabilityStatus?: AvailabilityStatus;
    /** Item preorder info. */
    preorderInfo?: PreorderInfo;
    /**
     * Product.
     * @readonly
     */
    product?: Product;
    /**
     * Custom field data for the inventory item object.
     *
     * [Extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields) must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
}
interface UpdateInventoryItemOptions {
    /** Reason for update. */
    reason?: ReasonType;
}
interface BulkUpdateInventoryItemsOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for update. */
    reason?: ReasonType;
}
interface BulkUpdateInventoryItemsByFilterOptions {
    /** Inventory item to update. */
    inventoryItem: InventoryItem;
    /** Free text to match in searchable fields. */
    search?: SearchDetails;
}
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface InventoryItemsQueryResult extends QueryCursorResult {
    items: InventoryItem[];
    query: InventoryItemsQueryBuilder;
    next: () => Promise<InventoryItemsQueryResult>;
    prev: () => Promise<InventoryItemsQueryResult>;
}
interface InventoryItemsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'preorderInfo.enabled', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'preorderInfo.enabled', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: 'quantity' | '_createdDate' | '_updatedDate', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: 'quantity' | '_createdDate' | '_updatedDate', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: 'quantity' | '_createdDate' | '_updatedDate', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: 'quantity' | '_createdDate' | '_updatedDate', value: any) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'variantId' | 'locationId' | 'productId', value: string) => InventoryItemsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'preorderInfo.enabled', value: any[]) => InventoryItemsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'preorderInfo.enabled', value: any) => InventoryItemsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: 'inStock' | 'quantity' | '_id' | '_createdDate' | '_updatedDate' | 'variantId' | 'locationId' | 'productId' | 'preorderInfo.enabled', value: boolean) => InventoryItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'inStock' | 'quantity' | '_createdDate' | '_updatedDate' | 'preorderInfo.enabled'>) => InventoryItemsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'inStock' | 'quantity' | '_createdDate' | '_updatedDate' | 'preorderInfo.enabled'>) => InventoryItemsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => InventoryItemsQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => InventoryItemsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<InventoryItemsQueryResult>;
}
interface SearchInventoryItemsOptions {
    /** Search options. */
    search?: CursorSearch;
}
interface BulkDecrementInventoryItemsOptions {
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
interface BulkIncrementInventoryItemsOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}
interface BulkDecrementInventoryItemsByVariantAndLocationOptions {
    /**
     * Whether to allow negative inventory following this decrement action.
     *
     * Default: `false` (negative inventory is not allowed)
     */
    restrictInventory?: boolean | null;
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for decrement inventory action. */
    reason?: ReasonType;
}
interface BulkIncrementInventoryItemsByVariantAndLocationOptions {
    /**
     * Whether to return the full inventory item entities in the response.
     *
     * Default: `false`
     */
    returnEntity?: boolean;
    /** Reason for increment inventory action. */
    reason?: ReasonType;
}

declare function createInventoryItem$1(httpClient: HttpClient): CreateInventoryItemSignature;
interface CreateInventoryItemSignature {
    /**
     * Creates an inventory item.
     * The combination of `variantId` and `locationId` is unique.
     * @param - Inventory item to create.
     * @returns Created inventory item.
     */
    (inventoryItem: InventoryItem): Promise<InventoryItem & InventoryItemNonNullableFields>;
}
declare function bulkCreateInventoryItems$1(httpClient: HttpClient): BulkCreateInventoryItemsSignature;
interface BulkCreateInventoryItemsSignature {
    /**
     * Creates multiple inventory items.
     * @param - Inventory items to create.
     */
    (inventoryItems: InventoryItem[], options?: BulkCreateInventoryItemsOptions | undefined): Promise<BulkCreateInventoryItemsResponse & BulkCreateInventoryItemsResponseNonNullableFields>;
}
declare function getInventoryItem$1(httpClient: HttpClient): GetInventoryItemSignature;
interface GetInventoryItemSignature {
    /**
     * Retrieves an inventory item.
     * @param - Inventory item ID.
     * @returns Inventory item.
     */
    (inventoryItemId: string): Promise<InventoryItem & InventoryItemNonNullableFields>;
}
declare function updateInventoryItem$1(httpClient: HttpClient): UpdateInventoryItemSignature;
interface UpdateInventoryItemSignature {
    /**
     * Updates an inventory item.
     *
     *
     * Each time the inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating the inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory item ID.
     * @returns Updated inventory item.
     */
    (_id: string | null, inventoryItem: UpdateInventoryItem, options?: UpdateInventoryItemOptions | undefined): Promise<InventoryItem & InventoryItemNonNullableFields>;
}
declare function bulkUpdateInventoryItems$1(httpClient: HttpClient): BulkUpdateInventoryItemsSignature;
interface BulkUpdateInventoryItemsSignature {
    /**
     * Updates multiple inventory items.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Inventory items to update.
     */
    (inventoryItems: MaskedInventoryItem[], options?: BulkUpdateInventoryItemsOptions | undefined): Promise<BulkUpdateInventoryItemsResponse & BulkUpdateInventoryItemsResponseNonNullableFields>;
}
declare function bulkUpdateInventoryItemsByFilter$1(httpClient: HttpClient): BulkUpdateInventoryItemsByFilterSignature;
interface BulkUpdateInventoryItemsByFilterSignature {
    /**
     * Updates multiple inventory items, given the provided filter.
     *
     * Each time an inventory item is updated, `revision` increments by 1.
     * The current `revision` must be passed when updating an inventory item.
     * This ensures you're working with the latest inventory item and prevents unintended overwrites.
     * @param - Filter object.
     */
    (filter: Record<string, any> | null, options?: BulkUpdateInventoryItemsByFilterOptions | undefined): Promise<BulkUpdateInventoryItemsByFilterResponse & BulkUpdateInventoryItemsByFilterResponseNonNullableFields>;
}
declare function deleteInventoryItem$1(httpClient: HttpClient): DeleteInventoryItemSignature;
interface DeleteInventoryItemSignature {
    /**
     * Deletes an inventory item.
     * @param - Inventory item ID.
     */
    (inventoryItemId: string): Promise<void>;
}
declare function bulkDeleteInventoryItems$1(httpClient: HttpClient): BulkDeleteInventoryItemsSignature;
interface BulkDeleteInventoryItemsSignature {
    /**
     * Deletes multiple inventory items.
     * @param - IDs of inventory items to delete.
     */
    (inventoryItemIds: string[]): Promise<BulkDeleteInventoryItemsResponse & BulkDeleteInventoryItemsResponseNonNullableFields>;
}
declare function queryInventoryItems$1(httpClient: HttpClient): QueryInventoryItemsSignature;
interface QueryInventoryItemsSignature {
    /**
     * Retrieves a list of up to 1,000 inventory items, given the provided filtering, sorting, and cursor paging.
     *
     * For field support for filters and sorting,
     * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Query_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    (): InventoryItemsQueryBuilder;
}
declare function searchInventoryItems$1(httpClient: HttpClient): SearchInventoryItemsSignature;
interface SearchInventoryItemsSignature {
    /**
     * Retrieves a list of inventory items, given the provided filtering, sorting, and cursor paging.
     *
     *
     * Search Inventory Items runs with these defaults, which you can override:
     *
     * - `createdDate` is sorted in `DESC` order
     * - `cursorPaging.limit` is `100`
     *
     * For field support for filters and sorting,
     * see [Inventory Items: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/inventory-items-v3/supported-filters-and-sorting).
     *
     * To learn about working with _Search_ endpoints, see
     * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
     * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    (options?: SearchInventoryItemsOptions | undefined): Promise<SearchInventoryItemsResponse & SearchInventoryItemsResponseNonNullableFields>;
}
declare function bulkDecrementInventoryItems$1(httpClient: HttpClient): BulkDecrementInventoryItemsSignature;
interface BulkDecrementInventoryItemsSignature {
    /**
     * Decrements quantities of multiple inventory items.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Inventory item IDs and decrement data.
     */
    (decrementData: DecrementDataById[], options?: BulkDecrementInventoryItemsOptions | undefined): Promise<BulkDecrementInventoryItemsResponse & BulkDecrementInventoryItemsResponseNonNullableFields>;
}
declare function bulkIncrementInventoryItems$1(httpClient: HttpClient): BulkIncrementInventoryItemsSignature;
interface BulkIncrementInventoryItemsSignature {
    /**
     * Increments quantities of multiple inventory items.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Inventory item IDs and increment data.
     */
    (incrementData: IncrementDataById[], options?: BulkIncrementInventoryItemsOptions | undefined): Promise<BulkIncrementInventoryItemsResponse & BulkIncrementInventoryItemsResponseNonNullableFields>;
}
declare function bulkDecrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkDecrementInventoryItemsByVariantAndLocationSignature;
interface BulkDecrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Decrements quantities of multiple inventory items by variant and location.
     *
     * > **Notes:**:
     * > + `trackQuantity` must be `true` to allow for decrementing the quantity.
     * > + If you pass `restrictInventory: true` and the `decrementData.decrementBy` amount is greater than the current quantity in stock, the request will fail with an `INSUFFICIENT_INVENTORY` error.
     * > + Pass `restrictInventory: false` to allow for negative quantities.
     * > + If you pass `preorderRequest: true` and the item is available for preorder, the item's `preorderCounter` will increase and the item's quantity will stay the same.
     * @param - Variant and location IDs, as well as decrement data.
     */
    (decrementData: DecrementDataByVariantAndLocation[], options?: BulkDecrementInventoryItemsByVariantAndLocationOptions | undefined): Promise<BulkDecrementInventoryItemsByVariantAndLocationResponse & BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields>;
}
declare function bulkIncrementInventoryItemsByVariantAndLocation$1(httpClient: HttpClient): BulkIncrementInventoryItemsByVariantAndLocationSignature;
interface BulkIncrementInventoryItemsByVariantAndLocationSignature {
    /**
     * Increments quantities of multiple inventory items by variant and location.
     *
     * > **Note:** `trackQuantity` must be `true` to allow for incrementing the quantity.
     * @param - Variant and location IDs, as well as increment data.
     */
    (incrementData: IncrementDataByVariantAndLocation[], options?: BulkIncrementInventoryItemsByVariantAndLocationOptions | undefined): Promise<BulkIncrementInventoryItemsByVariantAndLocationResponse & BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields>;
}
declare const onInventoryItemCreated$1: EventDefinition<InventoryItemCreatedEnvelope, "wix.stores.catalog.v3.inventory_item_created">;
declare const onInventoryItemUpdated$1: EventDefinition<InventoryItemUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_updated">;
declare const onInventoryItemStockStatusUpdated$1: EventDefinition<InventoryItemStockStatusUpdatedEnvelope, "wix.stores.catalog.v3.inventory_item_stock_status_updated">;
declare const onInventoryItemUpdatedWithReason$1: EventDefinition<InventoryItemUpdatedWithReasonEnvelope, "wix.stores.catalog.v3.inventory_item_updated_with_reason">;
declare const onInventoryItemDeleted$1: EventDefinition<InventoryItemDeletedEnvelope, "wix.stores.catalog.v3.inventory_item_deleted">;

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const createInventoryItem: MaybeContext<BuildRESTFunction<typeof createInventoryItem$1> & typeof createInventoryItem$1>;
declare const bulkCreateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkCreateInventoryItems$1> & typeof bulkCreateInventoryItems$1>;
declare const getInventoryItem: MaybeContext<BuildRESTFunction<typeof getInventoryItem$1> & typeof getInventoryItem$1>;
declare const updateInventoryItem: MaybeContext<BuildRESTFunction<typeof updateInventoryItem$1> & typeof updateInventoryItem$1>;
declare const bulkUpdateInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItems$1> & typeof bulkUpdateInventoryItems$1>;
declare const bulkUpdateInventoryItemsByFilter: MaybeContext<BuildRESTFunction<typeof bulkUpdateInventoryItemsByFilter$1> & typeof bulkUpdateInventoryItemsByFilter$1>;
declare const deleteInventoryItem: MaybeContext<BuildRESTFunction<typeof deleteInventoryItem$1> & typeof deleteInventoryItem$1>;
declare const bulkDeleteInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDeleteInventoryItems$1> & typeof bulkDeleteInventoryItems$1>;
declare const queryInventoryItems: MaybeContext<BuildRESTFunction<typeof queryInventoryItems$1> & typeof queryInventoryItems$1>;
declare const searchInventoryItems: MaybeContext<BuildRESTFunction<typeof searchInventoryItems$1> & typeof searchInventoryItems$1>;
declare const bulkDecrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItems$1> & typeof bulkDecrementInventoryItems$1>;
declare const bulkIncrementInventoryItems: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItems$1> & typeof bulkIncrementInventoryItems$1>;
declare const bulkDecrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkDecrementInventoryItemsByVariantAndLocation$1> & typeof bulkDecrementInventoryItemsByVariantAndLocation$1>;
declare const bulkIncrementInventoryItemsByVariantAndLocation: MaybeContext<BuildRESTFunction<typeof bulkIncrementInventoryItemsByVariantAndLocation$1> & typeof bulkIncrementInventoryItemsByVariantAndLocation$1>;

type _publicOnInventoryItemCreatedType = typeof onInventoryItemCreated$1;
/**
 * Triggered when an inventory item is created.
 */
declare const onInventoryItemCreated: ReturnType<typeof createEventModule<_publicOnInventoryItemCreatedType>>;

type _publicOnInventoryItemUpdatedType = typeof onInventoryItemUpdated$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdated: ReturnType<typeof createEventModule<_publicOnInventoryItemUpdatedType>>;

type _publicOnInventoryItemStockStatusUpdatedType = typeof onInventoryItemStockStatusUpdated$1;
/**
 * Triggered when an inventory item's stock is updated.
 */
declare const onInventoryItemStockStatusUpdated: ReturnType<typeof createEventModule<_publicOnInventoryItemStockStatusUpdatedType>>;

type _publicOnInventoryItemUpdatedWithReasonType = typeof onInventoryItemUpdatedWithReason$1;
/**
 * Triggered when an inventory item is updated.
 */
declare const onInventoryItemUpdatedWithReason: ReturnType<typeof createEventModule<_publicOnInventoryItemUpdatedWithReasonType>>;

type _publicOnInventoryItemDeletedType = typeof onInventoryItemDeleted$1;
/**
 * Triggered when an inventory item is deleted.
 */
declare const onInventoryItemDeleted: ReturnType<typeof createEventModule<_publicOnInventoryItemDeletedType>>;

export { type ActionEvent, type AdjustInventoryAction, type AdjustInventoryActionActionOneOf, type Aggregation, type AggregationData, type AggregationKindOneOf, type AggregationResults, type AggregationResultsResultOneOf, type AggregationResultsScalarResult, AggregationType, type App, type ApplicationError, AvailabilityStatus, type BaseEventMetadata, type BulkActionMetadata, type BulkCreateInventoryItemsOptions, type BulkCreateInventoryItemsRequest, type BulkCreateInventoryItemsResponse, type BulkCreateInventoryItemsResponseNonNullableFields, type BulkDecrementInventoryItemsByVariantAndLocationOptions, type BulkDecrementInventoryItemsByVariantAndLocationRequest, type BulkDecrementInventoryItemsByVariantAndLocationResponse, type BulkDecrementInventoryItemsByVariantAndLocationResponseNonNullableFields, type BulkDecrementInventoryItemsOptions, type BulkDecrementInventoryItemsRequest, type BulkDecrementInventoryItemsResponse, type BulkDecrementInventoryItemsResponseNonNullableFields, type BulkDeleteInventoryItemsRequest, type BulkDeleteInventoryItemsResponse, type BulkDeleteInventoryItemsResponseNonNullableFields, type BulkIncrementInventoryItemsByVariantAndLocationOptions, type BulkIncrementInventoryItemsByVariantAndLocationRequest, type BulkIncrementInventoryItemsByVariantAndLocationResponse, type BulkIncrementInventoryItemsByVariantAndLocationResponseNonNullableFields, type BulkIncrementInventoryItemsOptions, type BulkIncrementInventoryItemsRequest, type BulkIncrementInventoryItemsResponse, type BulkIncrementInventoryItemsResponseNonNullableFields, type BulkInventoryItemAction, type BulkInventoryItemResult, type BulkSetInventoryItemsForProductsInLocationRequest, type BulkSetInventoryItemsForProductsInLocationResponse, type BulkSetOrAdjustInventoryItemsByFilterRequest, type BulkSetOrAdjustInventoryItemsByFilterResponse, type BulkUpdateInventoryItemsByFilterOptions, type BulkUpdateInventoryItemsByFilterRequest, type BulkUpdateInventoryItemsByFilterResponse, type BulkUpdateInventoryItemsByFilterResponseNonNullableFields, type BulkUpdateInventoryItemsOptions, type BulkUpdateInventoryItemsRequest, type BulkUpdateInventoryItemsResponse, type BulkUpdateInventoryItemsResponseNonNullableFields, type CreateInventoryItemRequest, type CreateInventoryItemResponse, type CreateInventoryItemResponseNonNullableFields, type CursorPaging, type CursorPagingMetadata, type CursorSearch, type CursorSearchPagingMethodOneOf, type Cursors, type DateHistogramAggregation, type DateHistogramResult, type DateHistogramResults, type DecrementDataById, type DecrementDataByVariantAndLocation, type DeleteInventoryItemRequest, type DeleteInventoryItemResponse, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type EventMetadata, type ExtendedFields, type File, type GetInventoryItemRequest, type GetInventoryItemResponse, type GetInventoryItemResponseNonNullableFields, type GroupByAggregation, type GroupByAggregationKindOneOf, type GroupByValueResults, type IdentificationData, type IdentificationDataIdOneOf, type IncludeMissingValuesOptions, type IncrementDataById, type IncrementDataByVariantAndLocation, Interval, type InvalidateCache, type InvalidateCacheGetByOneOf, type InventoryCursorPaging, type InventoryItem, type InventoryItemCreatedEnvelope, type InventoryItemDeletedEnvelope, type InventoryItemNonNullableFields, type InventoryItemStockStatusUpdatedEnvelope, type InventoryItemStockStatusUpdatedEvent, type InventoryItemTrackingMethodOneOf, type InventoryItemUpdatedEnvelope, type InventoryItemUpdatedWithReason, type InventoryItemUpdatedWithReasonEnvelope, type InventoryItemsQueryBuilder, type InventoryItemsQueryResult, type InventoryPaging, type InventoryQuery, type InventoryQueryPagingMethodOneOf, type ItemMetadata, type MaskedInventoryItem, type MessageEnvelope, MissingValues, Mode, type NestedAggregation, type NestedAggregationItem, type NestedAggregationItemKindOneOf, type NestedAggregationResults, type NestedAggregationResultsResultOneOf, NestedAggregationType, type NestedResultValue, type NestedResultValueResultOneOf, type NestedResults, type NestedValueAggregationResult, type Page, type PagingMetadata, type PlatformOffsetSearch, type PlatformOffsetSearchPagingMethodOneOf, type PlatformPaging, type PlatformPagingMetadataV2, type PreorderInfo, type Product, type ProductInventoryItems, type QueryInventoryItemsRequest, type QueryInventoryItemsResponse, type QueryInventoryItemsResponseNonNullableFields, type RangeAggregation, type RangeAggregationResult, type RangeBucket, type RangeResult, type RangeResults, ReasonType, type RestoreInfo, type Results, type ScalarAggregation, type ScalarResult, ScalarType, type SearchDetails, type SearchInventoryItemsOptions, type SearchInventoryItemsRequest, type SearchInventoryItemsResponse, type SearchInventoryItemsResponseNonNullableFields, type SearchInventoryItemsWithOffsetRequest, type SearchInventoryItemsWithOffsetResponse, SortDirection, SortOrder, SortType, type Sorting, type URI, type UpdateInventoryItem, type UpdateInventoryItemOptions, type UpdateInventoryItemRequest, type UpdateInventoryItemResponse, type UpdateInventoryItemResponseNonNullableFields, type V3BulkInventoryItemResult, type ValueAggregation, type ValueAggregationOptionsOneOf, type ValueAggregationResult, type ValueResult, type ValueResults, WebhookIdentityType, type _publicOnInventoryItemCreatedType, type _publicOnInventoryItemDeletedType, type _publicOnInventoryItemStockStatusUpdatedType, type _publicOnInventoryItemUpdatedType, type _publicOnInventoryItemUpdatedWithReasonType, bulkCreateInventoryItems, bulkDecrementInventoryItems, bulkDecrementInventoryItemsByVariantAndLocation, bulkDeleteInventoryItems, bulkIncrementInventoryItems, bulkIncrementInventoryItemsByVariantAndLocation, bulkUpdateInventoryItems, bulkUpdateInventoryItemsByFilter, createInventoryItem, deleteInventoryItem, getInventoryItem, onInventoryItemCreated, onInventoryItemDeleted, onInventoryItemStockStatusUpdated, onInventoryItemUpdated, onInventoryItemUpdatedWithReason, onInventoryItemCreated$1 as publicOnInventoryItemCreated, onInventoryItemDeleted$1 as publicOnInventoryItemDeleted, onInventoryItemStockStatusUpdated$1 as publicOnInventoryItemStockStatusUpdated, onInventoryItemUpdated$1 as publicOnInventoryItemUpdated, onInventoryItemUpdatedWithReason$1 as publicOnInventoryItemUpdatedWithReason, queryInventoryItems, searchInventoryItems, updateInventoryItem };
