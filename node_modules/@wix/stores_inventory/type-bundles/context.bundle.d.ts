type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface InventoryItemV2 {
    /** Inventory item ID. */
    _id?: string | null;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string | null;
    /**
     * Product ID.
     * @readonly
     */
    productId?: string | null;
    /** Whether quantity is being tracked. */
    trackQuantity?: boolean | null;
    /** Variants associated with this inventory item. */
    variants?: InventoryVariantV2[];
    /**
     * Last updated timestamp.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Inventory’s unique numeric ID (assigned in ascending order).
     * Primarily for sorting and filtering when crawling all inventories.
     * @readonly
     */
    numericId?: string;
    /** Preorder information. */
    preorderInfo?: PreorderInfo;
}
interface InventoryVariantV2 {
    /** Variant ID. */
    variantId?: string;
    /** Whether the product is listed as in stock. */
    inStock?: boolean | null;
    /** Quantity currently left in inventory. */
    quantity?: number | null;
    /**
     * Whether the variant is available for preorder. When `true`, the variant is out of stock and preorder is enabled on inventory level.
     * @readonly
     */
    availableForPreorder?: boolean;
}
interface PreorderInfo {
    /** Whether the item is available for preorder. */
    enabled?: boolean;
    /** A message the buyer will see when the item is out of stock and preorder is enabled. */
    message?: string | null;
    /** Number of products that can be preordered after stock reaches zero. */
    limit?: number | null;
}
interface InventoryItemChanged {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Whether inventory is being tracked. */
    trackInventory?: boolean;
    /** Preorder information. */
    preorderInfo?: PreorderInfo;
    /** Date and time the inventory item was last updated. */
    _updatedDate?: Date | null;
}
interface InventoryVariantsChanged {
    /** Inventory item ID. */
    inventoryItemId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Information about changed variants. */
    variants?: ChangedInventoryVariant[];
    /** Date and time the inventory variant item was last updated. */
    _updatedDate?: Date | null;
}
interface ChangedInventoryVariant {
    /** Variant ID. */
    _id?: string;
    /** Previous inventory variant data. */
    oldValue?: ChangedInventoryVariantData;
    /** Current inventory variant data. */
    newValue?: ChangedInventoryVariantData;
}
interface ChangedInventoryVariantData {
    /** Inventory variant quantity. */
    quantity?: number | null;
    /** Whether the product variant is in stock. */
    inStock?: boolean;
    /** Whether the variant is available for preorder. When `true`, the variant is out of stock and preorder is enabled on inventory level. */
    availableForPreorder?: boolean;
}
declare enum ReasonType {
    UNKNOWN = "UNKNOWN",
    ORDER = "ORDER",
    MANUAL = "MANUAL",
    REVERT_INVENTORY_CHANGE = "REVERT_INVENTORY_CHANGE"
}
interface GetInventoryVariantsRequest extends GetInventoryVariantsRequestIdOneOf {
    /** Inventory item ID. */
    inventoryId: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant IDs to query for this inventory item (optional). */
    variantIds?: string[];
}
/** @oneof */
interface GetInventoryVariantsRequestIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
}
interface GetInventoryVariantsResponse {
    /** Inventory item. */
    inventoryItem?: InventoryItemV2;
}
interface GetInventoryItemsRequest {
    /** Product IDs */
    productIds?: string[];
}
interface GetInventoryItemsResponse {
    /** Inventory items. */
    inventoryItems?: InventoryItemV2[];
}
interface QueryInventoryRequest {
    /** Information about paging, filters, sorting. */
    query?: Query;
}
interface Query {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Filter string */
    filter?: string | null;
    /** Sort string */
    sort?: string | null;
}
interface Paging {
    /** Amount of items to load per page */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number | null;
}
interface QueryInventoryResponse {
    /** Inventory items. */
    inventoryItems?: InventoryItemV2[];
    /** Display metadata. */
    metadata?: PagingMetadata;
    /** Number of total results. */
    totalResults?: number;
}
interface PagingMetadata {
    /** Amount of items to load per page */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first) */
    offset?: number;
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface UpdateInventoryVariantsRequest {
    /** Inventory item. */
    inventoryItem: InventoryItemV2;
}
interface UpdateInventoryVariantsResponse {
}
interface BulkUpdateInventoryVariantsRequest extends BulkUpdateInventoryVariantsRequestActionOneOf {
    /** Change availability. */
    setInStock?: boolean | null;
    /** Set new quantity. */
    setQuantity?: number | null;
    /** Number to increment inventory by. */
    incrementBy?: number | null;
    /** Number to decrement inventory by. */
    decrementBy?: number | null;
    /** Variants filter. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
}
/** @oneof */
interface BulkUpdateInventoryVariantsRequestActionOneOf {
    /** Change availability. */
    setInStock?: boolean | null;
    /** Set new quantity. */
    setQuantity?: number | null;
    /** Number to increment inventory by. */
    incrementBy?: number | null;
    /** Number to decrement inventory by. */
    decrementBy?: number | null;
}
interface BulkUpdateInventoryVariantsResponse {
}
interface BulkUpdateInventoryItemsRequest {
    /** Variants filter */
    variantsFilter?: Record<string, any> | null;
    /** Whether inventory is being tracked. */
    trackInventory?: boolean | null;
}
interface BulkUpdateInventoryItemsResponse {
}
interface DecrementInventoryRequest {
    /** Item or product to decrement. */
    decrementData?: DecrementData[];
}
interface DecrementData extends DecrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant ID. */
    variantId?: string;
    /** Number to decrement inventory by. */
    decrementBy?: number;
    /**
     * Whether the request to decrement the item's inventory was made as part of a purchase that includes preorder items.
     * If true and the item is available for preorder, we allow negative inventory.
     * If false and the item is not available for preorder, we allow regular buy flow (no negative inventory).
     */
    preorderRequest?: boolean;
}
/** @oneof */
interface DecrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /**
     * @internal
     * @internal
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
}
interface DecrementInventoryResponse {
}
interface IncrementInventoryRequest {
    /** Item or product to increment. */
    incrementData?: IncrementData[];
}
interface IncrementData extends IncrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant ID. */
    variantId?: string;
    /** Number to increment inventory by. */
    incrementBy?: number;
}
/** @oneof */
interface IncrementDataIdOneOf {
    /** Inventory item ID. */
    inventoryId?: string;
    /** Product ID. */
    productId?: string;
}
interface IncrementInventoryResponse {
}
interface InventoryVariantV2NonNullableFields {
    variantId: string;
    availableForPreorder: boolean;
}
interface PreorderInfoNonNullableFields {
    enabled: boolean;
}
interface InventoryItemV2NonNullableFields {
    variants: InventoryVariantV2NonNullableFields[];
    numericId: string;
    preorderInfo?: PreorderInfoNonNullableFields;
}
interface GetInventoryVariantsResponseNonNullableFields {
    inventoryItem?: InventoryItemV2NonNullableFields;
}
interface PagingMetadataNonNullableFields {
    items: number;
    offset: number;
}
interface QueryInventoryResponseNonNullableFields {
    inventoryItems: InventoryItemV2NonNullableFields[];
    metadata?: PagingMetadataNonNullableFields;
    totalResults: number;
}
interface BaseEventMetadata {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface InventoryItemChangedEnvelope {
    data: InventoryItemChanged;
    metadata: BaseEventMetadata;
}
interface InventoryVariantsChangedEnvelope {
    data: InventoryVariantsChanged;
    metadata: BaseEventMetadata;
}
interface GetInventoryVariantsOptions extends GetInventoryVariantsRequestIdOneOf {
    /**
     * @internal
     * @internal
     * @deprecated Deprecated (use productID instead).
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string;
    /** Product ID. */
    productId?: string;
    /** Variant IDs to query for this inventory item (optional). */
    variantIds?: string[];
}
interface QueryInventoryOptions {
    /** Information about paging, filters, sorting. */
    query?: Query;
}
interface UpdateInventoryVariantsInventoryItem {
    /** Inventory item ID. */
    _id?: string | null;
    /**
     * @internal
     * @internal
     * @readonly
     * @deprecated Deprecated: use productId.
     * @replacedBy product_id
     * @targetRemovalDate 2024-12-31
     */
    externalId?: string | null;
    /** Whether quantity is being tracked. */
    trackQuantity?: boolean | null;
    /** Variants associated with this inventory item. */
    variants?: InventoryVariantV2[];
    /**
     * Last updated timestamp.
     * @readonly
     */
    lastUpdated?: Date | null;
    /**
     * Inventory’s unique numeric ID (assigned in ascending order).
     * Primarily for sorting and filtering when crawling all inventories.
     * @readonly
     */
    numericId?: string;
    /** Preorder information. */
    preorderInfo?: PreorderInfo;
}

declare function getInventoryVariants$1(httpClient: HttpClient): GetInventoryVariantsSignature;
interface GetInventoryVariantsSignature {
    /**
     * Gets inventory variant information based on the specified option choices.
     *
     *
     * The `getInventoryVariants()` function returns a Promise that resolves to the specified inventory variant information.
     * @param - Inventory item ID.
     */
    (inventoryId: string, options?: GetInventoryVariantsOptions | undefined): Promise<GetInventoryVariantsResponse & GetInventoryVariantsResponseNonNullableFields>;
}
declare function queryInventory$1(httpClient: HttpClient): QueryInventorySignature;
interface QueryInventorySignature {
    /**
     * Returns a list of inventory items, given the provided paging, sorting and filtering.
     */
    (options?: QueryInventoryOptions | undefined): Promise<QueryInventoryResponse & QueryInventoryResponseNonNullableFields>;
}
declare function updateInventoryVariants$1(httpClient: HttpClient): UpdateInventoryVariantsSignature;
interface UpdateInventoryVariantsSignature {
    /**
     * Updates product inventory, including total quantity, whether the product is in stock, and whether the product inventory is tracked.
     *
     *
     * The `updateInventoryVariants()` function is a Promise that resolves to the updated inventory variant data.
     * @param - Product ID.
     * @param - Inventory item to update.
     */
    (productId: string | null, inventoryItem: UpdateInventoryVariantsInventoryItem): Promise<void>;
}
declare function decrementInventory$1(httpClient: HttpClient): DecrementInventorySignature;
interface DecrementInventorySignature {
    /**
     * Subtracts a set number of items from inventory.
     *
     *
     * The `decrementInventory()` function returns a Promise that is resolved when the specified item's quantity has been updated in the inventory.
     * @param - Item or product to decrement.
     */
    (decrementData: DecrementData[]): Promise<void>;
}
declare function incrementInventory$1(httpClient: HttpClient): IncrementInventorySignature;
interface IncrementInventorySignature {
    /**
     * Adds a set number of items to inventory.
     *
     *
     * The `incrementInventory()` function returns a Promise that is resolved when the specified item's quantity has been updated in the inventory.
     * @param - Item or product to increment.
     */
    (incrementData: IncrementData[]): Promise<void>;
}
declare const onInventoryItemChanged$1: EventDefinition<InventoryItemChangedEnvelope, "com.wix.ecommerce.inventory.api.v1.InventoryItemChanged">;
declare const onInventoryVariantsChanged$1: EventDefinition<InventoryVariantsChangedEnvelope, "com.wix.ecommerce.inventory.api.v1.InventoryVariantsChanged">;

declare function createEventModule<T extends EventDefinition<any, string>>(eventDefinition: T): BuildEventDefinition<T> & T;

declare const getInventoryVariants: MaybeContext<BuildRESTFunction<typeof getInventoryVariants$1> & typeof getInventoryVariants$1>;
declare const queryInventory: MaybeContext<BuildRESTFunction<typeof queryInventory$1> & typeof queryInventory$1>;
declare const updateInventoryVariants: MaybeContext<BuildRESTFunction<typeof updateInventoryVariants$1> & typeof updateInventoryVariants$1>;
declare const decrementInventory: MaybeContext<BuildRESTFunction<typeof decrementInventory$1> & typeof decrementInventory$1>;
declare const incrementInventory: MaybeContext<BuildRESTFunction<typeof incrementInventory$1> & typeof incrementInventory$1>;

type _publicOnInventoryItemChangedType = typeof onInventoryItemChanged$1;
/**
 * Triggered when an inventory item is changed.
 */
declare const onInventoryItemChanged: ReturnType<typeof createEventModule<_publicOnInventoryItemChangedType>>;

type _publicOnInventoryVariantsChangedType = typeof onInventoryVariantsChanged$1;
/**
 * Triggered when inventory variants are changed.
 */
declare const onInventoryVariantsChanged: ReturnType<typeof createEventModule<_publicOnInventoryVariantsChangedType>>;

export { type BaseEventMetadata, type BulkUpdateInventoryItemsRequest, type BulkUpdateInventoryItemsResponse, type BulkUpdateInventoryVariantsRequest, type BulkUpdateInventoryVariantsRequestActionOneOf, type BulkUpdateInventoryVariantsResponse, type ChangedInventoryVariant, type ChangedInventoryVariantData, type DecrementData, type DecrementDataIdOneOf, type DecrementInventoryRequest, type DecrementInventoryResponse, type GetInventoryItemsRequest, type GetInventoryItemsResponse, type GetInventoryVariantsOptions, type GetInventoryVariantsRequest, type GetInventoryVariantsRequestIdOneOf, type GetInventoryVariantsResponse, type GetInventoryVariantsResponseNonNullableFields, type IdentificationData, type IdentificationDataIdOneOf, type IncrementData, type IncrementDataIdOneOf, type IncrementInventoryRequest, type IncrementInventoryResponse, type InventoryItemChanged, type InventoryItemChangedEnvelope, type InventoryItemV2, type InventoryVariantV2, type InventoryVariantsChanged, type InventoryVariantsChangedEnvelope, type MessageEnvelope, type Paging, type PagingMetadata, type PreorderInfo, type Query, type QueryInventoryOptions, type QueryInventoryRequest, type QueryInventoryResponse, type QueryInventoryResponseNonNullableFields, ReasonType, type UpdateInventoryVariantsInventoryItem, type UpdateInventoryVariantsRequest, type UpdateInventoryVariantsResponse, WebhookIdentityType, type _publicOnInventoryItemChangedType, type _publicOnInventoryVariantsChangedType, decrementInventory, getInventoryVariants, incrementInventory, onInventoryItemChanged, onInventoryVariantsChanged, onInventoryItemChanged$1 as publicOnInventoryItemChanged, onInventoryVariantsChanged$1 as publicOnInventoryVariantsChanged, queryInventory, updateInventoryVariants };
