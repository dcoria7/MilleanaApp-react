/** A location is a physical or virtual site where products are sold. */
interface StoresLocation {
    /**
     * Stores location ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the Stores location is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the Stores location.
     *
     * Ignored when creating a Stores location.
     * @readonly
     */
    revision?: string | null;
    /**
     * Date and time the Stores location was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the Stores location was last updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Wix location ID.
     * Learn more about the [Locations API](https://dev.wix.com/docs/rest/business-management/locations/introduction).
     */
    wixLocationId?: string | null;
    /**
     * Location type.
     *
     * + `VIRTUAL`: Online store.
     * + `PHYSICAL`: Physical location. For example, for POS.
     * @readonly
     */
    locationType?: LocationType;
    /**
     * Stores location name.
     * @readonly
     */
    name?: string;
    /** Whether the location is the site's default location. */
    defaultLocation?: boolean;
}
declare enum LocationType {
    UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
    /** Online stores location. */
    VIRTUAL = "VIRTUAL",
    /** Physical location like POS */
    PHYSICAL = "PHYSICAL"
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /** tell us why you're invalidating the cache. You don't need to add your app name */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
    metaSiteId?: string;
    /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
interface App {
    /** The AppDefId */
    appDefId?: string;
    /** The instance Id */
    instanceId?: string;
}
interface Page {
    /** the msid the page is on */
    metaSiteId?: string;
    /** Invalidate by Page ID */
    pageId?: string;
}
interface URI {
    /** the msid the URI is on */
    metaSiteId?: string;
    /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
    uriPath?: string;
}
interface File {
    /** the msid the file is related to */
    metaSiteId?: string;
    /** Invalidate by filename (for media files such as PDFs) */
    fileName?: string;
}
interface CreateStoresLocationRequest {
    /** Stores location to create. */
    storesLocation?: StoresLocation;
}
interface CreateStoresLocationResponse {
    /** Created Stores location. */
    storesLocation?: StoresLocation;
}
interface GetStoresLocationRequest {
    /** Stores location ID. */
    storesLocationId: string;
}
interface GetStoresLocationResponse {
    /** Stores location. */
    storesLocation?: StoresLocation;
}
interface UpdateStoresLocationRequest {
    /** Stores location to update. */
    storesLocation?: StoresLocation;
}
interface UpdateStoresLocationResponse {
    /** Updated Stores location. */
    storesLocation?: StoresLocation;
}
interface DeleteStoresLocationRequest {
    /** Stores location ID. */
    storesLocationId?: string;
}
interface DeleteStoresLocationResponse {
}
interface QueryStoresLocationsRequest {
    /** Query options. */
    query?: CursorQuery;
}
interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
}
/** @oneof */
interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
interface Sorting {
    /** Name of the field to sort by. */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
interface CursorPaging {
    /** Number of items to load. */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     */
    cursor?: string | null;
}
interface QueryStoresLocationsResponse {
    /** List of Stores locations. */
    storesLocations?: StoresLocation[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: CursorPagingMetadata;
}
interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
interface Cursors {
    /** Cursor pointing to next page in the list of results. */
    next?: string | null;
    /** Cursor pointing to previous page in the list of results. */
    prev?: string | null;
}
interface GetOrCreateDefaultStoresLocationRequest {
}
interface GetOrCreateDefaultStoresLocationResponse {
    /** Default Stores location. */
    storesLocation?: StoresLocation;
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MessageEnvelope {
    /** App instance ID. */
    instanceId?: string | null;
    /** Event type. */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /** ID of a site visitor that has not logged in to the site. */
    anonymousVisitorId?: string;
    /** ID of a site visitor that has logged in to the site. */
    memberId?: string;
    /** ID of a Wix user (site owner, contributor, etc.). */
    wixUserId?: string;
    /** ID of an app. */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface StoresLocationNonNullableFields {
    locationType: LocationType;
    name: string;
    defaultLocation: boolean;
}
interface GetStoresLocationResponseNonNullableFields {
    storesLocation?: StoresLocationNonNullableFields;
}
interface QueryStoresLocationsResponseNonNullableFields {
    storesLocations: StoresLocationNonNullableFields[];
}
/**
 * Retrieves a Stores location.
 * @param storesLocationId - Stores location ID.
 * @public
 * @documentationMaturity preview
 * @requiredField storesLocationId
 * @permissionId WIX_STORES.STORES_LOCATION_READ
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Read Stores Locations in v3 catalog
 * @permissionScopeId SCOPE.STORES.LOCATION_READ
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns Stores location.
 */
declare function getStoresLocation(storesLocationId: string): Promise<StoresLocation & StoresLocationNonNullableFields>;
/**
 * Retrieves a list of up to 100 Stores locations, given the provided filtering, sorting, and cursor paging.
 * Pass supported values to the `fields` array in the request to include those fields in the response.
 *
 *
 * Query Stores Locations runs with these defaults, which you can override:
 *
 * - `createdDate` is sorted in `DESC` order
 * - `cursorPaging.limit` is `100`
 *
 * For field support for filters and sorting,
 * see [Stores Locations: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/stores/catalog-v3/stores-locations-v3/supported-filters-and-sorting).
 *
 * To learn about working with _Query_ endpoints, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language),
 * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
 * @public
 * @documentationMaturity preview
 * @permissionScope Read inventory in v3 catalog
 * @permissionScopeId SCOPE.STORES.INVENTORY_ITEM_READ
 * @permissionScope Read v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_READ
 * @permissionScope Manage Products
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-PRODUCTS
 * @permissionScope Read Products
 * @permissionScopeId SCOPE.DC-STORES.READ-PRODUCTS
 * @permissionScope Manage v3 catalog
 * @permissionScopeId SCOPE.STORES.CATALOG_WRITE
 * @permissionScope Read Stores Locations in v3 catalog
 * @permissionScopeId SCOPE.STORES.LOCATION_READ
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @permissionId WIX_STORES.STORES_LOCATION_READ
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 */
declare function queryStoresLocations(): StoresLocationsQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
interface StoresLocationsQueryResult extends QueryCursorResult {
    items: StoresLocation[];
    query: StoresLocationsQueryBuilder;
    next: () => Promise<StoresLocationsQueryResult>;
    prev: () => Promise<StoresLocationsQueryResult>;
}
interface StoresLocationsQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    eq: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'wixLocationId' | 'locationType' | 'name' | 'defaultLocation', value: any) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ne: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'wixLocationId' | 'locationType' | 'name' | 'defaultLocation', value: any) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    le: (propertyName: '_createdDate' | '_updatedDate', value: any) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     * @documentationMaturity preview
     */
    lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     * @documentationMaturity preview
     */
    startsWith: (propertyName: '_id' | 'wixLocationId' | 'name', value: string) => StoresLocationsQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     * @documentationMaturity preview
     */
    hasSome: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'wixLocationId' | 'locationType' | 'name' | 'defaultLocation', value: any[]) => StoresLocationsQueryBuilder;
    /** @documentationMaturity preview */
    in: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'wixLocationId' | 'locationType' | 'name' | 'defaultLocation', value: any) => StoresLocationsQueryBuilder;
    /** @documentationMaturity preview */
    exists: (propertyName: '_id' | '_createdDate' | '_updatedDate' | 'wixLocationId' | 'locationType' | 'name' | 'defaultLocation', value: boolean) => StoresLocationsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    ascending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'locationType' | 'name' | 'defaultLocation'>) => StoresLocationsQueryBuilder;
    /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
     * @documentationMaturity preview
     */
    descending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'locationType' | 'name' | 'defaultLocation'>) => StoresLocationsQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
     * @documentationMaturity preview
     */
    limit: (limit: number) => StoresLocationsQueryBuilder;
    /** @param cursor - A pointer to specific record
     * @documentationMaturity preview
     */
    skipTo: (cursor: string) => StoresLocationsQueryBuilder;
    /** @documentationMaturity preview */
    find: () => Promise<StoresLocationsQueryResult>;
}

export { type ActionEvent, type App, type CreateStoresLocationRequest, type CreateStoresLocationResponse, type CursorPaging, type CursorPagingMetadata, type CursorQuery, type CursorQueryPagingMethodOneOf, type Cursors, type DeleteStoresLocationRequest, type DeleteStoresLocationResponse, type DomainEvent, type DomainEventBodyOneOf, type Empty, type EntityCreatedEvent, type EntityDeletedEvent, type EntityUpdatedEvent, type File, type GetOrCreateDefaultStoresLocationRequest, type GetOrCreateDefaultStoresLocationResponse, type GetStoresLocationRequest, type GetStoresLocationResponse, type GetStoresLocationResponseNonNullableFields, type IdentificationData, type IdentificationDataIdOneOf, type InvalidateCache, type InvalidateCacheGetByOneOf, LocationType, type MessageEnvelope, type Page, type QueryStoresLocationsRequest, type QueryStoresLocationsResponse, type QueryStoresLocationsResponseNonNullableFields, type RestoreInfo, SortOrder, type Sorting, type StoresLocation, type StoresLocationNonNullableFields, type StoresLocationsQueryBuilder, type StoresLocationsQueryResult, type URI, type UpdateStoresLocationRequest, type UpdateStoresLocationResponse, WebhookIdentityType, getStoresLocation, queryStoresLocations };
