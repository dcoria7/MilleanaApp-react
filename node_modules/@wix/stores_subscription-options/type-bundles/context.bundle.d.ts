type HostModule<T, H extends Host> = {
    __type: 'host';
    create(host: H): T;
};
type HostModuleAPI<T extends HostModule<any, any>> = T extends HostModule<infer U, any> ? U : never;
type Host<Environment = unknown> = {
    channel: {
        observeState(callback: (props: unknown, environment: Environment) => unknown): {
            disconnect: () => void;
        } | Promise<{
            disconnect: () => void;
        }>;
    };
    environment?: Environment;
    /**
     * Optional name of the environment, use for logging
     */
    name?: string;
    /**
     * Optional bast url to use for API requests, for example `www.wixapis.com`
     */
    apiBaseUrl?: string;
    /**
     * Possible data to be provided by every host, for cross cutting concerns
     * like internationalization, billing, etc.
     */
    essentials?: {
        /**
         * The language of the currently viewed session
         */
        language?: string;
        /**
         * The locale of the currently viewed session
         */
        locale?: string;
        /**
         * Any headers that should be passed through to the API requests
         */
        passThroughHeaders?: Record<string, string>;
    };
};

type RESTFunctionDescriptor<T extends (...args: any[]) => any = (...args: any[]) => any> = (httpClient: HttpClient) => T;
interface HttpClient {
    request<TResponse, TData = any>(req: RequestOptionsFactory<TResponse, TData>): Promise<HttpResponse<TResponse>>;
    fetchWithAuth: typeof fetch;
    wixAPIFetch: (relativeUrl: string, options: RequestInit) => Promise<Response>;
    getActiveToken?: () => string | undefined;
}
type RequestOptionsFactory<TResponse = any, TData = any> = (context: any) => RequestOptions<TResponse, TData>;
type HttpResponse<T = any> = {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    request?: any;
};
type RequestOptions<_TResponse = any, Data = any> = {
    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
    url: string;
    data?: Data;
    params?: URLSearchParams;
} & APIMetadata;
type APIMetadata = {
    methodFqn?: string;
    entityFqdn?: string;
    packageName?: string;
};
type BuildRESTFunction<T extends RESTFunctionDescriptor> = T extends RESTFunctionDescriptor<infer U> ? U : never;
type EventDefinition<Payload = unknown, Type extends string = string> = {
    __type: 'event-definition';
    type: Type;
    isDomainEvent?: boolean;
    transformations?: (envelope: unknown) => Payload;
    __payload: Payload;
};
declare function EventDefinition<Type extends string>(type: Type, isDomainEvent?: boolean, transformations?: (envelope: any) => unknown): <Payload = unknown>() => EventDefinition<Payload, Type>;
type EventHandler<T extends EventDefinition> = (payload: T['__payload']) => void | Promise<void>;
type BuildEventDefinition<T extends EventDefinition<any, string>> = (handler: EventHandler<T>) => void;

type ServicePluginMethodInput = {
    request: any;
    metadata: any;
};
type ServicePluginContract = Record<string, (payload: ServicePluginMethodInput) => unknown | Promise<unknown>>;
type ServicePluginMethodMetadata = {
    name: string;
    primaryHttpMappingPath: string;
    transformations: {
        fromREST: (...args: unknown[]) => ServicePluginMethodInput;
        toREST: (...args: unknown[]) => unknown;
    };
};
type ServicePluginDefinition<Contract extends ServicePluginContract> = {
    __type: 'service-plugin-definition';
    componentType: string;
    methods: ServicePluginMethodMetadata[];
    __contract: Contract;
};
declare function ServicePluginDefinition<Contract extends ServicePluginContract>(componentType: string, methods: ServicePluginMethodMetadata[]): ServicePluginDefinition<Contract>;
type BuildServicePluginDefinition<T extends ServicePluginDefinition<any>> = (implementation: T['__contract']) => void;
declare const SERVICE_PLUGIN_ERROR_TYPE = "wix_spi_error";

type RequestContext = {
    isSSR: boolean;
    host: string;
    protocol?: string;
};
type ResponseTransformer = (data: any, headers?: any) => any;
/**
 * Ambassador request options types are copied mostly from AxiosRequestConfig.
 * They are copied and not imported to reduce the amount of dependencies (to reduce install time).
 * https://github.com/axios/axios/blob/3f53eb6960f05a1f88409c4b731a40de595cb825/index.d.ts#L307-L315
 */
type Method = 'get' | 'GET' | 'delete' | 'DELETE' | 'head' | 'HEAD' | 'options' | 'OPTIONS' | 'post' | 'POST' | 'put' | 'PUT' | 'patch' | 'PATCH' | 'purge' | 'PURGE' | 'link' | 'LINK' | 'unlink' | 'UNLINK';
type AmbassadorRequestOptions<T = any> = {
    _?: T;
    url?: string;
    method?: Method;
    params?: any;
    data?: any;
    transformResponse?: ResponseTransformer | ResponseTransformer[];
};
type AmbassadorFactory<Request, Response> = (payload: Request) => ((context: RequestContext) => AmbassadorRequestOptions<Response>) & {
    __isAmbassador: boolean;
};
type AmbassadorFunctionDescriptor<Request = any, Response = any> = AmbassadorFactory<Request, Response>;
type BuildAmbassadorFunction<T extends AmbassadorFunctionDescriptor> = T extends AmbassadorFunctionDescriptor<infer Request, infer Response> ? (req: Request) => Promise<Response> : never;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

declare const emptyObjectSymbol: unique symbol;

/**
Represents a strictly empty plain object, the `{}` value.

When you annotate something as the type `{}`, it can be anything except `null` and `undefined`. This means that you cannot use `{}` to represent an empty plain object ([read more](https://stackoverflow.com/questions/47339869/typescript-empty-object-and-any-difference/52193484#52193484)).

@example
```
import type {EmptyObject} from 'type-fest';

// The following illustrates the problem with `{}`.
const foo1: {} = {}; // Pass
const foo2: {} = []; // Pass
const foo3: {} = 42; // Pass
const foo4: {} = {a: 1}; // Pass

// With `EmptyObject` only the first case is valid.
const bar1: EmptyObject = {}; // Pass
const bar2: EmptyObject = 42; // Fail
const bar3: EmptyObject = []; // Fail
const bar4: EmptyObject = {a: 1}; // Fail
```

Unfortunately, `Record<string, never>`, `Record<keyof any, never>` and `Record<never, never>` do not work. See {@link https://github.com/sindresorhus/type-fest/issues/395 #395}.

@category Object
*/
type EmptyObject = {[emptyObjectSymbol]?: never};

/**
Returns a boolean for whether the two given types are equal.

@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650
@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796

Use-cases:
- If you want to make a conditional branch based on the result of a comparison of two types.

@example
```
import type {IsEqual} from 'type-fest';

// This type returns a boolean for whether the given array includes the given item.
// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.
type Includes<Value extends readonly any[], Item> =
	Value extends readonly [Value[0], ...infer rest]
		? IsEqual<Value[0], Item> extends true
			? true
			: Includes<rest, Item>
		: false;
```

@category Type Guard
@category Utilities
*/
type IsEqual<A, B> =
	(<G>() => G extends A ? 1 : 2) extends
	(<G>() => G extends B ? 1 : 2)
		? true
		: false;

/**
Filter out keys from an object.

Returns `never` if `Exclude` is strictly equal to `Key`.
Returns `never` if `Key` extends `Exclude`.
Returns `Key` otherwise.

@example
```
type Filtered = Filter<'foo', 'foo'>;
//=> never
```

@example
```
type Filtered = Filter<'bar', string>;
//=> never
```

@example
```
type Filtered = Filter<'bar', 'foo'>;
//=> 'bar'
```

@see {Except}
*/
type Filter<KeyType, ExcludeType> = IsEqual<KeyType, ExcludeType> extends true ? never : (KeyType extends ExcludeType ? never : KeyType);

type ExceptOptions = {
	/**
	Disallow assigning non-specified properties.

	Note that any omitted properties in the resulting type will be present in autocomplete as `undefined`.

	@default false
	*/
	requireExactProps?: boolean;
};

/**
Create a type from an object type without certain keys.

We recommend setting the `requireExactProps` option to `true`.

This type is a stricter version of [`Omit`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html#the-omit-helper-type). The `Omit` type does not restrict the omitted keys to be keys present on the given type, while `Except` does. The benefits of a stricter type are avoiding typos and allowing the compiler to pick up on rename refactors automatically.

This type was proposed to the TypeScript team, which declined it, saying they prefer that libraries implement stricter versions of the built-in types ([microsoft/TypeScript#30825](https://github.com/microsoft/TypeScript/issues/30825#issuecomment-523668235)).

@example
```
import type {Except} from 'type-fest';

type Foo = {
	a: number;
	b: string;
};

type FooWithoutA = Except<Foo, 'a'>;
//=> {b: string}

const fooWithoutA: FooWithoutA = {a: 1, b: '2'};
//=> errors: 'a' does not exist in type '{ b: string; }'

type FooWithoutB = Except<Foo, 'b', {requireExactProps: true}>;
//=> {a: number} & Partial<Record<"b", never>>

const fooWithoutB: FooWithoutB = {a: 1, b: '2'};
//=> errors at 'b': Type 'string' is not assignable to type 'undefined'.
```

@category Object
*/
type Except<ObjectType, KeysType extends keyof ObjectType, Options extends ExceptOptions = {requireExactProps: false}> = {
	[KeyType in keyof ObjectType as Filter<KeyType, KeysType>]: ObjectType[KeyType];
} & (Options['requireExactProps'] extends true
	? Partial<Record<KeysType, never>>
	: {});

/**
Returns a boolean for whether the given type is `never`.

@link https://github.com/microsoft/TypeScript/issues/31751#issuecomment-498526919
@link https://stackoverflow.com/a/53984913/10292952
@link https://www.zhenghao.io/posts/ts-never

Useful in type utilities, such as checking if something does not occur.

@example
```
import type {IsNever, And} from 'type-fest';

// https://github.com/andnp/SimplyTyped/blob/master/src/types/strings.ts
type AreStringsEqual<A extends string, B extends string> =
	And<
		IsNever<Exclude<A, B>> extends true ? true : false,
		IsNever<Exclude<B, A>> extends true ? true : false
	>;

type EndIfEqual<I extends string, O extends string> =
	AreStringsEqual<I, O> extends true
		? never
		: void;

function endIfEqual<I extends string, O extends string>(input: I, output: O): EndIfEqual<I, O> {
	if (input === output) {
		process.exit(0);
	}
}

endIfEqual('abc', 'abc');
//=> never

endIfEqual('abc', '123');
//=> void
```

@category Type Guard
@category Utilities
*/
type IsNever<T> = [T] extends [never] ? true : false;

/**
An if-else-like type that resolves depending on whether the given type is `never`.

@see {@link IsNever}

@example
```
import type {IfNever} from 'type-fest';

type ShouldBeTrue = IfNever<never>;
//=> true

type ShouldBeBar = IfNever<'not never', 'foo', 'bar'>;
//=> 'bar'
```

@category Type Guard
@category Utilities
*/
type IfNever<T, TypeIfNever = true, TypeIfNotNever = false> = (
	IsNever<T> extends true ? TypeIfNever : TypeIfNotNever
);

/**
Extract the keys from a type where the value type of the key extends the given `Condition`.

Internally this is used for the `ConditionalPick` and `ConditionalExcept` types.

@example
```
import type {ConditionalKeys} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c?: string;
	d: {};
}

type StringKeysOnly = ConditionalKeys<Example, string>;
//=> 'a'
```

To support partial types, make sure your `Condition` is a union of undefined (for example, `string | undefined`) as demonstrated below.

@example
```
import type {ConditionalKeys} from 'type-fest';

type StringKeysAndUndefined = ConditionalKeys<Example, string | undefined>;
//=> 'a' | 'c'
```

@category Object
*/
type ConditionalKeys<Base, Condition> =
{
	// Map through all the keys of the given base type.
	[Key in keyof Base]-?:
	// Pick only keys with types extending the given `Condition` type.
	Base[Key] extends Condition
	// Retain this key
	// If the value for the key extends never, only include it if `Condition` also extends never
		? IfNever<Base[Key], IfNever<Condition, Key, never>, Key>
	// Discard this key since the condition fails.
		: never;
	// Convert the produced object into a union type of the keys which passed the conditional test.
}[keyof Base];

/**
Exclude keys from a shape that matches the given `Condition`.

This is useful when you want to create a new type with a specific set of keys from a shape. For example, you might want to exclude all the primitive properties from a class and form a new shape containing everything but the primitive properties.

@example
```
import type {Primitive, ConditionalExcept} from 'type-fest';

class Awesome {
	name: string;
	successes: number;
	failures: bigint;

	run() {}
}

type ExceptPrimitivesFromAwesome = ConditionalExcept<Awesome, Primitive>;
//=> {run: () => void}
```

@example
```
import type {ConditionalExcept} from 'type-fest';

interface Example {
	a: string;
	b: string | number;
	c: () => void;
	d: {};
}

type NonStringKeysOnly = ConditionalExcept<Example, string>;
//=> {b: string | number; c: () => void; d: {}}
```

@category Object
*/
type ConditionalExcept<Base, Condition> = Except<
Base,
ConditionalKeys<Base, Condition>
>;

/**
 * Descriptors are objects that describe the API of a module, and the module
 * can either be a REST module or a host module.
 * This type is recursive, so it can describe nested modules.
 */
type Descriptors = RESTFunctionDescriptor | AmbassadorFunctionDescriptor | HostModule<any, any> | EventDefinition<any> | ServicePluginDefinition<any> | {
    [key: string]: Descriptors | PublicMetadata | any;
};
/**
 * This type takes in a descriptors object of a certain Host (including an `unknown` host)
 * and returns an object with the same structure, but with all descriptors replaced with their API.
 * Any non-descriptor properties are removed from the returned object, including descriptors that
 * do not match the given host (as they will not work with the given host).
 */
type BuildDescriptors<T extends Descriptors, H extends Host<any> | undefined, Depth extends number = 5> = {
    done: T;
    recurse: T extends {
        __type: typeof SERVICE_PLUGIN_ERROR_TYPE;
    } ? never : T extends AmbassadorFunctionDescriptor ? BuildAmbassadorFunction<T> : T extends RESTFunctionDescriptor ? BuildRESTFunction<T> : T extends EventDefinition<any> ? BuildEventDefinition<T> : T extends ServicePluginDefinition<any> ? BuildServicePluginDefinition<T> : T extends HostModule<any, any> ? HostModuleAPI<T> : ConditionalExcept<{
        [Key in keyof T]: T[Key] extends Descriptors ? BuildDescriptors<T[Key], H, [
            -1,
            0,
            1,
            2,
            3,
            4,
            5
        ][Depth]> : never;
    }, EmptyObject>;
}[Depth extends -1 ? 'done' : 'recurse'];
type PublicMetadata = {
    PACKAGE_NAME?: string;
};

declare global {
    interface ContextualClient {
    }
}
/**
 * A type used to create concerete types from SDK descriptors in
 * case a contextual client is available.
 */
type MaybeContext<T extends Descriptors> = globalThis.ContextualClient extends {
    host: Host;
} ? BuildDescriptors<T, globalThis.ContextualClient['host']> : T;

interface SubscriptionOption {
    /** Subscription option ID (auto-generated upon subscription option creation). */
    _id?: string | null;
    /** Subscription option title. */
    title?: string | null;
    /** Subscription option description (optional). */
    description?: string | null;
    /** Subscription charge times. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months. */
    subscriptionSettings?: SubscriptionSettings;
    /**
     * Discount info (optional).
     * For example, a $20 discount would be `value: 20`, `type: AMOUNT`.
     */
    discount?: Discount;
}
interface SubscriptionSettings {
    /** Frequency of recurring payment. */
    frequency?: SubscriptionFrequency;
    /** Whether subscription is renewed automatically at the end of each period. */
    autoRenewal?: boolean;
    /** Number of billing cycles before subscription ends. Ignored if `autoRenewal: true`. */
    billingCycles?: number | null;
}
/** Frequency unit of recurring payment */
declare enum SubscriptionFrequency {
    UNDEFINED = "UNDEFINED",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    YEAR = "YEAR"
}
interface Discount {
    /** Discount type. */
    type?: DiscountType;
    /** Discount value. */
    value?: number;
}
declare enum DiscountType {
    UNDEFINED = "UNDEFINED",
    /** No discount */
    AMOUNT = "AMOUNT",
    PERCENT = "PERCENT"
}
interface CreateSubscriptionOptionRequest {
    /** Subscription option info. */
    subscriptionOption: SubscriptionOption;
}
interface CreateSubscriptionOptionResponse {
    /** Newly created subscription option. */
    subscriptionOption?: SubscriptionOption;
}
interface UpdateSubscriptionOptionRequest {
    /** Subscription option info. Only the passed parameters will be updated. */
    subscriptionOption: SubscriptionOption;
}
interface UpdateSubscriptionOptionResponse {
    /** Updated subscription option. */
    subscriptionOption?: SubscriptionOption;
}
interface DeleteSubscriptionOptionRequest {
    /** ID of the subscription option to delete. */
    _id: string;
}
interface DeleteSubscriptionOptionResponse {
}
interface BulkCreateSubscriptionOptionsRequest {
    /** Subscription options info. */
    subscriptionOptions: SubscriptionOption[];
}
interface BulkCreateSubscriptionOptionsResponse {
    /** Newly created subscription options. */
    subscriptionOptions?: SubscriptionOption[];
}
interface BulkUpdateSubscriptionOptionsRequest {
    /** Subscription options info. Only the passed parameters in each subscription option will be updated. */
    subscriptionOptions: SubscriptionOption[];
}
interface BulkUpdateSubscriptionOptionsResponse {
    /** Updated subscription options. */
    subscriptionOptions?: SubscriptionOption[];
}
interface BulkDeleteSubscriptionOptionsRequest {
    /** IDs of the subscription options to delete. */
    ids: string[];
}
interface BulkDeleteSubscriptionOptionsResponse {
}
interface AssignSubscriptionOptionsToProductRequest {
    /** Product ID. */
    productId: string;
    /** Ordered array of subscription options that will be assigned to the product. Pass an empty array to remove all subscription options from the product. */
    assignedSubscriptionOptions?: SubscriptionOptionInProduct[];
}
interface SubscriptionOptionInProduct {
    /** Subscription option ID. */
    _id?: string;
    /** Whether the subscription option is hidden for the product (the default is false). */
    hidden?: boolean;
    /**
     * Subscription option title.
     * @readonly
     */
    title?: string | null;
    /**
     * Subscription option description (optional).
     * @readonly
     */
    description?: string | null;
    /**
     * Subscription payment settings. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months.
     * @readonly
     */
    subscriptionSettings?: SubscriptionSettings;
    /**
     * Discount info (optional).
     * @readonly
     */
    discount?: Discount;
}
interface AssignSubscriptionOptionsToProductResponse {
}
interface AllowOneTimePurchasesRequest {
    /** Product ID. */
    productId: string;
    /** Pass `true` to offer product by subscription and as one-time purchase. Pass `false` to offer product as subscription only. */
    allowed: boolean | null;
}
interface AllowOneTimePurchasesResponse {
}
interface GetSubscriptionOptionRequest {
    /** Subscription option ID. */
    _id: string;
}
interface GetSubscriptionOptionResponse {
    /** Subscription option. */
    subscriptionOption?: SubscriptionOption;
}
interface GetSubscriptionOptionsForProductRequest {
    /** Product ID. */
    productId: string;
    /** Whether to include hidden subscription options in the results. */
    includeHiddenSubscriptionOptions?: boolean;
}
interface GetSubscriptionOptionsForProductResponse {
    /** Subscription options. */
    subscriptionOptions?: SubscriptionOptionInProduct[];
}
interface ListSubscriptionOptionsRequest {
    /** Subscription option IDs. */
    ids?: string[];
}
interface ListSubscriptionOptionsResponse {
    /** Subscription options. */
    subscriptionOptions?: SubscriptionOption[];
}
interface CalculatePricesRequest {
    /** original price to which subscription options discount will be applied */
    price?: number;
    /** ids of subscription options which will be applied to original price */
    ids?: string[];
}
interface CalculatePricesResponse {
    /** array of calculated prices */
    prices?: SubscriptionOptionPrices[];
    /** price to which subscription options discount applied */
    originalPrice?: number;
}
interface SubscriptionOptionPrices {
    /** Subscription option id */
    _id?: string;
    /** Price data calculated for subscription option */
    priceData?: SubscriptionOptionPriceData;
    /** Price data calculated for subscription option, converted to the currency requested in request header */
    convertedPriceData?: SubscriptionOptionPriceData;
}
interface SubscriptionOptionPriceData {
    /** Subscription option price currency */
    currency?: string;
    /** Price calculated after subscription option discount applied */
    discountedPrice?: number;
    /** Price calculated after subscription option discount applied, formatted with the currency */
    formattedDiscountedPrice?: string;
}
interface BulkCalculatePricesRequest {
    /**
     * Original prices to which subscription options discount will be applied.
     * Key is identifier unique per price that can be used to match calculated prices with original price
     */
    prices?: Record<string, number>;
    /** ids of subscription options which will be applied to original price */
    ids?: string[];
}
interface BulkCalculatePricesResponse {
    /**
     * Key is identifier unique per price that can be used to match calculated prices with original price
     * Value is response with calculated prices for each subscription option
     */
    calculatedPrices?: Record<string, CalculatePricesResponse>;
}
interface BulkCalculatePricesRequestV2 {
    /** Original prices to be calculated for each corresponding product id with related subscription plan ids */
    items?: BulkCalculatePricesRequestItem[];
}
interface BulkCalculatePricesRequestItem {
    /** Calculation id (product id) */
    _id?: string;
    /**
     * Original prices to which subscription options discount will be applied.
     * Key is identifier unique per price that can be used to match calculated prices with original price
     */
    prices?: Record<string, number>;
    /** ids of subscription options which will be applied to original price. */
    subscriptionOptionIds?: string[];
}
interface BulkCalculatePricesResponseV2 {
    /**
     * Key is identifier unique per price that can be used to match calculated prices with original price
     * Value is response with calculated prices for each subscription option for each product
     */
    calculatedPricesPerProduct?: BulkCalculatePricesResponseItem[];
}
interface BulkCalculatePricesResponseItem {
    /** Calculation id (product id) */
    _id?: string;
    /**
     * Key is identifier unique per price that can be used to match calculated prices with original price
     * Value is response with calculated prices for each subscription option
     */
    calculatedPrices?: Record<string, CalculatePricesResponse>;
}
interface GetProductIdsForSubscriptionOptionRequest {
    /** Subscription option ID. */
    _id: string;
    /** Whether to include hidden products in the returned results. */
    includeHiddenProducts?: boolean;
    /** Optional pagination parameters */
    paging?: Paging;
}
interface Paging {
    /** Amount of items to load per page. */
    limit?: number | null;
    /** Number of items to skip in the display (relevant for all pages after the first). */
    offset?: number | null;
}
interface GetProductIdsForSubscriptionOptionResponse {
    /** IDs of products associated with the specified subscription option. */
    productIds?: string[];
    /** Paging metadata. */
    metadata?: PagingMetadata;
    /** Number of total results. */
    totalResults?: number;
}
interface PagingMetadata {
    /** Amount of items to load per page. */
    items?: number;
    /** Number of items to skip in the display (relevant for all pages after the first). */
    offset?: number;
}
interface GetOneTimePurchasesStatusRequest {
    /** Product ID. */
    productId: string;
}
interface GetOneTimePurchasesStatusResponse {
    /** Whether the specified product is available for one-time purchase */
    allowed?: boolean;
}
interface SubscriptionSettingsNonNullableFields {
    frequency: SubscriptionFrequency;
    autoRenewal: boolean;
}
interface DiscountNonNullableFields {
    type: DiscountType;
    value: number;
}
interface SubscriptionOptionNonNullableFields {
    subscriptionSettings?: SubscriptionSettingsNonNullableFields;
    discount?: DiscountNonNullableFields;
}
interface CreateSubscriptionOptionResponseNonNullableFields {
    subscriptionOption?: SubscriptionOptionNonNullableFields;
}
interface UpdateSubscriptionOptionResponseNonNullableFields {
    subscriptionOption?: SubscriptionOptionNonNullableFields;
}
interface BulkCreateSubscriptionOptionsResponseNonNullableFields {
    subscriptionOptions: SubscriptionOptionNonNullableFields[];
}
interface BulkUpdateSubscriptionOptionsResponseNonNullableFields {
    subscriptionOptions: SubscriptionOptionNonNullableFields[];
}
interface GetSubscriptionOptionResponseNonNullableFields {
    subscriptionOption?: SubscriptionOptionNonNullableFields;
}
interface SubscriptionOptionInProductNonNullableFields {
    _id: string;
    hidden: boolean;
    subscriptionSettings?: SubscriptionSettingsNonNullableFields;
    discount?: DiscountNonNullableFields;
}
interface GetSubscriptionOptionsForProductResponseNonNullableFields {
    subscriptionOptions: SubscriptionOptionInProductNonNullableFields[];
}
interface PagingMetadataNonNullableFields {
    items: number;
    offset: number;
}
interface GetProductIdsForSubscriptionOptionResponseNonNullableFields {
    productIds: string[];
    metadata?: PagingMetadataNonNullableFields;
    totalResults: number;
}
interface GetOneTimePurchasesStatusResponseNonNullableFields {
    allowed: boolean;
}
interface UpdateSubscriptionOption {
    /** Subscription option ID (auto-generated upon subscription option creation). */
    _id?: string | null;
    /** Subscription option title. */
    title?: string | null;
    /** Subscription option description (optional). */
    description?: string | null;
    /** Subscription charge times. For example, if `frequency: MONTH` and `billingCycles: 6`; payment will be made monthly for 6 months. */
    subscriptionSettings?: SubscriptionSettings;
    /**
     * Discount info (optional).
     * For example, a $20 discount would be `value: 20`, `type: AMOUNT`.
     */
    discount?: Discount;
}
interface AssignSubscriptionOptionsToProductOptions {
    /** Ordered array of subscription options that will be assigned to the product. Pass an empty array to remove all subscription options from the product. */
    assignedSubscriptionOptions?: SubscriptionOptionInProduct[];
}
interface GetSubscriptionOptionsForProductOptions {
    /** Whether to include hidden subscription options in the results. */
    includeHiddenSubscriptionOptions?: boolean;
}
interface GetProductIdsForSubscriptionOptionOptions {
    /** Whether to include hidden products in the returned results. */
    includeHiddenProducts?: boolean;
    /** Optional pagination parameters */
    paging?: Paging;
}

declare function createSubscriptionOption$1(httpClient: HttpClient): CreateSubscriptionOptionSignature;
interface CreateSubscriptionOptionSignature {
    /**
     * Creates a subscription option.
     * To assign to a product, call [`assignSubscriptionOptionsToProduct()`](https://www.wix.com/velo/reference/wix-stores-v2/subscriptionoptions/assign-subscription-options-to-product).
     * Subscription options that are not assigned to a product will not be visible in the Wix business manager.
     * @param - Subscription option info.
     * @returns Newly created subscription option.
     * @deprecated
     */
    (subscriptionOption: SubscriptionOption): Promise<SubscriptionOption & SubscriptionOptionNonNullableFields>;
}
declare function updateSubscriptionOption$1(httpClient: HttpClient): UpdateSubscriptionOptionSignature;
interface UpdateSubscriptionOptionSignature {
    /**
     * Updates a subscription option.
     * Only parameters passed will be updated.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Subscription option ID (auto-generated upon subscription option creation).
     * @param - Subscription option update options.
     * @returns Updated subscription option.
     * @deprecated
     */
    (_id: string | null, subscriptionOption: UpdateSubscriptionOption): Promise<SubscriptionOption & SubscriptionOptionNonNullableFields>;
}
declare function deleteSubscriptionOption$1(httpClient: HttpClient): DeleteSubscriptionOptionSignature;
interface DeleteSubscriptionOptionSignature {
    /**
     * Deletes a subscription option.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - ID of the subscription option to delete.
     * @deprecated
     */
    (_id: string): Promise<void>;
}
declare function bulkCreateSubscriptionOptions$1(httpClient: HttpClient): BulkCreateSubscriptionOptionsSignature;
interface BulkCreateSubscriptionOptionsSignature {
    /**
     * Creates multiple subscription options (up to 100).
     * To assign to a product, call [`assignSubscriptionOptionsToProduct()`](https://www.wix.com/velo/reference/wix-stores-v2/subscriptionoptions/assign-subscription-options-to-product).
     * Subscription options that are not assigned to a product will not be visible in the Wix business manager.
     * @param - Subscription options info.
     * @deprecated
     */
    (subscriptionOptions: SubscriptionOption[]): Promise<BulkCreateSubscriptionOptionsResponse & BulkCreateSubscriptionOptionsResponseNonNullableFields>;
}
declare function bulkUpdateSubscriptionOptions$1(httpClient: HttpClient): BulkUpdateSubscriptionOptionsSignature;
interface BulkUpdateSubscriptionOptionsSignature {
    /**
     * Updates multiple subscription options.
     * Only parameters passed will be updated.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Subscription options info. Only the passed parameters in each subscription option will be updated.
     * @deprecated
     */
    (subscriptionOptions: SubscriptionOption[]): Promise<BulkUpdateSubscriptionOptionsResponse & BulkUpdateSubscriptionOptionsResponseNonNullableFields>;
}
declare function bulkDeleteSubscriptionOptions$1(httpClient: HttpClient): BulkDeleteSubscriptionOptionsSignature;
interface BulkDeleteSubscriptionOptionsSignature {
    /**
     * Deletes multiple subscription options.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - IDs of the subscription options to delete.
     * @deprecated
     */
    (ids: string[]): Promise<void>;
}
declare function assignSubscriptionOptionsToProduct$1(httpClient: HttpClient): AssignSubscriptionOptionsToProductSignature;
interface AssignSubscriptionOptionsToProductSignature {
    /**
     * Assign up to 6 subscription options to a specified product.
     * Pass an empty array to remove all subscription options assigned to a product.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Product ID.
     * @param - Subscription option assignment options.
     * @deprecated
     */
    (productId: string, options?: AssignSubscriptionOptionsToProductOptions | undefined): Promise<void>;
}
declare function allowOneTimePurchases$1(httpClient: HttpClient): AllowOneTimePurchasesSignature;
interface AllowOneTimePurchasesSignature {
    /**
     * Allow for one-time purchase of a product.
     * By default, product can be sold only as part of a subscription, not as a one-time purchase.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Product ID.
     * @param - Pass `true` to offer product by subscription and as one-time purchase. Pass `false` to offer product as subscription only.
     * @deprecated
     */
    (productId: string, allowed: boolean | null): Promise<void>;
}
declare function getSubscriptionOption$1(httpClient: HttpClient): GetSubscriptionOptionSignature;
interface GetSubscriptionOptionSignature {
    /**
     * Retrieves a subscription option by ID.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Subscription option ID.
     * @returns Subscription option.
     * @deprecated
     */
    (_id: string): Promise<SubscriptionOption & SubscriptionOptionNonNullableFields>;
}
declare function getSubscriptionOptionsForProduct$1(httpClient: HttpClient): GetSubscriptionOptionsForProductSignature;
interface GetSubscriptionOptionsForProductSignature {
    /**
     * Retrieves all subscription options assigned to a specified product.
     * By default, hidden subscription options are not returned. To retrieve all subscription options you must pass `includeHiddenSubscriptionOptions = true`.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Product ID.
     * @param - Options.
     * @deprecated
     */
    (productId: string, options?: GetSubscriptionOptionsForProductOptions | undefined): Promise<GetSubscriptionOptionsForProductResponse & GetSubscriptionOptionsForProductResponseNonNullableFields>;
}
declare function getProductIdsForSubscriptionOption$1(httpClient: HttpClient): GetProductIdsForSubscriptionOptionSignature;
interface GetProductIdsForSubscriptionOptionSignature {
    /**
     * Retrieves the IDs of products associated with a specified subscription option.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Subscription option ID.
     * @param - Paging and other options.
     * @deprecated
     */
    (_id: string, options?: GetProductIdsForSubscriptionOptionOptions | undefined): Promise<GetProductIdsForSubscriptionOptionResponse & GetProductIdsForSubscriptionOptionResponseNonNullableFields>;
}
declare function getOneTimePurchasesStatus$1(httpClient: HttpClient): GetOneTimePurchasesStatusSignature;
interface GetOneTimePurchasesStatusSignature {
    /**
     * Checks whether a specified product (associated with subscription options) is available for one-time purchase.
     * <blockquote class='warning'>
     *
     * __Deprecation Notice:__
     *
     * This endpoint has been deprecated and will be removed on January 29, 2024.
     *
     * </blockquote>
     * @param - Product ID.
     * @deprecated
     */
    (productId: string): Promise<GetOneTimePurchasesStatusResponse & GetOneTimePurchasesStatusResponseNonNullableFields>;
}

declare const createSubscriptionOption: MaybeContext<BuildRESTFunction<typeof createSubscriptionOption$1> & typeof createSubscriptionOption$1>;
declare const updateSubscriptionOption: MaybeContext<BuildRESTFunction<typeof updateSubscriptionOption$1> & typeof updateSubscriptionOption$1>;
declare const deleteSubscriptionOption: MaybeContext<BuildRESTFunction<typeof deleteSubscriptionOption$1> & typeof deleteSubscriptionOption$1>;
declare const bulkCreateSubscriptionOptions: MaybeContext<BuildRESTFunction<typeof bulkCreateSubscriptionOptions$1> & typeof bulkCreateSubscriptionOptions$1>;
declare const bulkUpdateSubscriptionOptions: MaybeContext<BuildRESTFunction<typeof bulkUpdateSubscriptionOptions$1> & typeof bulkUpdateSubscriptionOptions$1>;
declare const bulkDeleteSubscriptionOptions: MaybeContext<BuildRESTFunction<typeof bulkDeleteSubscriptionOptions$1> & typeof bulkDeleteSubscriptionOptions$1>;
declare const assignSubscriptionOptionsToProduct: MaybeContext<BuildRESTFunction<typeof assignSubscriptionOptionsToProduct$1> & typeof assignSubscriptionOptionsToProduct$1>;
declare const allowOneTimePurchases: MaybeContext<BuildRESTFunction<typeof allowOneTimePurchases$1> & typeof allowOneTimePurchases$1>;
declare const getSubscriptionOption: MaybeContext<BuildRESTFunction<typeof getSubscriptionOption$1> & typeof getSubscriptionOption$1>;
declare const getSubscriptionOptionsForProduct: MaybeContext<BuildRESTFunction<typeof getSubscriptionOptionsForProduct$1> & typeof getSubscriptionOptionsForProduct$1>;
declare const getProductIdsForSubscriptionOption: MaybeContext<BuildRESTFunction<typeof getProductIdsForSubscriptionOption$1> & typeof getProductIdsForSubscriptionOption$1>;
declare const getOneTimePurchasesStatus: MaybeContext<BuildRESTFunction<typeof getOneTimePurchasesStatus$1> & typeof getOneTimePurchasesStatus$1>;

export { type AllowOneTimePurchasesRequest, type AllowOneTimePurchasesResponse, type AssignSubscriptionOptionsToProductOptions, type AssignSubscriptionOptionsToProductRequest, type AssignSubscriptionOptionsToProductResponse, type BulkCalculatePricesRequest, type BulkCalculatePricesRequestItem, type BulkCalculatePricesRequestV2, type BulkCalculatePricesResponse, type BulkCalculatePricesResponseItem, type BulkCalculatePricesResponseV2, type BulkCreateSubscriptionOptionsRequest, type BulkCreateSubscriptionOptionsResponse, type BulkCreateSubscriptionOptionsResponseNonNullableFields, type BulkDeleteSubscriptionOptionsRequest, type BulkDeleteSubscriptionOptionsResponse, type BulkUpdateSubscriptionOptionsRequest, type BulkUpdateSubscriptionOptionsResponse, type BulkUpdateSubscriptionOptionsResponseNonNullableFields, type CalculatePricesRequest, type CalculatePricesResponse, type CreateSubscriptionOptionRequest, type CreateSubscriptionOptionResponse, type CreateSubscriptionOptionResponseNonNullableFields, type DeleteSubscriptionOptionRequest, type DeleteSubscriptionOptionResponse, type Discount, DiscountType, type GetOneTimePurchasesStatusRequest, type GetOneTimePurchasesStatusResponse, type GetOneTimePurchasesStatusResponseNonNullableFields, type GetProductIdsForSubscriptionOptionOptions, type GetProductIdsForSubscriptionOptionRequest, type GetProductIdsForSubscriptionOptionResponse, type GetProductIdsForSubscriptionOptionResponseNonNullableFields, type GetSubscriptionOptionRequest, type GetSubscriptionOptionResponse, type GetSubscriptionOptionResponseNonNullableFields, type GetSubscriptionOptionsForProductOptions, type GetSubscriptionOptionsForProductRequest, type GetSubscriptionOptionsForProductResponse, type GetSubscriptionOptionsForProductResponseNonNullableFields, type ListSubscriptionOptionsRequest, type ListSubscriptionOptionsResponse, type Paging, type PagingMetadata, SubscriptionFrequency, type SubscriptionOption, type SubscriptionOptionInProduct, type SubscriptionOptionNonNullableFields, type SubscriptionOptionPriceData, type SubscriptionOptionPrices, type SubscriptionSettings, type UpdateSubscriptionOption, type UpdateSubscriptionOptionRequest, type UpdateSubscriptionOptionResponse, type UpdateSubscriptionOptionResponseNonNullableFields, allowOneTimePurchases, assignSubscriptionOptionsToProduct, bulkCreateSubscriptionOptions, bulkDeleteSubscriptionOptions, bulkUpdateSubscriptionOptions, createSubscriptionOption, deleteSubscriptionOption, getOneTimePurchasesStatus, getProductIdsForSubscriptionOption, getSubscriptionOption, getSubscriptionOptionsForProduct, updateSubscriptionOption };
